#Below are the schemas for each of our databases
---
---
#Candidates
##Each candidate gets their own table following the same pattern. The primary key is a string that contains the date that the tweet was created at. There is a list of floats that contain the coordinates of the user that posted the given tweet. There is an integer that represents the number of times the given tweet was favorited. There is also a list of strings that contains all of the different hashtags used in the tweet. Next, there is a string that represents the language that the tweet was typed in. There is a big int that represents the quoted status id. There is also an int that represents the number of times the given tweet was retweeted. Finally, there is a string that represents the unique tweet id of the tweet. 

#Polls
##The attributes of each poll are id, pollser, start_date, end_date, name, observations, responses. The ID is used as the primary key and is just an integer that increments with each poll inserted into the database. This was necessary because there was no gurantee that any attribute or small subset of attributes from the API would always be unique. The last ID used is stored in PollID_DONOTTOUCH.txt so that it can be remembered each time PollGrabber.py is run. pollster, start_date, end_date and name are all stored as strings ('text' in cql) and are taken directly from the API. 'observations' is also taken from the API but is stored as an int. 'responses' is also stored as text, but is an array of dictionaries containing the information about each choice given in the poll. After being retrieved from the database, 'eval()' is used to decipher its structure in Python.
