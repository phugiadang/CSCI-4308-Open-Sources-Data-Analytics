{"version":3,"sources":["node_modules/browser-pack/_prelude.js","compass.js","node_modules/clusterfck/lib/clusterfck.js","node_modules/clusterfck/lib/distance.js","node_modules/clusterfck/lib/hcluster.js","node_modules/clusterfck/lib/kmeans.js","src/cluster/cluster.js","src/cluster/clusterconsts.js","src/cluster/distance.js","src/consts.js","src/cp","src/gen/aggregates.js","src/gen/encodings.js","src/gen/gen.js","src/gen/marks.js","src/gen/projections.js","src/gen/specs.js","src/rank/rank.js","src/rank/rankEncodings.js","src/util.js","../vega-lite/node_modules/datalib/node_modules/d3-time/build/d3-time.js","../vega-lite/node_modules/datalib/src/bins/bins.js","../vega-lite/node_modules/datalib/src/generate.js","../vega-lite/node_modules/datalib/src/import/type.js","../vega-lite/node_modules/datalib/src/stats.js","../vega-lite/node_modules/datalib/src/time.js","../vega-lite/node_modules/datalib/src/util.js","../vega-lite/src/aggregate.js","../vega-lite/src/bin.js","../vega-lite/src/channel.js","../vega-lite/src/compiler/Model.js","../vega-lite/src/compiler/layout.js","../vega-lite/src/compiler/time.js","../vega-lite/src/data.js","../vega-lite/src/encoding.js","../vega-lite/src/fielddef.js","../vega-lite/src/mark.js","../vega-lite/src/schema/axis.schema.js","../vega-lite/src/schema/bin.schema.js","../vega-lite/src/schema/config.cell.schema.js","../vega-lite/src/schema/config.marks.schema.js","../vega-lite/src/schema/config.schema.js","../vega-lite/src/schema/config.stack.schema.js","../vega-lite/src/schema/data.schema.js","../vega-lite/src/schema/encoding.schema.js","../vega-lite/src/schema/fielddef.schema.js","../vega-lite/src/schema/legend.schema.js","../vega-lite/src/schema/mark.schema.js","../vega-lite/src/schema/scale.schema.js","../vega-lite/src/schema/schema.js","../vega-lite/src/schema/schemautil.js","../vega-lite/src/schema/sort.schema.js","../vega-lite/src/shorthand.js","../vega-lite/src/spec.js","../vega-lite/src/timeunit.js","../vega-lite/src/type.js","../vega-lite/src/util.js","../vega-lite/src/validate.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","cp","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,2,"hcluster","Kmeans","kmeans","./hcluster","./kmeans",3,"euclidean","v1","v2","total","Math","pow","sqrt","manhattan","abs","max",4,"distances","HierarchicalClustering","distance","linkage","threshold","undefined","Infinity","prototype","cluster","items","snapshotPeriod","snapshotCb","clusters","dists","mins","index","value","key","size","j","dist","merged","mergeClosest","forEach","minKey","min","c1","c2","left","right","splice","ci","key1","key2","snapshot","snapshotCallback","./distance",5,"KMeans","centroids","randomCentroids","points","k","slice","sort","round","random","classify","point","ceil","assignment","Array","iterations","movement","assigned","push","centroid","newCentroid","sum","toJSON","JSON","stringify","fromJSON","json","parse","vectors",6,"specs","opt","table","clusterTrees","clusterfck","e1","e2","s1","vlShorthand","shorten","s2","consts","CLUSTER_THRESHOLD","map","tree","util","traverse","spec1","spec2","_info","score","filter","cluster1","cluster2","../util","./clusterconsts","vega-lite/src/shorthand",7,"reduceTupleToTable","x","b","d","c","SWAPPABLE","DIST_MISSING","DIST_BY_CHANNEL","reduce",8,"vlSpec","len","extendedSpecs","extendSpecWithChannelByColumnName","shorthands","diff","sj","si","get","extendedSpec1","extendedSpec2","cols","union","keys","channelByField","column","channel","isStack1","isStack","isStack2","encoding","color","field","detail","spec","_channelByField","duplicate","mark","vega-lite/src/spec",9,"gen","rank","X","Y","ROW","COL","SIZE","SHAPE","COLOR","TEXT","DETAIL","Type","Nominal","Ordinal","Quantitative","Temporal","projections","type","properties","omitDotPlot","default","description","maxCardinalityForAutoAddOrdinal","alwaysAddHistogram","aggregates","config","data","tableTypes","enum","genDimQ","minCardinalityForBin","omitMeasureOnly","omitDimensionOnly","addCountForDimensionOnly","aggrList","timeUnitList","consistentAutoQ","encodings","markList","encodingTypeList","requiredEncodings","supportedEncodings","maxGoodCardinalityForFacets","maxCardinalityForFacets","maxGoodCardinalityForColor","maxCardinalityForColor","maxCardinalityForShape","omitTranpose","omitDotPlotWithExtraEncoding","omitMultipleRetinalEncodings","omitNonTextAggrWithAllDimsOnFacets","omitOneDimensionCount","omitSizeOnBar","omitStackedAverage","alwaysGenerateTableAsHeatmap",10,"auto","./cluster/cluster","./consts","./gen/gen","./rank/rank","./util",11,"genAggregates","output","fieldDefs","stats","emit","fieldSet","fieldDef","shortenFieldDef","join","DELIM","checkAndPush","hasMeasure","hasDimension","hasRaw","tf","vlFieldDef","isDimension","aggregate","count","pop","assignAggrQ","hasAggr","autoMode","canHaveAggr","cantHaveAggr","assignField","assignBinQ","bin","assignQ","_aggregate","_raw","_bin","AUTO","isin","hasNorO","highCardinality","cardinality","isAuto","genBin","genCast","assignTimeUnitT","timeUnit","assignT","_timeUnit","vlSchemaUtil","extend","any","../consts","vega-lite/src/fielddef","vega-lite/src/schema/schemautil",12,"retinalEncRules","shape","colorRules","isMeasure","shapeRules","dimMeaTransposeRule","y","generalRules","text","genMarks","satisfyRules","geo","arc","row","genEncodings","isAggrWithAllDimOnFacets","isDimX","isDimY","vlEncoding","isAggregate","tmpEncoding","isDim","rules","dimension","measure","multiple","hasOtherO","./marks","vega-lite/src/encoding",13,"marks","charts","flat","getOpt","fieldSets","genAggr","level","encs","nestedReduce","nestedMap","./aggregates","./encodings","./projections","./specs",14,"getMarks","facetRule","facetsRule","pointRule","xIsDim","yIsDim","tickRule","barRule","aggEitherXorY","eitherXorYisDimOrNull","lineRule","areaRule","textRule","vlValidate","marksRule","rule","bar","line","area","tick","getEncodingMappingError","vega-lite/src/validate",15,"selected","fieldsToAdd","hasSelectedDimension","hasSelectedMeasure","indices","isCount","compareFieldsToAdd","setsToAdd","chooseKorLess","setToAdd","concat","typeIsMeasureScore","nominal","ordinal","temporal","quantitative","projection",16,"genSpecsFromFieldDefs","nested","dict","genSpecsFromEncodings","list","finalTouch","stat","stdev","mean","scale","zero","../rank/rank",17,"./rankEncodings",18,"rankEncodings","features","channels","encodingMappingByField","mappings","reasons","m","Assign","scores","role","reason","apply","UNUSED_POSITION","MARK_SCORE","p","vlChannel","circle","square","D","M","BAD","TERRIBLE","minor","pos","Y_T","facet_text","facet_good","facet_ok","facet_bad","color_good","color_ok","color_bad","color_stack","bad","terrible","dimensionScore","hasOrder","isStacked","measureScore","vega-lite/src/channel",19,"isArray","obj","toString","item","array","indexOf","sp","thisArg","arr","collection","v","nonEmpty","grp","node","Object","create","DEFAULT_OPT","powerset","ps","subset","sub","chooseK","kArray","cross",20,"factory","d3_time","newInterval","floori","offseti","interval","date","Date","floor","d0","d1","offset","step","range","start","stop","test","setTime","end","t0","t1","every","isFinite","weekday","setHours","setDate","getDate","getDay","getTimezoneOffset","utcWeekday","setUTCHours","setUTCDate","getUTCDate","getUTCDay","millisecond","second","setMilliseconds","getSeconds","minute","setSeconds","getMinutes","hour","setMinutes","getHours","day","sunday","monday","tuesday","wednesday","thursday","friday","saturday","month","setMonth","getMonth","getFullYear","year","setFullYear","utcSecond","setUTCMilliseconds","getUTCSeconds","utcMinute","setUTCSeconds","getUTCMinutes","utcHour","setUTCMinutes","getUTCHours","utcDay","utcSunday","utcMonday","utcTuesday","utcWednesday","utcThursday","utcFriday","utcSaturday","utcMonth","setUTCMonth","getUTCMonth","getUTCFullYear","utcYear","setUTCFullYear","milliseconds","seconds","minutes","hours","days","sundays","mondays","tuesdays","wednesdays","thursdays","fridays","saturdays","weeks","months","years","utcMillisecond","utcMilliseconds","utcSeconds","utcMinutes","utcHours","utcDays","utcSundays","utcMondays","utcTuesdays","utcWednesdays","utcThursdays","utcFridays","utcSaturdays","utcWeeks","utcMonths","utcYears","version","week","utcWeek",21,"bins","minstep","precision","eps","maxb","maxbins","base","logb","log","div","span","steps","bisect","unit","lo","hi","mid","cmp","EPSILON","date_value","date_index","time","units","utc","dmin","dmax","minb","minbins","find","raw","../time",22,"repeat","val","zeros","arguments","uniform","samples","pdf","cdf","icdf","NaN","integer","normal","next","rds","exp","PI","cd","z","Z","SQRT2",23,"annotation","types","TYPES","values","$","isString","isValid","isDate","isNumber","isBoolean","typeAll","fields","infer","TESTS","inferAll","PARSERS","boolean","number","string","isNaN","all","parsers",24,"unique","results","valid","missing","distinct","median","quantile","quartile","q","identity","H","h","delta","variance","M2","modeskew","avg","med","std","extent","dot","isFunction","L2","cohensd","x1","x2","n1","n2","covariance","vx","vy","xm","ym","mu","idx","comparator","tie","cor","fn","mua","mub","sda","sdb","ra","rb","aa","bb","ab","A","mat","B","linearRegression","res","xy","sx","sy","slope","icept","fit","intercept","R","rss","alpha","SE","nullH","gaussian","pairedTest","diffs","twoSampleTest","meanDiff","entropy","counts","LN2","mutual","px","py","I","info","profile","sd","vals","q1","q3","summary","__summary__","./generate","./import/type",25,"tempDate","entry","STEPS","toUnitMap","baseDate","utcBaseDate","UTC","locale","d3-time",26,"util_escape_str","replace","escape_str_re","strrep","str","truncateOnWord","rev","cnt","tok","split","truncate_word_re","reverse","w","trim","buffer","FNAME","namedfunc","name","equal","toMap","keystr","String","isObject","isBuffer","Buffer","format","field_re","match","accessor","mutator","$func","op","$valid","$length","$in","$year","$month","$date","dates","$day","weekdays","$hour","$minute","$second","$utcYear","$utcMonth","$utcDate","$utcDay","$utcHour","$utcMinute","$utcSecond","sign","numcmp","stablesort","sortBy","keyFn","sa","sb","pad","padchar","truncate","word","ellipsis","l1","l2","./time",27,"AGGREGATE_OPS","SHARED_DOMAIN_OPS",28,"MAXBINS_DEFAULT",29,"supportMark","getSupportedMark","COLUMN","getSupportedRole","Channel","CHANNELS",30,"bin_1","channel_1","data_1","layout_1","mark_1","schema","schemaUtil","type_1","util_1","Model","theme","defaults","instantiate","_spec","merge","getFullName","_stack","getStackProperties","_layout","compileLayout","stackChannel","has","is","BAR","AREA","isXMeasure","isYMeasure","groupbyChannel","fieldChannel","layout","stack","toSpec","excludeConfig","excludeData","subtract","datum","prefn","nofn","binSuffix","noAggregate","fieldTitle","COUNT_DISPLAYNAME","toUpperCase","numberFormat","init","isOrdinalScale","contains","NOMINAL","ORDINAL","TEMPORAL","isFacet","dataTable","SUMMARY","SOURCE","hasValues","markOpacity","opacity","POINT","TICK","CIRCLE","SQUARE","../bin","../channel","../data","../encoding","../fielddef","../mark","../schema/schema","../schema/schemautil","../type","./layout",31,"model","cellWidth","getCellWidth","cellHeight","getCellHeight","width","getWidth","height","getHeight","LAYOUT","bandWidth",32,"filterNull","yearstat","formula","labelTemplate","abbreviated","postfix","domain","isColor",33,"STACKED","QUANTITATIVE","./type",34,"countRetinal","./channel",35,"_isFieldDimension","displayName","getbins","./bin","./compiler/time",36,"Mark","LINE",37,"axis","grid","layer","orient","ticks","minimum","title","labelMaxLength","titleMaxLength","titleOffset","shortTimeNames",38,"supportedTypes",39,"cellConfig","padding","gridColor","gridOpacity","maximum","gridOffset","fill","fillOpacity","stroke","strokeWidth","strokeOpacity","strokeDash","strokeDashOffset",40,"marksConfig","filled","interpolate","tension","align","angle","baseline","dx","dy","font","fontStyle","fontWeight","radius","theta",41,"config_stack_schema_1","config_cell_schema_1","config_marks_schema_1","viewport","background","scene","textCellWidth","sortLineBy","stackConfig","cell","singleBarOffset","characterWidth","timeFormat","./config.cell.schema","./config.marks.schema","./config.stack.schema",42,"oneOf",43,"formatType","url","additionalProperties","calculate","expr",44,"schemautil_1","axis_schema_1","legend_schema_1","sort_schema_1","fielddef_schema_1","requiredNameType","required","typicalField","facet","onlyOrdinalField","legend","quantitativeRange","minItems","maxItems","./axis.schema","./fielddef.schema","./legend.schema","./schemautil","./sort.schema",45,"bin_schema_1","scale_schema_1","aggregate_1","timeunit_1","TIMEUNITS","supportedEnums","","typicalScale","ordinalOnlyScale","../aggregate","../timeunit","./bin.schema","./scale.schema",46,47,48,"ordinalScaleMixin","outerPadding","typicalScaleMixin","clamp","nice","exponent","useRawDomain",49,"mark_schema_1","config_schema_1","data_schema_1","encoding_schema_1","$schema","./config.schema","./data.schema","./encoding.schema","./mark.schema",50,"isEmpty","instance","changes","prop","def","ins","dest","src","_i","merge_","hasOwnProperty","constructor",51,"order",52,"ASSIGN","shortenEncoding","shorthand","shift","parseEncoding","encodingShorthand","enctype","fieldDefShorthand","parseFieldDef","FUNC","TYPE","SHORT_TYPE","shortenFieldDefs","delim","TYPE_FROM_SHORT_TYPE","substr","tu","./aggregate","./encoding","./mark","./timeunit",53,"alwaysNoOcclusion","getCleanSpec","Model_1","transpose","oldenc","./compiler/Model",54,55,"typeString","toLowerCase","Q","T","O","N",56,"__export","dlBin","error","message","console","datalib/src/bins/bins","datalib/src/generate","datalib/src/stats","datalib/src/util",57,"requiredChannelMap","supportedChannelMap","DEFAULT_REQUIRED_CHANNEL_MAP","DEFAULT_SUPPORTED_CHANNEL_TYPE","requiredChannels","supportedChannels"],"mappings":"CAAA,SAAAA,GAAA,GAAA,gBAAAC,UAAA,mBAAAC,QAAAA,OAAAD,QAAAD,QAAA,IAAA,kBAAAG,SAAAA,OAAAC,IAAAD,UAAAH,OAAA,CAAA,GAAAK,EAAAA,GAAA,mBAAAC,QAAAA,OAAA,mBAAAC,QAAAA,OAAA,mBAAAC,MAAAA,KAAAC,KAAAJ,EAAAK,GAAAV,MAAA,WAAA,GAAAG,EAAA,OAAA,SAAAQ,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAE,GAAA,kBAAAC,UAAAA,OAAA,KAAAF,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAAA,IAAAI,EAAA,MAAAA,GAAAJ,GAAA,EAAA,IAAAhB,GAAA,GAAAqB,OAAA,uBAAAL,EAAA,IAAA,MAAAhB,GAAAsB,KAAA,mBAAAtB,EAAA,GAAAuB,GAAAV,EAAAG,IAAAf,WAAAW,GAAAI,GAAA,GAAAQ,KAAAD,EAAAtB,QAAA,SAAAU,GAAA,GAAAE,GAAAD,EAAAI,GAAA,GAAAL,EAAA,OAAAI,GAAAF,EAAAA,EAAAF,IAAAY,EAAAA,EAAAtB,QAAAU,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAf,QAAA,IAAA,GAAAmB,GAAA,kBAAAD,UAAAA,QAAAH,EAAA,EAAAA,EAAAF,EAAAW,OAAAT,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,KAAAW,GAAA,SAAAP,EAAAjB,EAAAD,SCEM0B,GAAG,SAASR,EAAQjB,EAAOD,GCFjCC,EAAAD,SACA2B,SAAAT,EAAA,cACAU,OAAAV,EAAA,YACAW,OAAAX,EAAA,YAAAW,UDKGC,aAAa,EAAEC,WAAW,IAAIC,GAAG,SAASd,EAAQjB,EAAOD,GER5DC,EAAAD,SACAiC,UAAA,SAAAC,EAAAC,GAEA,IAAA,GADAC,GAAA,EACAjB,EAAA,EAAAA,EAAAe,EAAAV,OAAAL,IACAiB,GAAAC,KAAAC,IAAAH,EAAAhB,GAAAe,EAAAf,GAAA,EAEA,OAAAkB,MAAAE,KAAAH,IAEAI,UAAA,SAAAN,EAAAC,GAEA,IAAA,GADAC,GAAA,EACAjB,EAAA,EAAAA,EAAAe,EAAAV,OAAAL,IACAiB,GAAAC,KAAAI,IAAAN,EAAAhB,GAAAe,EAAAf,GAEA,OAAAiB,IAEAM,IAAA,SAAAR,EAAAC,GAEA,IAAA,GADAO,GAAA,EACAvB,EAAA,EAAAA,EAAAe,EAAAV,OAAAL,IACAuB,EAAAL,KAAAK,IAAAA,EAAAL,KAAAI,IAAAN,EAAAhB,GAAAe,EAAAf,IAEA,OAAAuB,UFYMC,GAAG,SAASzB,EAAQjB,EAAOD,GGhCjC,GAAA4C,GAAA1B,EAAA,cAEA2B,EAAA,SAAAC,EAAAC,EAAAC,GACAxC,KAAAsC,SAAAA,EACAtC,KAAAuC,QAAAA,EACAvC,KAAAwC,UAAAC,QAAAD,EAAAE,EAAAA,EAAAF,EAGAH,GAAAM,WACAC,QAAA,SAAAC,EAAAC,EAAAC,GACA/C,KAAAgD,YACAhD,KAAAiD,SACAjD,KAAAkD,QACAlD,KAAAmD,QAEA,KAAA,GAAAxC,GAAA,EAAAA,EAAAkC,EAAA7B,OAAAL,IAAA,CACA,GAAAiC,IACAQ,MAAAP,EAAAlC,GACA0C,IAAA1C,EACAwC,MAAAxC,EACA2C,KAAA,EAEAtD,MAAAgD,SAAArC,GAAAiC,EACA5C,KAAAmD,MAAAxC,GAAAiC,EACA5C,KAAAiD,MAAAtC,MACAX,KAAAkD,KAAAvC,GAAA,EAGA,IAAA,GAAAA,GAAA,EAAAA,EAAAX,KAAAgD,SAAAhC,OAAAL,IACA,IAAA,GAAA4C,GAAA,EAAA5C,GAAA4C,EAAAA,IAAA,CACA,GAAAC,GAAA7C,GAAA4C,EAAAb,EAAAA,EACA1C,KAAAsC,SAAAtC,KAAAgD,SAAArC,GAAAyC,MAAApD,KAAAgD,SAAAO,GAAAH,MACApD,MAAAiD,MAAAtC,GAAA4C,GAAAC,EACAxD,KAAAiD,MAAAM,GAAA5C,GAAA6C,EAEAA,EAAAxD,KAAAiD,MAAAtC,GAAAX,KAAAkD,KAAAvC,MACAX,KAAAkD,KAAAvC,GAAA4C,GAOA,IAFA,GAAAE,GAAAzD,KAAA0D,eACA/C,EAAA,EACA8C,GACAV,GAAApC,IAAAmC,GAAA,GACAC,EAAA/C,KAAAgD,UAEAS,EAAAzD,KAAA0D,cASA,OANA1D,MAAAgD,SAAAW,QAAA,SAAAf,SAEAA,GAAAS,UACAT,GAAAO,QAGAnD,KAAAgD,UAGAU,aAAA,WAGA,IAAA,GADAE,GAAA,EAAAC,EAAAnB,EAAAA,EACA/B,EAAA,EAAAA,EAAAX,KAAAgD,SAAAhC,OAAAL,IAAA,CACA,GAAA0C,GAAArD,KAAAgD,SAAArC,GAAA0C,IACAG,EAAAxD,KAAAiD,MAAAI,GAAArD,KAAAkD,KAAAG,GACAQ,GAAAL,IACAI,EAAAP,EACAQ,EAAAL,GAGA,GAAAK,GAAA7D,KAAAwC,UACA,OAAA,CAGA,IAAAsB,GAAA9D,KAAAmD,MAAAS,GACAG,EAAA/D,KAAAmD,MAAAnD,KAAAkD,KAAAU,IAGAH,GACAO,KAAAF,EACAG,MAAAF,EACAV,IAAAS,EAAAT,IACAC,KAAAQ,EAAAR,KAAAS,EAAAT,KAGAtD,MAAAgD,SAAAc,EAAAX,OAAAM,EACAzD,KAAAgD,SAAAkB,OAAAH,EAAAZ,MAAA,GACAnD,KAAAmD,MAAAW,EAAAT,KAAAI,CAGA,KAAA,GAAA9C,GAAA,EAAAA,EAAAX,KAAAgD,SAAAhC,OAAAL,IAAA,CACA,GACA6C,GADAW,EAAAnE,KAAAgD,SAAArC,EAEAmD,GAAAT,KAAAc,EAAAd,IACAG,EAAAd,EAAAA,EAEA,UAAA1C,KAAAuC,SACAiB,EAAAxD,KAAAiD,MAAAa,EAAAT,KAAAc,EAAAd,KACArD,KAAAiD,MAAAa,EAAAT,KAAAc,EAAAd,KAAArD,KAAAiD,MAAAc,EAAAV,KAAAc,EAAAd,OACAG,EAAAxD,KAAAiD,MAAAc,EAAAV,KAAAc,EAAAd,OAGA,YAAArD,KAAAuC,SACAiB,EAAAxD,KAAAiD,MAAAa,EAAAT,KAAAc,EAAAd,KACArD,KAAAiD,MAAAa,EAAAT,KAAAc,EAAAd,KAAArD,KAAAiD,MAAAc,EAAAV,KAAAc,EAAAd,OACAG,EAAAxD,KAAAiD,MAAAc,EAAAV,KAAAc,EAAAd,OAIAG,EADA,WAAAxD,KAAAuC,SACAvC,KAAAiD,MAAAa,EAAAT,KAAAc,EAAAd,KAAAS,EAAAR,KACAtD,KAAAiD,MAAAc,EAAAV,KAAAc,EAAAd,KAAAU,EAAAT,OAAAQ,EAAAR,KAAAS,EAAAT,MAGAtD,KAAAsC,SAAA6B,EAAAf,MAAAU,EAAAV,OAGApD,KAAAiD,MAAAa,EAAAT,KAAAc,EAAAd,KAAArD,KAAAiD,MAAAkB,EAAAd,KAAAS,EAAAT,KAAAG,EAKA,IAAA,GAAA7C,GAAA,EAAAA,EAAAX,KAAAgD,SAAAhC,OAAAL,IAAA,CACA,GAAAyD,GAAApE,KAAAgD,SAAArC,GAAA0C,GACA,IAAArD,KAAAkD,KAAAkB,IAAAN,EAAAT,KAAArD,KAAAkD,KAAAkB,IAAAL,EAAAV,IAAA,CAEA,IAAA,GADAQ,GAAAO,EACAb,EAAA,EAAAA,EAAAvD,KAAAgD,SAAAhC,OAAAuC,IAAA,CACA,GAAAc,GAAArE,KAAAgD,SAAAO,GAAAF,GACArD,MAAAiD,MAAAmB,GAAAC,GAAArE,KAAAiD,MAAAmB,GAAAP,KACAA,EAAAQ,GAGArE,KAAAkD,KAAAkB,GAAAP,EAEA7D,KAAAgD,SAAArC,GAAAwC,MAAAxC,EAOA,aAHAmD,GAAAT,UAAAU,GAAAV,UACAS,GAAAX,YAAAY,GAAAZ,OAEA,GAIA,IAAAhC,GAAA,SAAA0B,EAAAP,EAAAC,EAAAC,EAAA8B,EAAAC,GACAjC,EAAAA,GAAA,YACAC,EAAAA,GAAA,UAEA,gBAAAD,KACAA,EAAAF,EAAAE,GAEA,IAAAU,GAAA,GAAAX,GAAAC,EAAAC,EAAAC,GACAI,QAAAC,EAAAyB,EAAAC,EAEA,OAAA9B,UAAAD,EACAQ,EAAA,GAEAA,EAGAvD,GAAAD,QAAA2B,IHmCGqD,aAAa,IAAIC,GAAG,SAAS/D,EAAQjB,EAAOD,GIjM/C,QAAAkF,GAAAC,GACA3E,KAAA2E,UAAAA,MAHA,GAAAvC,GAAA1B,EAAA,aAMAgE,GAAA/B,UAAAiC,gBAAA,SAAAC,EAAAC,GACA,GAAAH,GAAAE,EAAAE,MAAA,EAIA,OAHAJ,GAAAK,KAAA,WACA,MAAAnD,MAAAoD,MAAApD,KAAAqD,UAAA,KAEAP,EAAAI,MAAA,EAAAD,IAGAJ,EAAA/B,UAAAwC,SAAA,SAAAC,EAAA9C,GACA,GAAAuB,GAAAnB,EAAAA,EACAS,EAAA,CAEAb,GAAAA,GAAA,YACA,gBAAAA,KACAA,EAAAF,EAAAE,GAGA,KAAA,GAAA3B,GAAA,EAAAA,EAAAX,KAAA2E,UAAA3D,OAAAL,IAAA,CACA,GAAA6C,GAAAlB,EAAA8C,EAAApF,KAAA2E,UAAAhE,GACAkD,GAAAL,IACAK,EAAAL,EACAL,EAAAxC,GAIA,MAAAwC,IAGAuB,EAAA/B,UAAAC,QAAA,SAAAiC,EAAAC,EAAAxC,EAAAQ,EAAAC,GACA+B,EAAAA,GAAAjD,KAAAK,IAAA,EAAAL,KAAAwD,KAAAxD,KAAAE,KAAA8C,EAAA7D,OAAA,KAEAsB,EAAAA,GAAA,YACA,gBAAAA,KACAA,EAAAF,EAAAE,IAGAtC,KAAA2E,UAAA3E,KAAA4E,gBAAAC,EAAAC,EAOA,KALA,GAAAQ,GAAA,GAAAC,OAAAV,EAAA7D,QACAgC,EAAA,GAAAuC,OAAAT,GAEAU,EAAA,EACAC,GAAA,EACAA,GAAA,CAEA,IAAA,GAAA9E,GAAA,EAAAA,EAAAkE,EAAA7D,OAAAL,IACA2E,EAAA3E,GAAAX,KAAAmF,SAAAN,EAAAlE,GAAA2B,EAIAmD,IAAA,CACA,KAAA,GAAAlC,GAAA,EAAAuB,EAAAvB,EAAAA,IAAA,CAEA,IAAA,GADAmC,MACA/E,EAAA,EAAAA,EAAA2E,EAAAtE,OAAAL,IACA2E,EAAA3E,IAAA4C,GACAmC,EAAAC,KAAAd,EAAAlE,GAIA,IAAA+E,EAAA1E,OAAA,CAOA,IAAA,GAHA4E,GAAA5F,KAAA2E,UAAApB,GACAsC,EAAA,GAAAN,OAAAK,EAAA5E,QAEApB,EAAA,EAAAA,EAAAgG,EAAA5E,OAAApB,IAAA,CAEA,IAAA,GADAkG,GAAA,EACAnF,EAAA,EAAAA,EAAA+E,EAAA1E,OAAAL,IACAmF,GAAAJ,EAAA/E,GAAAf,EAEAiG,GAAAjG,GAAAkG,EAAAJ,EAAA1E,OAEA6E,EAAAjG,IAAAgG,EAAAhG,KACA6F,GAAA,GAIAzF,KAAA2E,UAAApB,GAAAsC,EACA7C,EAAAO,GAAAmC,GAGA3C,GAAAyC,IAAA1C,GAAA,GACAC,EAAAC,GAIA,MAAAA,IAGA0B,EAAA/B,UAAAoD,OAAA,WACA,MAAAC,MAAAC,UAAAjG,KAAA2E,YAGAD,EAAA/B,UAAAuD,SAAA,SAAAC,GAEA,MADAnG,MAAA2E,UAAAqB,KAAAI,MAAAD,GACAnG,MAGAP,EAAAD,QAAAkF,EAEAjF,EAAAD,QAAA6B,OAAA,SAAAgF,EAAAvB,GACA,OAAA,GAAAJ,IAAA9B,QAAAyD,EAAAvB,MJsMGN,aAAa,IAAI8B,GAAG,SAAS5F,EAAQjB,EAAOD,GKlT/C,YAWA,SAAAoD,GAAA2D,EAAAC,GAEA,GAAAhD,GAAAZ,EAAAN,SAAAmE,MAAAF,GAEAG,EAAAC,EAAAxF,SAAAoF,EAAA,SAAAK,EAAAC,GACA,GAAAC,GAAAC,EAAAC,QAAAJ,GACAK,EAAAF,EAAAC,QAAAH,EACA,OAAArD,GAAAsD,GAAAG,IACA,UAAAC,EAAAC,mBAEAnE,EAAA0D,EAAAU,IAAA,SAAAC,GACA,MAAAC,GAAAC,SAAAF,QAEAD,IAAA,SAAAxE,GACA,MAAAA,GAAAoC,KAAA,SAAAwC,EAAAC,GAEA,MAAAA,GAAAC,MAAAC,MAAAH,EAAAE,MAAAC,UAEAC,OAAA,SAAAhF,GACA,MAAAA,GAAA5B,OAAA,IACAgE,KAAA,SAAA6C,EAAAC,GAEA,MAAAA,GAAA,GAAAJ,MAAAC,MAAAE,EAAA,GAAAH,MAAAC,OAKA,OAFA3E,GAAAQ,KAAAA,EAEAR,EApCAvD,EAAAD,QAAAoD,CAEA,IAAAmE,GAAArG,EAAA,2BACAiG,EAAAjG,EAAA,cACAwG,EAAAxG,EAAA,mBACA4G,EAAA5G,EAAA,UAEAkC,GAAAN,SAAA5B,EAAA,gBLkVGqH,UAAU,GAAGC,kBAAkB,EAAExD,aAAa,EAAEmC,WAAa,EAAEsB,0BAA0B,KAAKC,GAAG,SAASxH,EAAQjB,EAAOD,GM3V5H,YAQA,SAAA2I,GAAA9H,EAAA+H,GACA,GAAA3H,GAAA2H,EAAA,GAAAC,EAAAD,EAAA,GAAAE,EAAAF,EAAA,EAIA,OAHA/H,GAAAI,GAAAJ,EAAAI,OACAJ,EAAAgI,GAAAhI,EAAAgI,OACAhI,EAAAI,GAAA4H,GAAAhI,EAAAgI,GAAA5H,GAAA6H,EACAjI,EAXA,GAAAkI,GAAA9I,EAAAD,UAEA+I,GAAAC,UAAA,IACAD,EAAAE,aAAA,EACAF,EAAApB,kBAAA,EAUAoB,EAAAG,kBAEA,IAAA,IAAAH,EAAAC,YACA,MAAA,SAAAD,EAAAC,YAGA,QAAA,QAAAD,EAAAC,YACA,QAAA,SAAAD,EAAAC,YACA,SAAA,QAAAD,EAAAC,YAGA,OAAA,QAAAD,EAAAC,YACAG,OAAAR,WN8VMS,GAAG,SAASlI,EAAQjB,EAAOD,GO1XjC,YAEA,IAAAqJ,GAAAnI,EAAA,sBACAqG,EAAArG,EAAA,2BACAwG,EAAAxG,EAAA,mBACA4G,EAAA5G,EAAA,WAEA4B,IACA7C,GAAAD,QAAA8C,EAEAA,EAAAmE,MAAA,SAAAF,GACA,GAGA5F,GAAA4C,EAHAuF,EAAAvC,EAAAvF,OACA+H,EAAAxC,EAAAa,IAAA,SAAAlH,GAAA,MAAAoC,GAAA0G,kCAAA9I,KACA+I,EAAA1C,EAAAa,IAAAL,EAAAC,SACAkC,IAEA,KAAAvI,EAAA,EAAAmI,EAAAnI,EAAAA,IAAAuI,EAAAD,EAAAtI,MAEA,KAAAA,EAAA,EAAAmI,EAAAnI,EAAAA,IACA,IAAA4C,EAAA5C,EAAA,EAAAmI,EAAAvF,EAAAA,IAAA,CACA,GAAA4F,GAAAF,EAAA1F,GAAA6F,EAAAH,EAAAtI,EAEAuI,GAAAC,GAAAC,GAAAF,EAAAE,GAAAD,GAAA7G,EAAA+G,IAAAN,EAAApI,GAAAoI,EAAAxF,IAGA,MAAA2F,IAGA5G,EAAA+G,IAAA,SAAAC,EAAAC,GACA,GAAAC,GAAAlC,EAAAmC,MAAAnC,EAAAoC,KAAAJ,EAAAK,gBAAArC,EAAAoC,KAAAH,EAAAI,iBACAnG,EAAA,CAEAgG,GAAA7F,QAAA,SAAAiG,GACA,GAAAhD,GAAA0C,EAAAK,eAAAC,GAAA/C,EAAA0C,EAAAI,eAAAC,EAEAhD,IAAAC,EACAD,EAAAiD,SAAAhD,EAAAgD,UACArG,IAAA0D,EAAAwB,gBAAA9B,EAAAiD,cAAAhD,EAAAgD,UAAA,GAGArG,GAAA0D,EAAAuB,cAKA,IAAAqB,GAAAjB,EAAAkB,QAAAT,GACAU,EAAAnB,EAAAkB,QAAAR,EAeA,QAbAO,GAAAE,KACAF,GAAAE,GACAV,EAAAW,SAAAC,OAAAX,EAAAU,SAAAC,OACAZ,EAAAW,SAAAC,MAAAC,QAAAZ,EAAAU,SAAAC,MAAAC,OACAb,EAAAW,SAAAG,QAAAb,EAAAU,SAAAG,QACAd,EAAAW,SAAAG,OAAAD,QAAAZ,EAAAU,SAAAG,OAAAD,SAEA3G,GAAA,GAGAA,GAAA,GAGAA,GAIAlB,EAAA0G,kCAAA,SAAAqB,GACA,GAAAC,MACAL,EAAAI,EAAAJ,QASA,OAPA3C,GAAAoC,KAAAO,GAAAtG,QAAA,SAAAkG,GACA,GAAA3J,GAAAoH,EAAAiD,UAAAN,EAAAJ,GACA3J,GAAA2J,QAAAA,EACAS,EAAApK,EAAAiK,OAAA,IAAAjK,QACAA,GAAAiK,SAIAK,KAAAH,EAAAG,KACAb,eAAAW,EACAL,SAAAI,EAAAJ,aP8XGlC,UAAU,GAAGC,kBAAkB,EAAEC,0BAA0B,GAAGwC,qBAAqB,KAAKC,GAAG,SAAShK,EAAQjB,EAAOD,GQ7ctH,YAEA,IAAA0H,GAAAzH,EAAAD,SACAmL,OACA/H,WACAgI,QAGA1D,GAAA2D,EAAA,IACA3D,EAAA4D,EAAA,IACA5D,EAAA6D,IAAA,MACA7D,EAAA8D,IAAA,SACA9D,EAAA+D,KAAA,OACA/D,EAAAgE,MAAA,QACAhE,EAAAiE,MAAA,QACAjE,EAAAkE,KAAA,OACAlE,EAAAmE,OAAA,SAIAnE,EAAAoE,QACApE,EAAAoE,KAAAC,QAAA,UACArE,EAAAoE,KAAAE,QAAA,UACAtE,EAAAoE,KAAAG,aAAA,eACAvE,EAAAoE,KAAAI,SAAA,WAGAxE,EAAAyD,IAAAgB,aACAC,KAAA,SACAC,YACAC,aACAF,KAAA,UACAG,WAAA,EACAC,YAAA,wBAEAC,iCACAL,KAAA,UACAG,UAAA,GACAC,YAAA,4EAEAE,oBACAN,KAAA,UACAG,WAAA,KAKA7E,EAAAyD,IAAAwB,YACAP,KAAA,SACAC,YACAO,QACAR,KAAA,UAEAS,MACAT,KAAA,UAEAU,YACAV,KAAA,UACAG,UAAA,OACAQ,QAAA,OAAA,aAAA,kBAEAC,SACAZ,KAAA,SACAG,UAAA,OACAQ,QAAA,OAAA,MAAA,OAAA,QACAP,YAAA,mDAEAS,sBACAb,KAAA,UACAG,UAAA,GACAC,YAAA,gEAEAF,aACAF,KAAA,UACAG,WAAA,EACAC,YAAA,wBAEAU,iBACAd,KAAA,UACAG,WAAA,EACAC,YAAA,yCAEAW,mBACAf,KAAA,UACAG,WAAA,EACAC,YAAA,2CAEAY,0BACAhB,KAAA,UACAG,WAAA,EACAC,YAAA,8CAEAa,UACAjB,KAAA,QACA/I,OACA+I,MAAA,WAEAG,WAAAtJ,OAAA,SAEAqK,cACAlB,KAAA,QACA/I,OACA+I,MAAA,WAEAG,WAAA,SAEAgB,iBACAnB,KAAA,UACAG,WAAA,EACAC,YAAA,+CAKA9E,EAAAyD,IAAAqC,WACApB,KAAA,SACAC,YACAoB,UACArB,KAAA,QACA/I,OAAA+I,KAAA,UACAG,WAAA,QAAA,MAAA,OAAA,OAAA,OAAA,QACAC,YAAA,iBAEAkB,kBACAtB,KAAA,QACA/I,OAAA+I,KAAA,UACAG,WAAA,IAAA,IAAA,MAAA,SAAA,OAAA,QAAA,OAAA,UACAC,YAAA,0BAEAmB,mBACAvB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,yCAEAoB,oBACAxB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,yCAGAqB,6BACAzB,KAAA,UACAG,UAAA,EACAC,YAAA,0FAEAsB,yBACA1B,KAAA,UACAG,UAAA,GACAC,YAAA,8EAEAuB,4BACA3B,KAAA,UACAG,UAAA,EACAC,YAAA,6EAEAwB,wBACA5B,KAAA,UACAG,UAAA,GACAC,YAAA,iEAEAyB,wBACA7B,KAAA,UACAG,UAAA,EACAC,YAAA,iEAEA0B,cACA9B,KAAA,UACAG,WAAA,EACAC,YAAA,+JAGAF,aACAF,KAAA,UACAG,WAAA,EACAC,YAAA,wBAEA2B,8BACA/B,KAAA,UACAG,WAAA,EACAC,YAAA,yCAEA4B,8BACAhC,KAAA,UACAG,WAAA,EACAC,YAAA,8DAGA6B,oCACAjC,KAAA,UACAG,WAAA,EACAC,YAAA,2FAGA8B,uBACAlC,KAAA,UACAG,WAAA,EACAC,YAAA,4BAGA+B,eACAnC,KAAA,UACAG,WAAA,EACAC,YAAA,yBAGAgC,oBACApC,KAAA,UACAG,WAAA,EACAC,YAAA,uCAEAiC,8BACArC,KAAA,UACAG,WAAA,URmdMmC,IAAI,SAASxN,EAAQjB,EAAOD,GSvqBlCC,EAAAD,SACA0H,OAAAxG,EAAA,YACAkC,QAAAlC,EAAA,qBACAiK,IAAAjK,EAAA,aACAkK,KAAAlK,EAAA,eACA4G,KAAA5G,EAAA,UACAyN,KAAA,YT6qBGC,oBAAoB,EAAEC,WAAW,EAAEC,YAAY,GAAGC,cAAc,GAAGC,SAAS,KAAKC,IAAI,SAAS/N,EAAQjB,EAAOD,GUnrBhH,YAeA,SAAAkP,GAAAC,EAAAC,EAAAC,EAAArI,GAOA,QAAAsI,GAAAC,GACAA,EAAAzH,EAAAiD,UAAAwE,GACAA,EAAA1L,IAAA0L,EAAA3H,IAAA,SAAA4H,GACA,MAAAjI,GAAAkI,gBAAAD,KACAE,KAAAnI,EAAAoI,OACAR,EAAAhJ,KAAAoJ,GAGA,QAAAK,KACA,GAAA5I,EAAAkG,iBAAAlG,EAAAmG,kBAAA,CACA,GAAA0C,IAAA,EAAAC,GAAA,EAAAC,GAAA,CASA,IARAC,EAAA7L,QAAA,SAAApE,GACAkQ,EAAAC,YAAAnQ,GACA+P,GAAA,GAEAD,GAAA,EACA9P,EAAAoQ,YAAAJ,GAAA,OAGAD,IAAAC,GAAA/I,EAAAkG,gBAAA,MACA,KAAA2C,IACA7I,EAAAoG,2BACA4C,EAAA7J,KAAA8J,EAAAG,SACAd,EAAAU,GACAA,EAAAK,OAEArJ,EAAAmG,mBAAA,OAGAnG,EAAAsF,aAAA,IAAA0D,EAAAxO,QACA8N,EAAAU,GAGA,QAAAM,GAAAnP,EAAAoP,EAAAC,EAAAvP,GACA,GAAAwP,GAAAF,KAAA,GAAA,OAAAA,EACAG,EAAAH,KAAA,GAAA,OAAAA,CACAtP,GACAwP,IACAT,EAAA7O,GAAAgP,UAAAlP,EACA0P,EAAAxP,EAAA,GAAA,EAAAqP,SACAR,GAAA7O,GAAAgP,WAGAO,GACAC,EAAAxP,EAAA,GAAA,EAAAqP,GAKA,QAAAI,GAAAzP,EAAAoP,EAAAC,GACAR,EAAA7O,GAAA0P,KAAA,EACAF,EAAAxP,EAAA,EAAAoP,EAAAC,SACAR,GAAA7O,GAAA0P,IAGA,QAAAC,GAAA3P,EAAAoP,EAAAC,GACA,GAAAzQ,GAAAqP,EAAAjO,GACAsP,EAAAF,KAAA,GAAA,OAAAA,CAIA,IAFAP,EAAA7O,IAAAwJ,MAAA5K,EAAA4K,MAAAyB,KAAArM,EAAAqM,MAEA,UAAArM,EAAAoQ,UACAM,IACAT,EAAA7O,GAAAgP,UAAApQ,EAAAoQ,UACAQ,EAAAxP,EAAA,GAAA,EAAAqP,QAEA,IAAAzQ,EAAAgR,WAEAT,EAAAnP,EAAAoP,EAAAC,EAAAzQ,EAAAgR,gBACA,IAAAhR,EAAAiR,KACAV,EAAAnP,EAAAoP,EAAAC,EAAAvN,YACA,IAAAlD,EAAAkR,KACAL,EAAAzP,EAAAoP,EAAAC,OAQA,IANAxJ,EAAAqG,SAAAlJ,QAAA,SAAAlD,GACA+F,EAAAuG,iBAAAiD,IAAAU,GAAAV,IAAAvP,GACAqP,EAAAnP,EAAAoP,EAAAtP,EAAAA,OAIA+F,EAAAuG,iBAAAzF,EAAAqJ,KAAAX,GAAAU,EAAA,MAAA,OAAA,gBAAAE,EAAA,CACA,GAAAC,GAAApB,EAAAqB,YAAAvR,EAAAsP,GAAArI,EAAAiG,qBAEAsE,EAAA,SAAAvK,EAAAgG,QACAwE,EAAA,QAAAxK,EAAAgG,SAAAuE,GAAAF,EACAI,EAAA,SAAAzK,EAAAgG,SAAAuE,IAAAF,CAEAG,IAAA1J,EAAAqJ,KAAAX,GAAAU,EAAA,MAAA,cACAN,EAAAzP,EAAAoP,EAAAgB,EAAA,WAAA,OAEAE,GAAA3J,EAAAqJ,KAAAX,GAAAU,EAAA,OAAA,eACAlB,EAAA7O,GAAAiL,KAAAN,EAAAE,QACA2E,EAAAxP,EAAA,EAAAoP,EAAAgB,EAAA,WAAA,QACAvB,EAAA7O,GAAAiL,KAAAN,EAAAG,eAMA,QAAAyF,GAAAvQ,EAAAoP,EAAAC,EAAAmB,GACA3B,EAAA7O,GAAAwQ,SAAAA,EACAhB,EAAAxP,EAAA,EAAAoP,EAAAC,SACAR,GAAA7O,GAAAwQ,SAGA,QAAAC,GAAAzQ,EAAAoP,EAAAC,GACA,GAAAzQ,GAAAqP,EAAAjO,EACA6O,GAAA7O,IAAAwJ,MAAA5K,EAAA4K,MAAAyB,KAAArM,EAAAqM,MAGArM,EAAA8R,UACAH,EAAAvQ,EAAAoP,EAAAC,EAAAzQ,EAAA8R,WAEA7K,EAAAsG,aAAAnJ,QAAA,SAAAwN,GACA1O,SAAA0O,EACApB,GACAI,EAAAxP,EAAA,GAAA,EAAAqP,GAGAkB,EAAAvQ,EAAAoP,EAAAC,EAAAmB,KAQA,QAAAhB,GAAAxP,EAAAoP,EAAAC,GACA,GAAArP,IAAAiO,EAAA5N,OAEA,WADAoO,IAIA,IAAA7P,GAAAqP,EAAAjO,EAEA,QAAApB,EAAAqM,MAEA,IAAAN,GAAAG,aACA6E,EAAA3P,EAAAoP,EAAAC,EACA,MAEA,KAAA1E,GAAAI,SACA0F,EAAAzQ,EAAAoP,EAAAC,EACA,MACA,KAAA1E,GAAAE,QAEA,IAAAF,GAAAC,QAEA,QACAiE,EAAA7O,GAAApB,EACA4Q,EAAAxP,EAAA,EAAAoP,EAAAC,IA5JAxJ,EAAA8K,EAAAC,OAAA/K,MAAAU,EAAAyD,IAAAwB,WACA,IAAAqD,GAAA,GAAAjK,OAAAqJ,EAAA5N,QACA4P,EAAAtJ,EAAAkK,IAAA5C,EAAA,SAAArP,GACA,MAAAA,GAAAqM,OAAAN,EAAAC,SAAAhM,EAAAqM,MAAAN,EAAAE,UA8JAuE,EAAA,eAAAvJ,EAAA8F,YAAA,EAAA,kBAAA9F,EAAA8F,YAAA,EAAA,IAGA,OAFA6D,GAAA,EAAAJ,EAAAW,GAEA/B,EAlLA,GAAAc,GAAA/O,EAAA,0BACA4Q,EAAA5Q,EAAA,mCACAqG,EAAArG,EAAA,2BAEAwG,EAAAxG,EAAA,aACA4K,EAAApE,EAAAoE,KACAhE,EAAA5G,EAAA,WAEAgQ,EAAA,GAEAjR,GAAAD,QAAAkP,IV+1BG+C,YAAY,EAAE1J,UAAU,GAAG2J,yBAAyB,GAAGC,kCAAkC,GAAG1J,0BAA0B,KAAK2J,IAAI,SAASlR,EAAQjB,EAAOD,GW32B1J,YA8DA,SAAAqS,GAAA5H,EAAA+E,EAAAH,EAAArI,GACA,MAAAA,GAAAoH,+BACA3D,EAAAC,OAAAD,EAAA3G,MAAA2G,EAAA6H,QAAA,GAEA,EAGA,QAAAC,GAAA9H,EAAA+E,EAAAH,EAAArI,GACA,MAAAqL,GAAA5H,EAAA+E,EAAAH,EAAArI,GAEAiJ,EAAAuC,UAAAhD,IACAS,EAAAqB,YAAA9B,EAAAH,IAAArI,EAAAgH,wBAHA,EAMA,QAAAyE,GAAAhI,EAAA+E,EAAAH,EAAArI,GACA,MAAAqL,GAAA5H,EAAA+E,EAAAH,EAAArI,GAEAwI,EAAAqB,KAAArB,EAAApD,OAAAN,EAAAG,cAAA,EACAuD,EAAAmC,UAAAnC,EAAApD,OAAAN,EAAAI,UAAA,EACA+D,EAAAqB,YAAA9B,EAAAH,IAAArI,EAAAgH,wBAJA,EAOA,QAAA0E,GAAAjI,GAEA,MAAAA,GAAAkI,EAAAvG,OAAAN,EAAAC,SAAAtB,EAAAkI,EAAAvG,OAAAN,EAAAE,UAAAwG,EAAA/H,EAAA7B,GAKA4J,EAAA/H,EAAAkI,IACAlI,EAAA7B,EAAAwD,OAAAN,EAAAC,SAAAtB,EAAA7B,EAAAwD,OAAAN,EAAAE,SACAkE,EAAAzF,EAAA7B,IAEA,GAGA,GAXA,EAcA,QAAAgK,GAAAnI,EAAA4E,EAAArI,GAEA,GAAAyD,EAAAoI,KACA,MAAAC,GAAAC,aAAAtI,EAAA,OAAA4E,EAAArI,EAIA,IAAAyD,EAAA7B,GAAA6B,EAAAkI,GAAAlI,EAAAuI,KAAAvI,EAAAwI,IAAA,CAEA,GAAAxI,EAAAyI,KAAAzI,EAAAL,OAAA,CAGA,IAAAK,EAAA7B,IAAA6B,EAAAkI,EAAA,OAAA,CAEA,IAAA3L,EAAAqH,oCAEA8E,EAAAC,yBAAA3I,GAAA,OAAA,EAIA,GAAAA,EAAA7B,GAAA6B,EAAAkI,EAAA,CACA,GAAAU,KAAAnD,EAAAzF,EAAA7B,GACA0K,IAAApD,EAAAzF,EAAAkI,EAEA,IAAAU,GAAAC,IAAAC,EAAAC,YAAA/I,GAEA,OAAA,CAGA,IAAAzD,EAAAkH,aACA,GAAAmF,EAAAC,GACA,IAAAZ,EAAAjI,GACA,OAAA,MAEA,IAAAA,EAAAkI,EAAAvG,OAAAN,EAAAI,UAAAzB,EAAA7B,EAAAwD,OAAAN,EAAAI,UACA,GAAAzB,EAAAkI,EAAAvG,OAAAN,EAAAI,UAAAzB,EAAA7B,EAAAwD,OAAAN,EAAAI,SACA,OAAA,MAGA,IAAAzB,EAAA7B,EAAA+B,MAAAF,EAAAkI,EAAAhI,MACA,OAAA,CAIA,QAAA,EAKA,GAAA3D,EAAAsF,YACA,OAAA,CAIA,IAAAtF,EAAAkH,cAAAzD,EAAAkI,EACA,OAAA,CAIA,IAAA3L,EAAAmH,8BAAArG,EAAAoC,KAAAO,GAAAjJ,OAAA,EACA,OAAA,CAGA,IAAAwF,EAAAsH,sBAAA,CAEA,GAAA7D,EAAA7B,GAAA,SAAA6B,EAAA7B,EAAAuH,YAAA1F,EAAAkI,EACA,OAAA,CAEA,IAAAlI,EAAAkI,GAAA,SAAAlI,EAAAkI,EAAAxC,YAAA1F,EAAA7B,EACA,OAAA,EAIA,OAAA,EAEA,OAAA,EAoBA,QAAAuK,GAAA3F,EAAA4B,EAAAC,EAAArI,GAIA,QAAA2J,GAAAxP,GAEA,GAAAA,IAAAiO,EAAA5N,OAKA,YAHAoR,EAAAa,EAAApE,EAAArI,IACAwG,EAAArH,KAAA2B,EAAAiD,UAAA0I,IAMA,IAAAjE,GAAAJ,EAAAjO,EACA,KAAA,GAAA4C,KAAAiD,GAAA0G,iBAAA,CACA,GAAArD,GAAArD,EAAA0G,iBAAA3J,GACA2P,EAAAxD,EAAAV,EAGAnF,KAAAoJ,MACAC,GAAAC,EAAAtJ,GAAAuJ,YAAAF,GAAAC,EAAAtJ,GAAAwJ,UACAF,EAAAtJ,GAAAsJ,QAAAA,EAAAtJ,GAAAsJ,MAAAF,EAAAjE,EAAAH,EAAArI,KAEAyM,EAAApJ,GAAAmF,EACAmB,EAAAxP,EAAA,SACAsS,GAAApJ,KAzBA,GAAAoJ,KAgCA,OAFA9C,GAAA,GAEAnD,EApOA,GAAAyC,GAAA/O,EAAA,0BACAqS,EAAArS,EAAA,0BACA4G,EAAA5G,EAAA,WAEA4R,EAAA5R,EAAA,WACAgP,EAAAD,EAAAC,YACAsC,EAAAvC,EAAAuC,UAEA9K,EAAAxG,EAAA,aACA4K,EAAApE,EAAAoE,IAEA7L,GAAAD,QAAAmT,CAGA,IAAAQ,IACA/K,GACAgL,WAAA,EACAC,SAAA,EACAC,UAAA,GAEAnB,GACAiB,WAAA,EACAC,SAAA,EACAC,UAAA,GAEAZ,KACAU,WAAA,EACAE,UAAA,GAEA1J,QACAwJ,WAAA,EACAE,UAAA,GAEAxB,OACAsB,WAAA,EACAD,MAAAlB,GAEA3O,MACA+P,SAAA,EACAF,MAAAtB,GAEA3H,OACAkJ,WAAA,EACAC,SAAA,EACAF,MAAApB,GAEAM,MACAgB,SAAA,GAEAjJ,QACAgJ,WAAA,GA+HAT,GAAAC,yBAAA,SAAA3I,GACA,GAAA8F,IAAA,EAAAwD,GAAA,CACA,KAAA,GAAA1J,KAAAI,GAAA,CACA,GAAA+E,GAAA/E,EAAAJ,EAOA,IANAmF,EAAAW,YACAI,GAAA,GAEAN,EAAAC,YAAAV,IAAAnF,IAAA3C,EAAA6D,KAAAlB,IAAA3C,EAAA8D,MACAuI,GAAA,GAEAxD,GAAAwD,EAAA,MAGA,MAAAxD,KAAAwD,KXq5BG9B,YAAY,EAAE1J,UAAU,GAAGyL,UAAU,GAAGC,yBAAyB,GAAG/B,yBAAyB,KAAKgC,IAAI,SAAShT,EAAQjB,EAAOD,GYrlCjI,YAEA,IAAA8H,GAAA5G,EAAA,WAMAiK,EAAAlL,EAAAD,SAEA2M,WAAAzL,EAAA,gBACAiL,YAAAjL,EAAA,iBAEA6F,MAAA7F,EAAA,WACAsM,UAAAtM,EAAA,eACAiT,MAAAjT,EAAA,WAKAiK,GAAAiJ,OAAA,SAAAhF,EAAApI,EAAA4F,EAAAyH,GACArN,EAAAc,EAAAqD,IAAAmJ,OAAAtN,GACAqN,EAAApR,SAAAoR,GAAA7G,UAAA,GAAA6G,CAKA,IACA7G,GAAA4G,EADAG,EAAAvN,EAAAwN,QAAArJ,EAAAwB,cAAAyC,EAAApI,IAAAoI,GACAqF,EAAA,CAuBA,OArBAJ,MAAA,GAAAA,GAAAA,EAAAlE,UACA3C,EAAA+G,EAAApL,OAAA,SAAAgG,EAAAC,GACA,MAAAjE,GAAAuJ,KAAAvF,EAAAC,EAAApI,SAGAwG,EAAA+G,EAAA3M,IAAA,SAAAwH,GACA,MAAAjE,GAAAuJ,QAAAtF,EAAApI,KACA,GACAyN,GAAA,GAGAJ,KAAA,GAAAA,GAAAA,EAAA7G,UACA4G,EAAAtM,EAAA6M,aAAAnH,EAAA,SAAA2B,EAAA1E,GACA,MAAAU,GAAAgJ,MAAAhF,EAAA1E,EAAAzD,EAAA4F,IACA6H,GAAA,IAEAL,EAAAtM,EAAA8M,UAAApH,EAAA,SAAA/C,GACA,MAAAU,GAAAgJ,SAAA1J,EAAAzD,EAAA4F,IACA6H,GAAA,GACAA,GAAA,GAEAL,KZwlCG7L,UAAU,GAAGsM,eAAe,GAAGC,cAAc,GAAGd,UAAU,GAAGe,gBAAgB,GAAGC,UAAU,KAAKC,IAAI,SAAS/T,EAAQjB,EAAOD,Ga3oC9H,YAuBA,SAAAkV,GAAAzK,EAAA4E,EAAArI,GACA,MAAAA,GAAAyG,SAAArF,OAAA,SAAA4C,GACA,MAAA8H,GAAAC,aAAAtI,EAAAO,EAAAqE,EAAArI,KAYA,QAAAmO,GAAA3F,EAAAH,EAAArI,GACA,MAAAiJ,GAAAqB,YAAA9B,EAAAH,IAAArI,EAAA8G,wBAGA,QAAAsH,GAAA3K,EAAA4E,EAAArI,GACA,MAAAyD,GAAAyI,MAAAiC,EAAA1K,EAAAyI,IAAA7D,EAAArI,IAAA,EACAyD,EAAAL,SAAA+K,EAAA1K,EAAAL,OAAAiF,EAAArI,IAAA,GACA,EAGA,QAAAqO,GAAA5K,EAAA4E,EAAArI,GACA,IAAAoO,EAAA3K,EAAA4E,EAAArI,GAAA,OAAA,CACA,IAAAyD,EAAA7B,GAAA6B,EAAAkI,EAAA,CAGA,GAAA2C,GAAApF,EAAAzF,EAAA7B,GACA2M,EAAArF,EAAAzF,EAAAkI,EAGA,IAAA2C,GAAAC,EAAA,CAEA,GAAA9K,EAAA6H,MACA,OAAA,CAIA,IAAA7H,EAAAC,OAAAwF,EAAAzF,EAAAC,OACA,OAAA,OAIA,CACA,GAAA1D,EAAAsF,YAAA,OAAA,CAGA,IAAAtF,EAAAkH,cAAAzD,EAAAkI,EAAA,OAAA,CAGA,IAAA3L,EAAAmH,8BAAArG,EAAAoC,KAAAO,GAAAjJ,OAAA,EAAA,OAAA,CAGA,IAAAiJ,EAAA6H,MAAA,OAAA,EAEA,OAAA,EAGA,QAAAkD,GAAA/K,EAAA4E,EAAArI,GAEA,GAAAyD,EAAA7B,GAAA6B,EAAAkI,EAAA,CACA,GAAAY,EAAAC,YAAA/I,GAAA,OAAA,CAEA,IAAA6K,GAAApF,EAAAzF,EAAA7B,GACA2M,EAAArF,EAAAzF,EAAAkI,EAEA,QAAA2C,KAAA7K,EAAAkI,GAAA4C,KACAA,KAAA9K,EAAA7B,GAAA0M,GAEA,OAAA,EAGA,QAAAG,GAAAhL,EAAA4E,EAAArI,GACA,IAAAoO,EAAA3K,EAAA4E,EAAArI,GAAA,OAAA,CAGA,KAAAyD,EAAA7B,IAAA6B,EAAAkI,EAAA,OAAA,CAEA,IAAA3L,EAAAuH,eAAAtL,SAAAwH,EAAA3G,KAAA,OAAA,CAIA,IAAA4R,KACAjL,EAAA7B,GAAA3F,SAAAwH,EAAA7B,EAAAuH,aACA1F,EAAAkI,GAAA1P,SAAAwH,EAAAkI,EAAAxC,UAGA,IAAAuF,EAAA,CACA,GAAAC,KACAlL,EAAA7B,GAAAsH,EAAAzF,EAAA7B,MACA6B,EAAAkI,GAAAzC,EAAAzF,EAAAkI,GAEA,IAAAgD,EAAA,CACA,GAAAxF,GAAA1F,EAAA7B,EAAAuH,WAAA1F,EAAAkI,EAAAxC,SACA,SAAAnJ,EAAAwH,oBAAA,SAAA2B,GAAA1F,EAAAC,QAIA,OAAA,EAGA,QAAAkL,GAAAnL,EAAA4E,EAAArI,GACA,MAAAoO,GAAA3K,EAAA4E,EAAArI,GAOAyD,EAAA7B,EAAAwD,MAAAN,EAAAI,UAAAzB,EAAA7B,EAAA+I,UAAAlH,EAAAkI,EAAAvG,MAAAN,EAAAG,cAAAxB,EAAAkI,EAAAxC,WAPA,EAUA,QAAA0F,GAAApL,EAAA4E,EAAArI,GACA,MAAAoO,GAAA3K,EAAA4E,EAAArI,IAEA4O,EAAAnL,EAAA4E,EAAArI,KAEAA,EAAAwH,oBAAA,SAAA/D,EAAAkI,EAAAxC,WAAA1F,EAAAC,QAJA,EAOA,QAAAoL,GAAArL,EAAA4E,EAAArI,GAEA,OAAAyD,EAAAyI,KAAAzI,EAAAL,SAAAK,EAAAoI,MAAApI,EAAAoI,KAAA1C,YAAA1F,EAAA7B,IAAA6B,EAAAkI,IAAAlI,EAAA3G,QACAkD,EAAAyH,+BAAAhE,EAAAC,OAlJA,GAAA6I,GAAArS,EAAA,0BACA+O,EAAA/O,EAAA,0BACA6U,EAAA7U,EAAA,0BAEAgP,EAAAD,EAAAC,YACApI,EAAA5G,EAAA,WAEAwG,EAAAxG,EAAA,aACA4K,EAAApE,EAAAoE,KAEAgH,EAAA7S,EAAAD,QAAAkV,EAEAc,EAAAlD,EAAAmD,MACArQ,MAAAyP,EACAa,IAAAT,EACAU,KAAAP,EACAQ,KAAAP,EACAhD,KAAAiD,EACAO,KAAAb,EASA1C,GAAAC,aAAA,SAAAtI,EAAAO,EAAAqE,EAAArI,GACA,MAGA,QAHA+O,EAAAO,yBACAtL,KAAAA,EACAP,SAAAA,OAEAuL,EAAAhL,IAAAgL,EAAAhL,GAAAP,EAAA4E,EAAArI,ObiwCGiL,YAAY,EAAE1J,UAAU,GAAG0L,yBAAyB,GAAG/B,yBAAyB,GAAGqE,yBAAyB,KAAKC,IAAI,SAAStV,EAAQjB,EAAOD,GcnyChJ,YAmBA,SAAAmM,GAAAiD,EAAAC,EAAArI,GACAA,EAAA8K,EAAAC,OAAA/K,MAAAU,EAAAyD,IAAAgB,YAGA,IAAAsK,MAAAC,KAAAnC,KACAoC,GAAA,EACAC,GAAA,EACAC,IAEAzH,GAAAjL,QAAA,SAAAqL,EAAA7L,GAIA,GAFAkT,EAAArH,EAAA7E,OAAAhH,EAEA6L,EAAAiH,SACAA,EAAAtQ,KAAAqJ,GACAU,EAAAV,IAAA,aAAAA,EAAApD,KACAuK,GAAA,EAEAC,GAAA,MAEA,IAAApH,EAAAiH,YAAA,IAAAxG,EAAA6G,QAAAtH,GAAA,CACA,GAAAS,EAAAC,YAAAV,KACAxI,EAAAyF,iCACAwD,EAAAqB,YAAA9B,EAAAH,EAAA,IAAArI,EAAAyF,gCAEA,MAEAiK,GAAAvQ,KAAAqJ,MAIAkH,EAAAlR,KAAAuR,EAAAJ,EAAAC,EAAAC,GAEA,IAAAG,GAAAlP,EAAAmP,cAAAP,EAAA,EAeA,OAbAM,GAAA7S,QAAA,SAAA+S,GACA,GAAA3H,GAAAkH,EAAAU,OAAAD,EACA,IAAA3H,EAAA/N,OAAA,EAAA,CACA,GAAAwF,EAAAsF,aAAA,IAAAiD,EAAA/N,OAAA,MACA+S,GAAApO,KAAAoJ,MAIAgF,EAAApQ,QAAA,SAAAoL,GAEAA,EAAA1L,IAAAsI,EAAAtI,IAAA0L,KAGAgF,EAUA,QAAAwC,GAAAJ,EAAAC,EAAAC,GACA,MAAA,UAAA5V,EAAA4H,GAEA,MAAA5H,GAAAmL,OAAAvD,EAAAuD,KACAuK,EAGAS,EAAAvO,EAAAuD,MAAAgL,EAAAnW,EAAAmL,MAFAgL,EAAAnW,EAAAmL,MAAAgL,EAAAvO,EAAAuD,MAMAyK,EAAA5V,EAAA0J,OAAAkM,EAAAhO,EAAA8B,QAtFA,GAAAsF,GAAA/O,EAAA,0BACA4Q,EAAA5Q,EAAA,mCAEA4G,EAAA5G,EAAA,WACAwG,EAAAxG,EAAA,aACAgP,EAAAD,EAAAC,WAEAjQ,GAAAD,QAAAmM,CA6DA,IAAAiL,IACAC,QAAA,EACAC,QAAA,EACAC,SAAA,EACAC,aAAA,EAkBArL,GAAAtI,IAAA,SAAA4T,GACA,MAAAA,GAAA7P,IAAA,SAAA4H,GACA,MAAAS,GAAA6G,QAAAtH,GAAA,QAAAA,EAAA7E,QACA+E,KAAA,QdwyCGuC,YAAY,EAAE1J,UAAU,GAAG2J,yBAAyB,GAAGC,kCAAkC,KAAKuF,IAAI,SAASxW,EAAQjB,EAAOD,Gev4C7H,YAeA,SAAA2X,GAAAxI,EAAAC,EAAAC,EAAArI,EAAA4Q,GAEA5Q,EAAA8K,EAAAC,OAAA/K,MAAAU,EAAAyD,IAAAqC,UACA,IAAAA,GAAA2F,KAAA/D,EAAAC,EAAArI,EAEA,OAAA4Q,GACApK,EAAArE,OAAA,SAAA0O,EAAApN,GAEA,MADAoN,GAAApN,GAAAqN,KAAArN,EAAA4E,EAAArI,GACA6Q,OAGArK,EAAArE,OAAA,SAAA4O,EAAAtN,GACA,MAAAqN,GAAAC,EAAAtN,EAAA4E,EAAArI,QAKA,QAAA8Q,GAAA3I,EAAA1E,EAAA4E,EAAArI,GAmBA,MAlBAkO,GAAAzK,EAAA4E,EAAArI,GACA7C,QAAA,SAAA6G,GACA,GAAAH,GAAA/C,EAAAiD,WAEAN,SAAAA,EACAmC,OAAA5F,EAAA4F,QAGA/B,GAAAG,KAAAA,EAEAH,EAAAgC,KAAA7F,EAAA6F,KAEAhC,EAAAmN,EAAAnN,EAAAwE,EAAArI,EACA,IAAAmB,GAAAiD,EAAAX,SAAAI,EAAAwE,EAAArI,EAEA6D,GAAA3C,MAAAC,EACAgH,EAAAhJ,KAAA0E,KAEAsE,EAIA,QAAA6I,GAAAnN,EAAAwE,EAAArI,GACA,SAAA6D,EAAAG,MAAAhE,EAAAyH,+BACA5D,EAAAJ,SAAAC,MAAAG,EAAAJ,SAAAoI,KAKA,IAAApI,GAAAI,EAAAJ,QAYA,QAXA,IAAA,KAAAtG,QAAA,SAAAkG,GACA,GAAAmF,GAAA/E,EAAAJ,EAGA,IAAAmF,GAAAS,EAAAuC,UAAAhD,KAAAS,EAAA6G,QAAAtH,GAAA,CACA,GAAAyI,GAAA5I,EAAAG,EAAA7E,MACAsN,IAAAA,EAAAC,MAAAD,EAAAE,KAAA,MACA3I,EAAA4I,OAAAC,MAAA,OAIAxN,EAxEA,GAAAoF,GAAA/O,EAAA,0BACA4Q,EAAA5Q,EAAA,mCACA4G,EAAA5G,EAAA,WAEAiS,EAAAjS,EAAA,eACAgU,EAAAhU,EAAA,WACAkK,EAAAlK,EAAA,gBACAwG,EAAAxG,EAAA,YAEAjB,GAAAD,QAAA2X,If08CG1F,YAAY,EAAEqG,eAAe,GAAG/P,UAAU,GAAGuM,cAAc,GAAGd,UAAU,GAAG9B,yBAAyB,GAAGC,kCAAkC,KAAKoG,IAAI,SAASrX,EAAQjB,EAAOD,GgBr9C7KC,EAAAD,SACAyK,SAAAvJ,EAAA,sBhB29CGsX,kBAAkB,KAAKC,IAAI,SAASvX,EAAQjB,EAAOD,GiB19CtD,YA6BA,SAAA0Y,GAAA7N,EAAAwE,EAAArI,EAAAyP,GACA,GAAAkC,MACAC,EAAA9Q,EAAAoC,KAAAW,EAAAJ,UACAO,EAAAH,EAAAG,KACAP,EAAAI,EAAAJ,SAEAoO,EAAAtF,EAAApK,OAAA0B,EAAAJ,SAAA,SAAA1J,EAAAyO,EAAAnF,GACA,GAAAxG,GAAA0D,EAAAkI,gBAAAD,GACAsJ,EAAA/X,EAAA8C,GAAA9C,EAAA8C,MAEA,OADAiV,GAAA3S,MAAAkE,QAAAA,EAAAmF,SAAAA,IACAzO,MAqDA,OAjDA+G,GAAA3D,QAAA0U,EAAA,SAAAC,GACA,GAAAC,GAAAD,EAAAlR,IAAA,SAAAoR,GACA,MAAAA,GAAA3O,QAAA9C,EAAA0R,OAAA1R,EAAAkI,gBAAAuJ,EAAAxJ,UACA,KAAAiH,GAAAA,EAAAuC,EAAAxJ,SAAA7E,OAAA,MAAA,SAEAuO,EAAAJ,EAAAlR,IAAA,SAAAoR,GACA,GAAAG,GAAAlJ,EAAAC,YAAA8I,EAAAxJ,UAAA,YAAA,UAEArH,EAAAuQ,EAAAvQ,MAAAgR,GAAAH,EAAAxJ,SAAAwJ,EAAA3O,QAAAQ,EAAAG,KAAAqE,EAAArI,EAEA,QAAAyP,GAAAA,EAAAuC,EAAAxJ,SAAA7E,OAAAxC,EAAA9F,KAAAC,IAAA6F,EAAA,OAGAwQ,GAAAxS,MACAiT,OAAAL,EAAArJ,KAAA,OACAvH,MAAA9F,KAAAK,IAAA2W,MAAA,KAAAH,OAKA,SAAAlO,GAGAP,EAAA7B,GAAA6B,EAAAkI,GACAzC,EAAAzF,EAAA7B,GAAAsH,EAAAzF,EAAAkI,IACAgG,EAAAxS,MACAiT,OAAA,WACAjR,MAAA,KAOAyQ,EAAApX,OAAA,GAAA,SAAAwJ,IACAP,EAAA7B,GAAA6B,EAAAkI,GAAAlI,EAAAuI,KAAAvI,EAAAoI,MACA8F,EAAAxS,MACAiT,OAAA,kBACAjR,MAAAmR,KAMAX,EAAAxS,MACAiT,OAAA,QAAApO,EACA7C,MAAAoR,EAAAvO,MAIA7C,MAAAwQ,EAAAxP,OAAA,SAAAqQ,EAAAzZ,GACA,MAAAyZ,GAAAzZ,EAAAoI,OACA,GACAwQ,SAAAA,GA9FA,GAAApF,GAAArS,EAAA,0BACA+O,EAAA/O,EAAA,0BACAuY,EAAAvY,EAAA,yBACAgP,EAAAD,EAAAC,YACApI,EAAA5G,EAAA,WAEAqG,EAAArG,EAAA,2BAEAwG,EAAAxG,EAAA,aACA4K,EAAApE,EAAAoE,IAEA7L,GAAAD,QAAA0Y,CAGA,IAAAY,GAAA,GAEAC,GACApD,KAAA,IACAC,KAAA,IACAF,IAAA,IACAG,KAAA,IACAzQ,MAAA,IACA8T,OAAA,IACAC,OAAA,IACA9G,KAAA,IA2EA+G,KAAAC,KAAAC,EAAA,GAAAC,EAAA,GAEAH,GAAAI,MAAA,IACAJ,EAAAK,IAAA,EACAL,EAAAM,IAAA,GACAN,EAAAO,WAAA,EACAP,EAAAQ,WAAA,KACAR,EAAAS,SAAA,IACAT,EAAAU,UAAA,GACAV,EAAAW,WAAA,GACAX,EAAAY,SAAA,IACAZ,EAAAa,UAAA,GACAb,EAAAc,YAAA,GACAd,EAAAtH,MAAA,GACAsH,EAAAhP,OAAA,GACAgP,EAAAe,IAAAb,EACAF,EAAAgB,SAAAb,EAEAF,EAAAI,IAAA,EACAJ,EAAA/V,KAAA,GACA+V,EAAAnP,MAAA,GACAmP,EAAAhH,KAAA,GACAgH,EAAAc,IAAAb,EACAD,EAAAe,SAAAb,EAEArB,EAAAmC,eAAA,SAAArL,EAAAnF,EAAAW,EAAAqE,EAAArI,GACA,GAAAsK,GAAArB,EAAAqB,YAAA9B,EAAAH,EACA,QAAAhF,GACA,IAAAoP,GAAApO,EACA,MAAAmE,GAAApD,OAAAN,EAAAC,SAAAyD,EAAApD,OAAAN,EAAAE,QACA4N,EAAAK,IAAAL,EAAAI,MAEAJ,EAAAK,GAEA,KAAAR,GAAAnO,EACA,MAAAkE,GAAApD,OAAAN,EAAAC,SAAAyD,EAAApD,OAAAN,EAAAE,QACA4N,EAAAK,IAAAL,EAAAI,MAEAxK,EAAApD,OAAAN,EAAAI,SACA0N,EAAAM,IAEAN,EAAAK,IAAAL,EAAAI,KAEA,KAAAP,GAAAjO,IACA,MAAA,SAAAR,EAAA4O,EAAAO,WAEA7I,GAAAtK,EAAA6G,4BAAA+L,EAAAQ,WACA9I,GAAAtK,EAAA8G,wBAAA8L,EAAAS,SAAAT,EAAAU,SAEA,KAAAb,GAAAlO,IACA,MAAA,SAAAP,EAAA4O,EAAAO,YACA7I,GAAAtK,EAAA6G,4BAAA+L,EAAAQ,WACA9I,GAAAtK,EAAA8G,wBAAA8L,EAAAS,SAAAT,EAAAU,WAAAV,EAAAI,KAEA,KAAAP,GAAA9N,MACA,GAAAmP,GAAAtL,EAAAqB,KAAArB,EAAApD,OAAAN,EAAAG,cAAAuD,EAAAmC,UAAAnC,EAAApD,OAAAN,EAAAI,SAGA6O,EAAA,QAAA/P,GAAA,SAAAA,CAGA,OAAA8P,GAAAlB,EAAAa,UAGAM,EAAAnB,EAAAc,YAEApJ,GAAAtK,EAAA+G,2BAAA6L,EAAAW,WAAAjJ,GAAAtK,EAAAgH,uBAAA4L,EAAAY,SAAAZ,EAAAa,SACA,KAAAhB,GAAA/N,MACA,MAAA4F,IAAAtK,EAAAiH,uBAAA2L,EAAAtH,MAAAyH,CACA,KAAAN,GAAA5N,OACA,MAAA+N,GAAAhP,OAEA,MAAAmP,IAGArB,EAAAmC,eAAAnT,OAAAkS,EAEAlB,EAAAsC,aAAA,SAAAxL,EAAAnF,EAAAW,EAAAqE,EAAArI,GAEA,OAAAqD,GACA,IAAAoP,GAAApO,EAAA,MAAAwO,GAAAI,GACA,KAAAR,GAAAnO,EAAA,MAAAuO,GAAAI,GACA,KAAAR,GAAAhO,KACA,MAAA,QAAAT,EAAA8O,EACA,SAAA9O,EAAA8O,EACA,SAAA9O,EAAA8O,EACAD,EAAA/V,IACA,KAAA2V,GAAA9N,MAAA,MAAAkO,GAAAnP,KACA,KAAA+O,GAAA7N,KAAA,MAAAiO,GAAAhH,KAEA,MAAAiH,IAGApB,EAAAsC,aAAAtT,OAAAmS,EAGAnB,EAAAvQ,OACAyL,UAAA8E,EAAAmC,eACAhH,QAAA6E,EAAAsC,gBjBg+CG/I,YAAY,EAAE1J,UAAU,GAAG0S,wBAAwB,GAAGhH,yBAAyB,GAAG/B,yBAAyB,GAAGzJ,0BAA0B,KAAKyS,IAAI,SAASha,EAAQjB,EAAOD,GkBzqD5K,YAEA,IAAA0H,GAAAxG,EAAA,YAEA4G,EAAA7H,EAAAD,SACAmL,OAKArD,GAAAqT,QAAApV,MAAAoV,SAAA,SAAAC,GACA,MAAA,qBAAAC,SAAA9Z,KAAA6Z,IAGAtT,EAAAqJ,KAAA,SAAAmK,EAAAC,GACA,MAAA,KAAAA,EAAAC,QAAAF,IAGAxT,EAAAnB,KAAA,SAAA7F,EAAA2a,GACA,MAAAjV,MAAAC,UAAA3F,EAAA,KAAA2a,IAGA3T,EAAAoC,KAAA,SAAAkR,GACA,GAAAxS,GAAAtD,IACA,KAAAsD,IAAAwS,GAAA9V,EAAAa,KAAAyC,EACA,OAAAtD,IAGAwC,EAAAiD,UAAA,SAAAqQ,GACA,MAAA5U,MAAAI,MAAAJ,KAAAC,UAAA2U,KAGAtT,EAAA3D,QAAA,SAAAiX,EAAArb,EAAA2b,GACA,GAAAN,EAAAjX,QACAiX,EAAAjX,QAAA5C,KAAAma,EAAA3b,OAGA,KAAA,GAAAuF,KAAA8V,GACArb,EAAAwB,KAAAma,EAAAN,EAAA9V,GAAAA,EAAA8V,IAKAtT,EAAAkK,IAAA,SAAA2J,EAAA5b,GACA,GAAAuF,GAAAnE,EAAA,CACA,KAAAmE,IAAAqW,GACA,GAAA5b,EAAA4b,EAAArW,GAAAA,EAAAnE,KACA,OAAA,CAEA,QAAA,GAGA2G,EAAA8M,UAAA,SAAAgH,EAAA7b,EAAA0U,EAAArM,GACA,MAAA,KAAAqM,EACAmH,EAAAhU,IAAA7H,GACA6b,EAAAhU,IAAA,SAAAiU,GACA,GAAAhb,GAAAiH,EAAA8M,UAAAiH,EAAA9b,EAAA0U,EAAA,EACA,OAAArM,GAAAvH,EAAAuH,OAAAN,EAAAgU,UAAAjb,KAIAiH,EAAA6M,aAAA,SAAAiH,EAAA7b,EAAA0U,EAAArM,GACA,MAAA,KAAAqM,EACAmH,EAAAzS,OAAApJ,MACA6b,EAAAhU,IAAA,SAAAiU,GACA,GAAAhb,GAAAiH,EAAA6M,aAAAkH,EAAA9b,EAAA0U,EAAA,EACA,OAAArM,GAAAvH,EAAAuH,OAAAN,EAAAgU,UAAAjb,KAIAiH,EAAAgU,SAAA,SAAAC,GACA,OAAAjU,EAAAqT,QAAAY,IAAAA,EAAAva,OAAA,GAIAsG,EAAAC,SAAA,SAAAiU,EAAAL,GAOA,MANA1Y,UAAA+Y,EAAApY,MACA+X,EAAAxV,KAAA6V,EAAApY,QAEAoY,EAAAxX,MAAAsD,EAAAC,SAAAiU,EAAAxX,KAAAmX,GACAK,EAAAvX,OAAAqD,EAAAC,SAAAiU,EAAAvX,MAAAkX,IAEAA,GAGA7T,EAAAmC,MAAA,SAAAhJ,EAAA4H,GACA,GAAA9H,KAGA,OAFAE,GAAAkD,QAAA,SAAAyE,GAAA7H,EAAA6H,IAAA,IACAC,EAAA1E,QAAA,SAAAyE,GAAA7H,EAAA6H,IAAA,IACAd,EAAAoC,KAAAnJ,IAIA+G,EAAAqD,IAAAmJ,OAAA,SAAAtN,GAEA,OAAAA,EAAAc,EAAAoC,KAAAlD,OAAAmC,OAAA,SAAAJ,EAAAzD,GAEA,MADAyD,GAAAzD,GAAA0B,EAAA1B,GACAyD,GACAkT,OAAAC,OAAAxU,EAAAyD,IAAAgR,eAeArU,EAAAsU,SAAA,SAAArE,GAIA,IAAA,GAHAsE,QAGAlb,EAAA,EAAAA,EAAA4W,EAAAvW,OAAAL,IACA,IAAA,GAAA4C,GAAA,EAAAuF,EAAA+S,EAAA7a,OAAA8H,EAAAvF,EAAAA,IACAsY,EAAAlW,KAAAkW,EAAAtY,GAAAoT,OAAAY,EAAA5W,IAGA,OAAAkb,IAGAvU,EAAAmP,cAAA,SAAAc,EAAAzS,GAEA,IAAA,GADAgX,QACAnb,EAAA,EAAAA,EAAA4W,EAAAvW,OAAAL,IACA,IAAA,GAAA4C,GAAA,EAAAuF,EAAAgT,EAAA9a,OAAA8H,EAAAvF,EAAAA,IAAA,CACA,GAAAwY,GAAAD,EAAAvY,GAAAoT,OAAAY,EAAA5W,GACAob,GAAA/a,QAAA8D,GACAgX,EAAAnW,KAAAoW,GAIA,MAAAD,IAGAxU,EAAA0U,QAAA,SAAAzE,EAAAzS,GAGA,IAAA,GAFAgX,QACAG,KACAtb,EAAA,EAAAA,EAAA4W,EAAAvW,OAAAL,IACA,IAAA,GAAA4C,GAAA,EAAAuF,EAAAgT,EAAA9a,OAAA8H,EAAAvF,EAAAA,IAAA,CACA,GAAAwY,GAAAD,EAAAvY,GAAAoT,OAAAY,EAAA5W,GACAob,GAAA/a,OAAA8D,EACAgX,EAAAnW,KAAAoW,GACAA,EAAA/a,SAAA8D,GACAmX,EAAAtW,KAAAoW,GAIA,MAAAE,IAGA3U,EAAA4U,MAAA,SAAAzb,EAAA4H,GAEA,IAAA,GADAD,MACAzH,EAAA,EAAAA,EAAAF,EAAAO,OAAAL,IACA,IAAA,GAAA4C,GAAA,EAAAA,EAAA8E,EAAArH,OAAAuC,IACA6E,EAAAzC,KAAAlF,EAAAE,GAAAgW,OAAAtO,EAAA9E,IAGA,OAAA6E,MlB8qDGiG,WAAW,IAAI8N,IAAI,SAASzb,EAAQjB,EAAOD,ImB/0D9C,SAAAM,EAAAsc,GACA,gBAAA5c,IAAA,mBAAAC,GAAA2c,EAAA5c,GACA,kBAAAE,IAAAA,EAAAC,IAAAD,EAAA,WAAA,WAAA0c,GACAA,EAAAtc,EAAAuc,aACArc,KAAA,SAAAR,GAAA,YAIA,SAAA8c,GAAAC,EAAAC,EAAA5M,EAAAzF,GAEA,QAAAsS,GAAAC,GACA,MAAAH,GAAAG,EAAA,GAAAC,OAAAD,IAAAA,EAyDA,MAtDAD,GAAAG,MAAAH,EAEAA,EAAAxX,MAAA,SAAAyX,GACA,GAAAG,GAAA,GAAAF,OAAAD,GACAI,EAAA,GAAAH,MAAAD,EAAA,EAEA,OADAH,GAAAM,GAAAN,EAAAO,GAAAN,EAAAM,EAAA,GACAA,EAAAJ,EAAAA,EAAAG,EAAAA,EAAAC,GAGAL,EAAApX,KAAA,SAAAqX,GACA,MAAAH,GAAAG,EAAA,GAAAC,MAAAD,EAAA,IAAAF,EAAAE,EAAA,GAAAA,GAGAD,EAAAM,OAAA,SAAAL,EAAAM,GACA,MAAAR,GAAAE,EAAA,GAAAC,OAAAD,GAAA,MAAAM,EAAA,EAAAnb,KAAA+a,MAAAI,IAAAN,GAGAD,EAAAQ,MAAA,SAAAC,EAAAC,EAAAH,GACA,GAAAC,KAIA,IAHAC,EAAA,GAAAP,MAAAO,EAAA,GACAC,EAAA,GAAAR,OAAAQ,GACAH,EAAA,MAAAA,EAAA,EAAAnb,KAAA+a,MAAAI,KACAG,EAAAD,GAAAF,EAAA,GAAA,MAAAC,EAGA,KAFAT,EAAAU,EAAA,GAAAX,EAAAW,GACAC,EAAAD,GAAAD,EAAAtX,KAAA,GAAAgX,OAAAO,IACAV,EAAAU,EAAAF,GAAAT,EAAAW,GAAAC,EAAAD,GAAAD,EAAAtX,KAAA,GAAAgX,OAAAO,GACA,OAAAD,IAGAR,EAAA7U,OAAA,SAAAwV,GACA,MAAAd,GAAA,SAAAI,GACA,KAAAH,EAAAG,IAAAU,EAAAV,IAAAA,EAAAW,QAAAX,EAAA,IACA,SAAAA,EAAAM,GACA,OAAAA,GAAA,GAAA,KAAAR,EAAAE,EAAA,IAAAU,EAAAV,SAIA9M,IACA6M,EAAA7M,MAAA,SAAAsN,EAAAI,GAGA,MAFAC,GAAAF,SAAAH,GAAAM,EAAAH,SAAAC,GACAf,EAAAgB,GAAAhB,EAAAiB,GACA3b,KAAA+a,MAAAhN,EAAA2N,EAAAC,KAGAf,EAAAgB,MAAA,SAAAT,GAEA,MADAA,GAAAnb,KAAA+a,MAAAI,GACAU,SAAAV,IAAAA,EAAA,EACAA,EAAA,EACAP,EAAA7U,OAAAuC,EACA,SAAA7B,GAAA,MAAA6B,GAAA7B,GAAA0U,IAAA,GACA,SAAA1U,GAAA,MAAAmU,GAAA7M,MAAA,EAAAtH,GAAA0U,IAAA,IAHAP,EADA,OAQAA,EAiEA,QAAAkB,GAAAhd,GACA,MAAA2b,GAAA,SAAAI,GACAA,EAAAkB,SAAA,EAAA,EAAA,EAAA,GACAlB,EAAAmB,QAAAnB,EAAAoB,WAAApB,EAAAqB,SAAA,EAAApd,GAAA,IACA,SAAA+b,EAAAM,GACAN,EAAAmB,QAAAnB,EAAAoB,UAAA,EAAAd,IACA,SAAAE,EAAAI,GACA,OAAAA,EAAAJ,EAAA,KAAAI,EAAAU,oBAAAd,EAAAc,sBAAA,SA0EA,QAAAC,GAAAtd,GACA,MAAA2b,GAAA,SAAAI,GACAA,EAAAwB,YAAA,EAAA,EAAA,EAAA,GACAxB,EAAAyB,WAAAzB,EAAA0B,cAAA1B,EAAA2B,YAAA,EAAA1d,GAAA,IACA,SAAA+b,EAAAM,GACAN,EAAAyB,WAAAzB,EAAA0B,aAAA,EAAApB,IACA,SAAAE,EAAAI,GACA,OAAAA,EAAAJ,GAAA,SAvNA,GAAAK,GAAA,GAAAZ,MACAa,EAAA,GAAAb,MAgEA2B,EAAAhC,EAAA,aAEA,SAAAI,EAAAM,GACAN,EAAAW,SAAAX,EAAAM,IACA,SAAAE,EAAAI,GACA,MAAAA,GAAAJ,GAIAoB,GAAAb,MAAA,SAAA3Y,GAEA,MADAA,GAAAjD,KAAA+a,MAAA9X,GACA4Y,SAAA5Y,IAAAA,EAAA,EACAA,EAAA,EACAwX,EAAA,SAAAI,GACAA,EAAAW,QAAAxb,KAAA+a,MAAAF,EAAA5X,GAAAA,IACA,SAAA4X,EAAAM,GACAN,EAAAW,SAAAX,EAAAM,EAAAlY,IACA,SAAAoY,EAAAI,GACA,OAAAA,EAAAJ,GAAApY,IANAwZ,EADA,KAWA,IAAAC,GAAAjC,EAAA,SAAAI,GACAA,EAAA8B,gBAAA,IACA,SAAA9B,EAAAM,GACAN,EAAAW,SAAAX,EAAA,IAAAM,IACA,SAAAE,EAAAI,GACA,OAAAA,EAAAJ,GAAA,KACA,SAAAR,GACA,MAAAA,GAAA+B,eAGAC,EAAApC,EAAA,SAAAI,GACAA,EAAAiC,WAAA,EAAA,IACA,SAAAjC,EAAAM,GACAN,EAAAW,SAAAX,EAAA,IAAAM,IACA,SAAAE,EAAAI,GACA,OAAAA,EAAAJ,GAAA,KACA,SAAAR,GACA,MAAAA,GAAAkC,eAGAC,EAAAvC,EAAA,SAAAI,GACAA,EAAAoC,WAAA,EAAA,EAAA,IACA,SAAApC,EAAAM,GACAN,EAAAW,SAAAX,EAAA,KAAAM,IACA,SAAAE,EAAAI,GACA,OAAAA,EAAAJ,GAAA,MACA,SAAAR,GACA,MAAAA,GAAAqC,aAGAC,EAAA1C,EAAA,SAAAI,GACAA,EAAAkB,SAAA,EAAA,EAAA,EAAA,IACA,SAAAlB,EAAAM,GACAN,EAAAmB,QAAAnB,EAAAoB,UAAAd,IACA,SAAAE,EAAAI,GACA,OAAAA,EAAAJ,EAAA,KAAAI,EAAAU,oBAAAd,EAAAc,sBAAA,OACA,SAAAtB,GACA,MAAAA,GAAAoB,UAAA,IAcAmB,EAAAtB,EAAA,GACAuB,EAAAvB,EAAA,GACAwB,EAAAxB,EAAA,GACAyB,EAAAzB,EAAA,GACA0B,EAAA1B,EAAA,GACA2B,EAAA3B,EAAA,GACA4B,EAAA5B,EAAA,GAEA6B,EAAAlD,EAAA,SAAAI,GACAA,EAAAkB,SAAA,EAAA,EAAA,EAAA,GACAlB,EAAAmB,QAAA,IACA,SAAAnB,EAAAM,GACAN,EAAA+C,SAAA/C,EAAAgD,WAAA1C,IACA,SAAAE,EAAAI,GACA,MAAAA,GAAAoC,WAAAxC,EAAAwC,WAAA,IAAApC,EAAAqC,cAAAzC,EAAAyC,gBACA,SAAAjD,GACA,MAAAA,GAAAgD,aAGAE,EAAAtD,EAAA,SAAAI,GACAA,EAAAkB,SAAA,EAAA,EAAA,EAAA,GACAlB,EAAA+C,SAAA,EAAA,IACA,SAAA/C,EAAAM,GACAN,EAAAmD,YAAAnD,EAAAiD,cAAA3C,IACA,SAAAE,EAAAI,GACA,MAAAA,GAAAqC,cAAAzC,EAAAyC,eACA,SAAAjD,GACA,MAAAA,GAAAiD,gBAGAG,EAAAxD,EAAA,SAAAI,GACAA,EAAAqD,mBAAA,IACA,SAAArD,EAAAM,GACAN,EAAAW,SAAAX,EAAA,IAAAM,IACA,SAAAE,EAAAI,GACA,OAAAA,EAAAJ,GAAA,KACA,SAAAR,GACA,MAAAA,GAAAsD,kBAGAC,EAAA3D,EAAA,SAAAI,GACAA,EAAAwD,cAAA,EAAA,IACA,SAAAxD,EAAAM,GACAN,EAAAW,SAAAX,EAAA,IAAAM,IACA,SAAAE,EAAAI,GACA,OAAAA,EAAAJ,GAAA,KACA,SAAAR,GACA,MAAAA,GAAAyD,kBAGAC,EAAA9D,EAAA,SAAAI,GACAA,EAAA2D,cAAA,EAAA,EAAA,IACA,SAAA3D,EAAAM,GACAN,EAAAW,SAAAX,EAAA,KAAAM,IACA,SAAAE,EAAAI,GACA,OAAAA,EAAAJ,GAAA,MACA,SAAAR,GACA,MAAAA,GAAA4D,gBAGAC,EAAAjE,EAAA,SAAAI,GACAA,EAAAwB,YAAA,EAAA,EAAA,EAAA,IACA,SAAAxB,EAAAM,GACAN,EAAAyB,WAAAzB,EAAA0B,aAAApB,IACA,SAAAE,EAAAI,GACA,OAAAA,EAAAJ,GAAA,OACA,SAAAR,GACA,MAAAA,GAAA0B,aAAA,IAcAoC,EAAAvC,EAAA,GACAwC,EAAAxC,EAAA,GACAyC,EAAAzC,EAAA,GACA0C,EAAA1C,EAAA,GACA2C,EAAA3C,EAAA,GACA4C,EAAA5C,EAAA,GACA6C,EAAA7C,EAAA,GAEA8C,EAAAzE,EAAA,SAAAI,GACAA,EAAAwB,YAAA,EAAA,EAAA,EAAA,GACAxB,EAAAyB,WAAA,IACA,SAAAzB,EAAAM,GACAN,EAAAsE,YAAAtE,EAAAuE,cAAAjE,IACA,SAAAE,EAAAI,GACA,MAAAA,GAAA2D,cAAA/D,EAAA+D,cAAA,IAAA3D,EAAA4D,iBAAAhE,EAAAgE,mBACA,SAAAxE,GACA,MAAAA,GAAAuE,gBAGAE,EAAA7E,EAAA,SAAAI,GACAA,EAAAwB,YAAA,EAAA,EAAA,EAAA,GACAxB,EAAAsE,YAAA,EAAA,IACA,SAAAtE,EAAAM,GACAN,EAAA0E,eAAA1E,EAAAwE,iBAAAlE,IACA,SAAAE,EAAAI,GACA,MAAAA,GAAA4D,iBAAAhE,EAAAgE,kBACA,SAAAxE,GACA,MAAAA,GAAAwE,mBAGAG,EAAA/C,EAAArB,MACAqE,EAAA/C,EAAAtB,MACAsE,EAAA7C,EAAAzB,MACAuE,EAAA3C,EAAA5B,MACAwE,EAAAzC,EAAA/B,MACAyE,EAAAzC,EAAAhC,MACA0E,EAAAzC,EAAAjC,MACA2E,EAAAzC,EAAAlC,MACA4E,EAAAzC,EAAAnC,MACA6E,EAAAzC,EAAApC,MACA8E,EAAAzC,EAAArC,MACA+E,EAAAzC,EAAAtC,MACAgF,EAAAhD,EAAAhC,MACAiF,EAAA1C,EAAAvC,MACAkF,EAAAvC,EAAA3C,MAEAmF,EAAA9D,EACA+D,EAAAhB,EACAiB,EAAAxC,EAAA7C,MACAsF,EAAAtC,EAAAhD,MACAuF,EAAApC,EAAAnD,MACAwF,EAAAlC,EAAAtD,MACAyF,GAAAlC,EAAAvD,MACA0F,GAAAlC,EAAAxD,MACA2F,GAAAlC,EAAAzD,MACA4F,GAAAlC,EAAA1D,MACA6F,GAAAlC,EAAA3D,MACA8F,GAAAlC,EAAA5D,MACA+F,GAAAlC,EAAA7D,MACAgG,GAAAzC,EAAAvD,MACAiG,GAAAnC,EAAA9D,MACAkG,GAAAhC,EAAAlE,MAEAmG,GAAA,OAEA5jB,GAAA4jB,QAAAA,GACA5jB,EAAA6hB,aAAAA,EACA7hB,EAAA8hB,QAAAA,EACA9hB,EAAA+hB,QAAAA,EACA/hB,EAAAgiB,MAAAA,EACAhiB,EAAAiiB,KAAAA,EACAjiB,EAAAkiB,QAAAA,EACAliB,EAAAmiB,QAAAA,EACAniB,EAAAoiB,SAAAA,EACApiB,EAAAqiB,WAAAA,EACAriB,EAAAsiB,UAAAA,EACAtiB,EAAAuiB,QAAAA,EACAviB,EAAAwiB,UAAAA,EACAxiB,EAAAyiB,MAAAA,EACAziB,EAAA0iB,OAAAA,EACA1iB,EAAA2iB,MAAAA,EACA3iB,EAAA4iB,eAAAA,EACA5iB,EAAA6iB,gBAAAA,EACA7iB,EAAA8iB,WAAAA,EACA9iB,EAAA+iB,WAAAA,EACA/iB,EAAAgjB,SAAAA,EACAhjB,EAAAijB,QAAAA,EACAjjB,EAAAkjB,WAAAA,GACAljB,EAAAmjB,WAAAA,GACAnjB,EAAAojB,YAAAA,GACApjB,EAAAqjB,cAAAA,GACArjB,EAAAsjB,aAAAA,GACAtjB,EAAAujB,WAAAA,GACAvjB,EAAAwjB,aAAAA,GACAxjB,EAAAyjB,SAAAA,GACAzjB,EAAA0jB,UAAAA,GACA1jB,EAAA2jB,SAAAA,GACA3jB,EAAA8e,YAAAA,EACA9e,EAAA+e,OAAAA,EACA/e,EAAAkf,OAAAA,EACAlf,EAAAqf,KAAAA,EACArf,EAAAwf,IAAAA,EACAxf,EAAAyf,OAAAA,EACAzf,EAAA0f,OAAAA,EACA1f,EAAA2f,QAAAA,EACA3f,EAAA4f,UAAAA,EACA5f,EAAA6f,SAAAA,EACA7f,EAAA8f,OAAAA,EACA9f,EAAA+f,SAAAA,EACA/f,EAAA6jB,KAAApE,EACAzf,EAAAggB,MAAAA,EACAhgB,EAAAogB,KAAAA,EACApgB,EAAAsgB,UAAAA,EACAtgB,EAAAygB,UAAAA,EACAzgB,EAAA4gB,QAAAA,EACA5gB,EAAA+gB,OAAAA,EACA/gB,EAAAghB,UAAAA,EACAhhB,EAAAihB,UAAAA,EACAjhB,EAAAkhB,WAAAA,EACAlhB,EAAAmhB,aAAAA,EACAnhB,EAAAohB,YAAAA,EACAphB,EAAAqhB,UAAAA,EACArhB,EAAAshB,YAAAA,EACAthB,EAAA8jB,QAAA9C,EACAhhB,EAAAuhB,SAAAA,EACAvhB,EAAA2hB,QAAAA,EACA3hB,EAAAid,SAAAH,SnBm1DMiH,IAAI,SAAS7iB,EAAQjB,EAAOD,GoB9qElC,QAAAgkB,GAAAhd,GACA,IAAAA,EAAA,KAAA5F,OAAA,2BAGA,IAOAoc,GAAA/I,EAAAwP,EAAAC,EAAArI,EAAA1a,EAAAgjB,EAPAC,EAAApd,EAAAqd,SAAA,GACAC,EAAAtd,EAAAsd,MAAA,GACAC,EAAAliB,KAAAmiB,IAAAF,GACAG,EAAAzd,EAAAyd,MAAA,EAAA,GACApgB,EAAA2C,EAAA3C,IACA3B,EAAAsE,EAAAtE,IACAgiB,EAAAhiB,EAAA2B,CAGA,IAAA2C,EAAAwW,KAEAA,EAAAxW,EAAAwW,SACA,IAAAxW,EAAA2d,MAEAnH,EAAAxW,EAAA2d,MAAAtiB,KAAAgC,IACA2C,EAAA2d,MAAAnjB,OAAA,EACAojB,EAAA5d,EAAA2d,MAAAD,EAAAN,EAAA,EAAApd,EAAA2d,MAAAnjB,cAEA,CAEAiT,EAAApS,KAAAwD,KAAAxD,KAAAmiB,IAAAJ,GAAAG,GACAN,EAAAjd,EAAAid,SAAA,EACAzG,EAAAnb,KAAAK,IACAuhB,EACA5hB,KAAAC,IAAAgiB,EAAAjiB,KAAAoD,MAAApD,KAAAmiB,IAAAE,GAAAH,GAAA9P,GAIA,GAAA+I,IAAA8G,QAAAjiB,KAAAwD,KAAA6e,EAAAlH,GAAA4G,EAGA,KAAAjjB,EAAA,EAAAA,EAAAsjB,EAAAjjB,SAAAL,EACA0a,EAAA2B,EAAAiH,EAAAtjB,GACA0a,GAAAoI,GAAAG,GAAAM,EAAA7I,IAAA2B,EAAA3B,GAWA,MANAA,GAAAxZ,KAAAmiB,IAAAhH,GACA0G,EAAArI,GAAA,EAAA,MAAAA,EAAA0I,GAAA,EACAJ,EAAA9hB,KAAAC,IAAAgiB,GAAAJ,EAAA,GACA7f,EAAAhC,KAAAgC,IAAAA,EAAAhC,KAAA+a,MAAA/Y,EAAAmZ,EAAA2G,GAAA3G,GACA9a,EAAAL,KAAAwD,KAAAnD,EAAA8a,GAAAA,GAGAE,MAAArZ,EACAsZ,KAAAjb,EACA8a,KAAAA,EACAqH,MAAAX,UAAAA,GACAtgB,MAAAA,EACAD,MAAAA,GAIA,QAAAihB,GAAA3jB,EAAA2H,EAAAkc,EAAAC,GACA,KAAAA,EAAAD,GAAA,CACA,GAAAE,GAAAF,EAAAC,IAAA,CACAjd,GAAAmd,IAAAhkB,EAAA+jB,GAAApc,GAAA,EAAAkc,EAAAE,EAAA,EACAD,EAAAC,EAEA,MAAAF,GAGA,QAAAlhB,GAAAiY,GACA,MAAArb,MAAAgd,KAAAnb,KAAA+a,MAAAvB,EAAArb,KAAAgd,KAAA0H,GAGA,QAAAvhB,GAAAkY,GACA,MAAAxZ,MAAA+a,OAAAvB,EAAArb,KAAAkd,OAAAld,KAAAgd,KAAA0H,GAGA,QAAAC,GAAAtJ,GACA,MAAArb,MAAAqkB,KAAA3H,KAAAtZ,EAAArC,KAAAf,KAAAqb,IAGA,QAAAuJ,GAAAvJ,GACA,MAAAlY,GAAApC,KAAAf,KAAAA,KAAAqkB,KAAAA,KAAAhJ,IApFA,GAAA/T,GAAA5G,EAAA,WACAmkB,EAAAnkB,EAAA,WACAgkB,EAAA,KAqFAlB,GAAA9G,KAAA,SAAAlW,GACA,IAAAA,EAAA,KAAA5F,OAAA,gCAGA,IAAAkkB,GAAAte,EAAAue,IAAAF,EAAAE,IAAAF,EACAG,EAAAxe,EAAA3C,IACAohB,EAAAze,EAAAtE,IACA0hB,EAAApd,EAAAqd,SAAA,GACAqB,EAAA1e,EAAA2e,SAAA,EACAjB,GAAAe,GAAAD,EACAX,EAAA7d,EAAA6d,KAAAS,EAAAte,EAAA6d,MAAAS,EAAAM,KAAAlB,EAAAgB,EAAAtB,GACAvZ,EAAAmZ,GACA3f,IAAA,MAAAwgB,EAAAxgB,IAAAwgB,EAAAxgB,IAAAwgB,EAAAA,KAAAW,GACA9iB,IAAA,MAAAmiB,EAAAniB,IAAAmiB,EAAAniB,IAAAmiB,EAAAA,KAAAY,GACApB,QAAAD,EACAH,QAAAY,EAAAZ,QACAU,MAAAE,EAAArH,MAMA,OAHA3S,GAAAga,KAAAA,EACAha,EAAAlH,MAAAyhB,EACApe,EAAA6e,MAAAhb,EAAAjH,MAAAuhB,GACAta,GAGA5K,EAAAD,QAAAgkB,IpBqrEG8B,UAAU,GAAGvd,UAAU,KAAKwd,IAAI,SAAS7kB,EAAQjB,EAAOD,GqBryE3D,GAAAmL,GAAAlL,EAAAD,UAEAmL,GAAA6a,OAAA,SAAAC,EAAArlB,GACA,GAAAO,GAAAF,EAAA8E,MAAAnF,EACA,KAAAO,EAAA,EAAAP,EAAAO,IAAAA,EAAAF,EAAAE,GAAA8kB,CACA,OAAAhlB,IAGAkK,EAAA+a,MAAA,SAAAtlB,GACA,MAAAuK,GAAA6a,OAAA,EAAAplB,IAGAuK,EAAAsS,MAAA,SAAAC,EAAAC,EAAAH,GAQA,GAPA2I,UAAA3kB,OAAA,IACAgc,EAAA,EACA2I,UAAA3kB,OAAA,IACAmc,EAAAD,EACAA,EAAA,KAGAC,EAAAD,GAAAF,GAAAta,EAAAA,EAAA,KAAA,IAAA9B,OAAA,iBACA,IAAA2C,GAAA0Z,KAAAtc,EAAA,EACA,IAAA,EAAAqc,EAAA,MAAAzZ,EAAA2Z,EAAAF,IAAArc,GAAAwc,GAAAF,EAAAtX,KAAApC,OACA,OAAAA,EAAA2Z,EAAAF,IAAArc,GAAAwc,GAAAF,EAAAtX,KAAApC,EACA,OAAA0Z,IAGAtS,EAAAzF,UAEAyF,EAAAzF,OAAA0gB,QAAA,SAAA/hB,EAAA3B,GACAO,SAAAP,IACAA,EAAAO,SAAAoB,EAAA,EAAAA,EACAA,EAAA,EAEA,IAAAyE,GAAApG,EAAA2B,EACAtE,EAAA,WACA,MAAAsE,GAAAyE,EAAAzG,KAAAqD,SAcA,OAZA3F,GAAAsmB,QAAA,SAAAzlB;AACA,MAAAuK,GAAA+a,MAAAtlB,GAAAgH,IAAA7H,IAEAA,EAAAumB,IAAA,SAAA1d,GACA,MAAAA,IAAAvE,GAAA3B,GAAAkG,EAAA,EAAAE,EAAA,GAEA/I,EAAAwmB,IAAA,SAAA3d,GACA,MAAAvE,GAAAuE,EAAA,EAAAA,EAAAlG,EAAA,GAAAkG,EAAAvE,GAAAyE,GAEA/I,EAAAymB,KAAA,SAAAhN,GACA,MAAAA,IAAA,GAAA,GAAAA,EAAAnV,EAAAmV,EAAA1Q,EAAA2d,KAEA1mB,GAGAoL,EAAAzF,OAAAghB,QAAA,SAAAzlB,EAAA4H,GACA5F,SAAA4F,IACAA,EAAA5H,EACAA,EAAA,EAEA,IAAA6H,GAAAD,EAAA5H,EACAlB,EAAA,WACA,MAAAkB,GAAAoB,KAAA+a,MAAAtU,EAAAzG,KAAAqD,UAeA,OAbA3F,GAAAsmB,QAAA,SAAAzlB,GACA,MAAAuK,GAAA+a,MAAAtlB,GAAAgH,IAAA7H,IAEAA,EAAAumB,IAAA,SAAA1d,GACA,MAAAA,KAAAvG,KAAA+a,MAAAxU,IAAAA,GAAA3H,GAAA4H,EAAAD,EAAA,EAAAE,EAAA,GAEA/I,EAAAwmB,IAAA,SAAA3d,GACA,GAAAiT,GAAAxZ,KAAA+a,MAAAxU,EACA,OAAA3H,GAAA4a,EAAA,EAAAA,GAAAhT,EAAA,GAAAgT,EAAA5a,EAAA,GAAA6H,GAEA/I,EAAAymB,KAAA,SAAAhN,GACA,MAAAA,IAAA,GAAA,GAAAA,EAAAvY,EAAA,EAAAoB,KAAA+a,MAAA5D,EAAA1Q,GAAA2d,KAEA1mB,GAGAoL,EAAAzF,OAAAihB,OAAA,SAAAxO,EAAAD,GACAC,EAAAA,GAAA,EACAD,EAAAA,GAAA,CACA,IAAA0O,GACA7mB,EAAA,WACA,GAAA8mB,GAAA9d,EAAAH,EAAA,EAAA+J,EAAA,CACA,IAAA1P,SAAA2jB,EAGA,MAFAhe,GAAAge,EACAA,EAAA3jB,OACA2F,CAEA,GACAA,GAAA,EAAAvG,KAAAqD,SAAA,EACAiN,EAAA,EAAAtQ,KAAAqD,SAAA,EACAmhB,EAAAje,EAAAA,EAAA+J,EAAAA,QACA,IAAAkU,GAAAA,EAAA,EAGA,OAFA9d,GAAA1G,KAAAE,KAAA,GAAAF,KAAAmiB,IAAAqC,GAAAA,GACAD,EAAAzO,EAAAxF,EAAA5J,EAAAmP,EACAC,EAAAvP,EAAAG,EAAAmP,EAwDA,OAtDAnY,GAAAsmB,QAAA,SAAAzlB,GACA,MAAAuK,GAAA+a,MAAAtlB,GAAAgH,IAAA7H,IAEAA,EAAAumB,IAAA,SAAA1d,GACA,GAAAke,GAAAzkB,KAAAykB,IAAAzkB,KAAAC,IAAAsG,EAAAuP,EAAA,IAAA,GAAA9V,KAAAC,IAAA4V,EAAA,IACA,OAAA,IAAAA,EAAA7V,KAAAE,KAAA,EAAAF,KAAA0kB,KAAAD,GAEA/mB,EAAAwmB,IAAA,SAAA3d,GAGA,GAAAoe,GACAC,GAAAre,EAAAuP,GAAAD,EACAgP,EAAA7kB,KAAAI,IAAAwkB,EACA,IAAAC,EAAA,GACAF,EAAA,MACA,CACA,GAAA1gB,GAAAwgB,EAAAzkB,KAAAykB,KAAAI,EAAAA,EAAA,EACA,kBAAAA,GACA5gB,EAAA,kBAAA4gB,EAAA,iBACA5gB,EAAAA,EAAA4gB,EAAA,iBACA5gB,EAAAA,EAAA4gB,EAAA,gBACA5gB,EAAAA,EAAA4gB,EAAA,iBACA5gB,EAAAA,EAAA4gB,EAAA,iBACA5gB,EAAAA,EAAA4gB,EAAA,iBACAF,EAAAF,EAAAxgB,EACAA,EAAA,kBAAA4gB,EAAA,iBACA5gB,EAAAA,EAAA4gB,EAAA,gBACA5gB,EAAAA,EAAA4gB,EAAA,iBACA5gB,EAAAA,EAAA4gB,EAAA,iBACA5gB,EAAAA,EAAA4gB,EAAA,iBACA5gB,EAAAA,EAAA4gB,EAAA,iBACA5gB,EAAAA,EAAA4gB,EAAA,iBACAF,GAAA1gB,IAEAA,EAAA4gB,EAAA,IACA5gB,EAAA4gB,EAAA,EAAA5gB,EACAA,EAAA4gB,EAAA,EAAA5gB,EACAA,EAAA4gB,EAAA,EAAA5gB,EACAA,EAAA4gB,EAAA,EAAA5gB,EACA0gB,EAAAF,EAAAxgB,EAAA,gBAGA,MAAA2gB,GAAA,EAAA,EAAAD,EAAAA,GAEAjnB,EAAAymB,KAAA,SAAAhN,GAEA,GAAA,GAAAA,GAAAA,GAAA,EAAA,MAAAiN,IACA,IAAA7d,GAAA,EAAA4Q,EAAA,EACAqC,EAAA,GAAAxZ,KAAA0kB,GAAA,IAAA,EAAA1kB,KAAA0kB,IAAA,EAAA1kB,KAAA0kB,KACA9lB,EAAA,GAAAoB,KAAA0kB,GAAAlL,GAAAxZ,KAAAmiB,IAAA,EAAAniB,KAAAC,IAAAsG,EAAA,IAAA,EACAC,EAAAxG,KAAAmiB,IAAA,EAAA5b,EAAAA,GAAAiT,EACA/a,GAAA8H,EAAA,EAAA,EAAA,IAAAvG,KAAAE,KAAAF,KAAAE,KAAAtB,EAAAA,EAAA4H,GAAA5H,EACA,OAAAkX,GAAAD,EAAA7V,KAAA8kB,MAAArmB,GAEAf,QrBwyEMqnB,IAAI,SAASlmB,EAAQjB,EAAOD,GsB76ElC,QAAAqnB,GAAAxa,EAAAya,GACA,MAAAA,QACAza,EAAA0a,GAAAD,GADAza,GAAAA,EAAA0a,IAAA,KAIA,QAAAnb,GAAAob,EAAAznB,GACAynB,EAAA1f,EAAAyT,MAAAiM,GACAznB,EAAA+H,EAAA2f,EAAA1nB,EACA,IAAA8b,GAAA1a,EAAAP,CAGA,IAAA4mB,EAAAD,KACA1L,EAAA9b,EAAAynB,EAAAD,IACAzf,EAAA4f,SAAA7L,IAAA,MAAAA,EAGA,KAAA1a,EAAA,EAAAP,EAAA4mB,EAAAhmB,QAAAsG,EAAA6f,QAAA9L,IAAAjb,EAAAO,IAAAA,EACA0a,EAAA9b,EAAAA,EAAAynB,EAAArmB,IAAAqmB,EAAArmB,EAGA,OAAA2G,GAAA8f,OAAA/L,GAAA,OACA/T,EAAA+f,SAAAhM,GAAA,SACA/T,EAAAggB,UAAAjM,GAAA,UACA/T,EAAA4f,SAAA7L,GAAA,SAAA,KAGA,QAAAkM,GAAAlb,EAAAmb,GACA,MAAAnb,GAAArL,QACAwmB,EAAAA,GAAAlgB,EAAAoC,KAAA2C,EAAA,IACAmb,EAAA7e,OAAA,SAAAme,EAAAvnB,GACA,MAAAunB,GAAAvnB,GAAAqM,EAAAS,EAAA9M,GAAAunB,QAHA,OAOA,QAAAW,GAAAT,EAAAznB,GACAynB,EAAA1f,EAAAyT,MAAAiM,GACAznB,EAAA+H,EAAA2f,EAAA1nB,EACA,IAAAoB,GAAA4C,EAAA8X,EAGAyL,GAAA,UAAA,UAAA,SAAA,OAEA,KAAAnmB,EAAA,EAAAA,EAAAqmB,EAAAhmB,SAAAL,EAAA,CAIA,IAFA0a,EAAA9b,EAAAA,EAAAynB,EAAArmB,IAAAqmB,EAAArmB,GAEA4C,EAAA,EAAAA,EAAAujB,EAAA9lB,SAAAuC,EACA+D,EAAA6f,QAAA9L,KAAAqM,EAAAZ,EAAAvjB,IAAA8X,KACAyL,EAAA5iB,OAAAX,EAAA,GACAA,GAAA,EAIA,IAAA,IAAAujB,EAAA9lB,OAAA,MAAA,SAGA,MAAA8lB,GAAA,GAGA,QAAAa,GAAAtb,EAAAmb,GAEA,MADAA,GAAAA,GAAAlgB,EAAAoC,KAAA2C,EAAA,IACAmb,EAAA7e,OAAA,SAAAme,EAAAvnB,GAEA,MADAunB,GAAAvnB,GAAAkoB,EAAApb,EAAA9M,GACAunB,OAlFA,GAAAxf,GAAA5G,EAAA,WAEAqmB,EAAA,YAEAa,GACAC,UAAAvgB,EAAAA,WACA4e,QAAA5e,EAAAwgB,OACAA,OAAAxgB,EAAAwgB,OACApL,KAAApV,EAAAoV,KACAqL,OAAA,SAAA3f,GAAA,MAAA,KAAAA,EAAA,KAAAA,IAGAsf,GACAG,UAAA,SAAAzf,GAAA,MAAA,SAAAA,GAAA,UAAAA,GAAAd,EAAAggB,UAAAlf,IACA8d,QAAA,SAAA9d,GAAA,MAAAsf,GAAAI,OAAA1f,KAAAA,GAAAA,OAAAA,GACA0f,OAAA,SAAA1f,GAAA,OAAA4f,OAAA5f,KAAAd,EAAA8f,OAAAhf,IACAsU,KAAA,SAAAtU,GAAA,OAAA4f,MAAArL,KAAAvW,MAAAgC,KAsEAwD,GAAAib,WAAAA,EACAjb,EAAAqc,IAAAV,EACA3b,EAAA6b,MAAAA,EACA7b,EAAA+b,SAAAA,EACA/b,EAAAsc,QAAAN,EACAnoB,EAAAD,QAAAoM,ItBm8EG7D,UAAU,KAAKogB,IAAI,SAASznB,EAAQjB,EAAOD,GuB9hF9C,GAAA8H,GAAA5G,EAAA,UACAkL,EAAAlL,EAAA,iBACAiK,EAAAjK,EAAA,cAEAmO,IAIAA,GAAAuZ,OAAA,SAAApB,EAAAznB,EAAA8oB,GACA9oB,EAAA+H,EAAA2f,EAAA1nB,GACA8oB,EAAAA,KACA,IAAAhN,GAAA1a,EAAAP,EAAAI,IACA,KAAAG,EAAA,EAAAP,EAAA4mB,EAAAhmB,OAAAZ,EAAAO,IAAAA,EACA0a,EAAA9b,EAAAA,EAAAynB,EAAArmB,IAAAqmB,EAAArmB,GACA0a,IAAA7a,KACAA,EAAA6a,GAAA,EACAgN,EAAA1iB,KAAA0V,GAEA,OAAAgN,IAIAxZ,EAAAe,MAAA,SAAAoX,GACA,MAAAA,IAAAA,EAAAhmB,QAAA,GAIA6N,EAAAe,MAAA0Y,MAAA,SAAAtB,EAAAznB,GACAA,EAAA+H,EAAA2f,EAAA1nB,EACA,IAAA8b,GAAA1a,EAAAP,EAAAkoB,EAAA,CACA,KAAA3nB,EAAA,EAAAP,EAAA4mB,EAAAhmB,OAAAZ,EAAAO,IAAAA,EACA0a,EAAA9b,EAAAA,EAAAynB,EAAArmB,IAAAqmB,EAAArmB,GACA2G,EAAA6f,QAAA9L,KAAAiN,GAAA,EAEA,OAAAA,IAIAzZ,EAAAe,MAAA2Y,QAAA,SAAAvB,EAAAznB,GACAA,EAAA+H,EAAA2f,EAAA1nB,EACA,IAAA8b,GAAA1a,EAAAP,EAAAwP,EAAA,CACA,KAAAjP,EAAA,EAAAP,EAAA4mB,EAAAhmB,OAAAZ,EAAAO,IAAAA,EACA0a,EAAA9b,EAAAA,EAAAynB,EAAArmB,IAAAqmB,EAAArmB,GACA,MAAA0a,IAAAzL,GAAA,EAEA,OAAAA,IAKAf,EAAAe,MAAA4Y,SAAA,SAAAxB,EAAAznB,GACAA,EAAA+H,EAAA2f,EAAA1nB,EACA,IAAA8b,GAAA1a,EAAAP,EAAAI,KAAAoP,EAAA,CACA,KAAAjP,EAAA,EAAAP,EAAA4mB,EAAAhmB,OAAAZ,EAAAO,IAAAA,EACA0a,EAAA9b,EAAAA,EAAAynB,EAAArmB,IAAAqmB,EAAArmB,GACA0a,IAAA7a,KACAA,EAAA6a,GAAA,EACAzL,GAAA,EAEA,OAAAA,IAIAf,EAAAe,MAAAxI,IAAA,SAAA4f,EAAAznB,GACAA,EAAA+H,EAAA2f,EAAA1nB,EACA,IAAA8b,GAAA1a,EAAAP,EAAAgH,IACA,KAAAzG,EAAA,EAAAP,EAAA4mB,EAAAhmB,OAAAZ,EAAAO,IAAAA,EACA0a,EAAA9b,EAAAA,EAAAynB,EAAArmB,IAAAqmB,EAAArmB,GACAyG,EAAAiU,GAAAA,IAAAjU,GAAAA,EAAAiU,GAAA,EAAA,CAEA,OAAAjU,IAIAyH,EAAA4Z,OAAA,SAAAzB,EAAAznB,GAGA,MAFAA,KAAAynB,EAAAA,EAAA5f,IAAAE,EAAA2f,EAAA1nB,KACAynB,EAAAA,EAAApf,OAAAN,EAAA6f,SAAAniB,KAAAsC,EAAAmd,KACA5V,EAAA6Z,SAAA1B,EAAA,KAIAnY,EAAA8Z,SAAA,SAAA3B,EAAAznB,GACAA,IAAAynB,EAAAA,EAAA5f,IAAAE,EAAA2f,EAAA1nB,KACAynB,EAAAA,EAAApf,OAAAN,EAAA6f,SAAAniB,KAAAsC,EAAAmd,IACA,IAAAmE,GAAA/Z,EAAA6Z,QACA,QAAAE,EAAA5B,EAAA,KAAA4B,EAAA5B,EAAA,IAAA4B,EAAA5B,EAAA,OAKAnY,EAAA6Z,SAAA,SAAA1B,EAAAznB,EAAAyZ,GACAvW,SAAAuW,IAAAA,EAAAzZ,EAAAA,EAAA+H,EAAAuhB,UACAtpB,EAAA+H,EAAA2f,EAAA1nB,EACA,IAAAupB,IAAA9B,EAAAhmB,OAAA,GAAAgY,EAAA,EACA+P,EAAAlnB,KAAA+a,MAAAkM,GACAzN,GAAA9b,EAAAynB,EAAA+B,EAAA,IACA7oB,EAAA4oB,EAAAC,CACA,OAAA7oB,GAAAmb,EAAAnb,GAAAX,EAAAynB,EAAA+B,IAAA1N,GAAAA,GAIAxM,EAAA/I,IAAA,SAAAkhB,EAAAznB,GACAA,EAAA+H,EAAA2f,EAAA1nB,EACA,KAAA,GAAA8b,GAAAvV,EAAA,EAAAnF,EAAA,EAAAP,EAAA4mB,EAAAhmB,OAAAZ,EAAAO,IAAAA,EACA0a,EAAA9b,EAAAA,EAAAynB,EAAArmB,IAAAqmB,EAAArmB,GACA2G,EAAA6f,QAAA9L,KAAAvV,GAAAuV,EAEA,OAAAvV,IAIA+I,EAAA8I,KAAA,SAAAqP,EAAAznB,GACAA,EAAA+H,EAAA2f,EAAA1nB,EACA,IAAAypB,GAAAroB,EAAAP,EAAAmI,EAAA8S,EAAA1D,EAAA,CACA,KAAAhX,EAAA,EAAA4H,EAAA,EAAAnI,EAAA4mB,EAAAhmB,OAAAZ,EAAAO,IAAAA,EACA0a,EAAA9b,EAAAA,EAAAynB,EAAArmB,IAAAqmB,EAAArmB,GACA2G,EAAA6f,QAAA9L,KACA2N,EAAA3N,EAAA1D,EACAA,GAAAqR,IAAAzgB,EAGA,OAAAoP,IAIA9I,EAAAoa,SAAA,SAAAjC,EAAAznB,GAEA,GADAA,EAAA+H,EAAA2f,EAAA1nB,IACA+H,EAAAqT,QAAAqM,IAAAA,EAAAhmB,OAAA,EAAA,MAAA,EACA,IAAAgoB,GAAAroB,EAAA4H,EAAA8S,EAAA1D,EAAA,EAAAuR,EAAA,CACA,KAAAvoB,EAAA,EAAA4H,EAAA,EAAA5H,EAAAqmB,EAAAhmB,SAAAL,EACA0a,EAAA9b,EAAAA,EAAAynB,EAAArmB,IAAAqmB,EAAArmB,GACA2G,EAAA6f,QAAA9L,KACA2N,EAAA3N,EAAA1D,EACAA,GAAAqR,IAAAzgB,EACA2gB,GAAAF,GAAA3N,EAAA1D,GAIA,OADAuR,IAAA3gB,EAAA,GAKAsG,EAAA6I,MAAA,SAAAsP,EAAAznB,GACA,MAAAsC,MAAAE,KAAA8M,EAAAoa,SAAAjC,EAAAznB,KAIAsP,EAAAsa,SAAA,SAAAnC,EAAAznB,GACA,GAAA6pB,GAAAva,EAAA8I,KAAAqP,EAAAznB,GACA8pB,EAAAxa,EAAA4Z,OAAAzB,EAAAznB,GACA+pB,EAAAza,EAAA6I,MAAAsP,EAAAznB,EACA,OAAA,KAAA+pB,EAAA,GAAAF,EAAAC,GAAAC,GAIAza,EAAAhL,IAAA,SAAAmjB,EAAAznB,GACA,MAAAsP,GAAA0a,OAAAvC,EAAAznB,GAAA,IAIAsP,EAAA3M,IAAA,SAAA8kB,EAAAznB,GACA,MAAAsP,GAAA0a,OAAAvC,EAAAznB,GAAA,IAIAsP,EAAA0a,OAAA,SAAAvC,EAAAznB,GACAA,EAAA+H,EAAA2f,EAAA1nB,EACA,IAAAkB,GAAA4H,EAAAgT,EAAA1a,EAAAP,EAAA4mB,EAAAhmB,MACA,KAAAL,EAAA,EAAAP,EAAAO,IAAAA,EAEA,GADA0a,EAAA9b,EAAAA,EAAAynB,EAAArmB,IAAAqmB,EAAArmB,GACA2G,EAAA6f,QAAA9L,GAAA,CAAA5a,EAAA4H,EAAAgT,CAAA,OAEA,KAAAjb,EAAAO,IAAAA,EACA0a,EAAA9b,EAAAA,EAAAynB,EAAArmB,IAAAqmB,EAAArmB,GACA2G,EAAA6f,QAAA9L,KACA5a,EAAA4a,IAAA5a,EAAA4a,GACAA,EAAAhT,IAAAA,EAAAgT,GAGA,QAAA5a,EAAA4H,IAIAwG,EAAA0a,OAAApmB,MAAA,SAAA6jB,EAAAznB,GACAA,EAAA+H,EAAA2f,EAAA1nB,EACA,IAAAkB,GAAA4H,EAAAgT,EAAA1a,EAAAyH,EAAA,GAAA+J,EAAA,GAAA/R,EAAA4mB,EAAAhmB,MACA,KAAAL,EAAA,EAAAP,EAAAO,IAAAA,EAEA,GADA0a,EAAA9b,EAAAA,EAAAynB,EAAArmB,IAAAqmB,EAAArmB,GACA2G,EAAA6f,QAAA9L,GAAA,CAAA5a,EAAA4H,EAAAgT,EAAAjT,EAAA+J,EAAAxR,CAAA,OAEA,KAAAP,EAAAO,IAAAA,EACA0a,EAAA9b,EAAAA,EAAAynB,EAAArmB,IAAAqmB,EAAArmB,GACA2G,EAAA6f,QAAA9L,KACA5a,EAAA4a,IAAA5a,EAAA4a,EAAAjT,EAAAzH,GACA0a,EAAAhT,IAAAA,EAAAgT,EAAAlJ,EAAAxR,GAGA,QAAAyH,EAAA+J,IAIAtD,EAAA2a,IAAA,SAAAxC,EAAAvmB,EAAA4H,GACA,GAAA1H,GAAA0a,EAAAvV,EAAA,CACA,IAAAuC,EAWA,IAFA5H,EAAA6G,EAAA2f,EAAAxmB,GACA4H,EAAAf,EAAA2f,EAAA5e,GACA1H,EAAA,EAAAA,EAAAqmB,EAAAhmB,SAAAL,EACA0a,EAAA5a,EAAAumB,EAAArmB,IAAA0H,EAAA2e,EAAArmB,IACA0a,IAAAA,IAAAvV,GAAAuV,OAbA,CACA,GAAA2L,EAAAhmB,SAAAP,EAAAO,OACA,KAAAJ,OAAA,4BAEA,KAAAD,EAAA,EAAAA,EAAAqmB,EAAAhmB,SAAAL,EACA0a,EAAA2L,EAAArmB,GAAAF,EAAAE,GACA0a,IAAAA,IAAAvV,GAAAuV,GAUA,MAAAvV,IAKA+I,EAAArL,KAAA,SAAAwjB,EAAAvmB,EAAA4H,EAAAie,GACA,GAKAhe,GAAA3H,EALApB,EAAA+H,EAAAmiB,WAAAphB,IAAAf,EAAA4f,SAAA7e,GACAwC,EAAAmc,EACAlc,EAAAvL,EAAAynB,EAAAvmB,EACAP,EAAAX,EAAA+mB,EAAAje,EACAqhB,EAAA,IAAAxpB,GAAA,MAAAA,EACAE,EAAA4mB,EAAAhmB,OAAAV,EAAA,CAKA,KAJAf,IACAkB,EAAA6G,EAAA2f,EAAAxmB,GACA4H,EAAAf,EAAA2f,EAAA5e,IAEA1H,EAAA,EAAAP,EAAAO,IAAAA,EACA2H,EAAA/I,EAAAkB,EAAAoK,EAAAlK,IAAA0H,EAAAyC,EAAAnK,IAAAkK,EAAAlK,GAAAmK,EAAAnK,GACAL,GAAAopB,EAAAphB,EAAAA,EAAAzG,KAAAC,IAAAD,KAAAI,IAAAqG,GAAApI,EAEA,OAAAwpB,GAAA7nB,KAAAE,KAAAzB,GAAAuB,KAAAC,IAAAxB,EAAA,EAAAJ,IAIA2O,EAAA8a,QAAA,SAAA3C,EAAAvmB,EAAA4H,GACA,GAAAwC,GAAAxC,EAAA2e,EAAA5f,IAAAE,EAAA2f,EAAAxmB,IAAAumB,EACAlc,EAAAzC,EAAA2e,EAAA5f,IAAAE,EAAA2f,EAAA5e,IAAA5H,EACAmpB,EAAA/a,EAAA8I,KAAA9M,GACAgf,EAAAhb,EAAA8I,KAAA7M,GACAgf,EAAAjb,EAAAe,MAAA0Y,MAAAzd,GACAkf,EAAAlb,EAAAe,MAAA0Y,MAAAxd,EAEA,IAAA,GAAAgf,EAAAC,EAAA,EAEA,MAAA,EAGA,IAAAjjB,GAAA+H,EAAAoa,SAAApe,GACA5D,EAAA4H,EAAAoa,SAAAne,GACAxK,EAAAuB,KAAAE,OAAA+nB,EAAA,GAAAhjB,GAAAijB,EAAA,GAAA9iB,IAAA6iB,EAAAC,EAAA,GAEA,OAAA,KAAAzpB,EAAA,GAAAspB,EAAAC,GAAAvpB,GAIAuO,EAAAmb,WAAA,SAAAhD,EAAAvmB,EAAA4H,GACA,GAKA1H,GAAAyH,EAAA+J,EAAA8X,EAAAC,EALArf,EAAAxC,EAAA2e,EAAA5f,IAAAE,EAAA2f,EAAAxmB,IAAAumB,EACAlc,EAAAzC,EAAA2e,EAAA5f,IAAAE,EAAA2f,EAAA5e,IAAA5H,EACAL,EAAAyK,EAAA7J,OACAmpB,EAAAtb,EAAA8I,KAAA9M,GACAuf,EAAAvb,EAAA8I,KAAA7M,GACAhF,EAAA,EAAAyC,EAAA,CAEA,IAAAnI,IAAA0K,EAAA9J,OACA,KAAAJ,OAAA,4BAGA,KAAAD,EAAA,EAAAP,EAAAO,IAAAA,EAGA,GAFAyH,EAAAyC,EAAAlK,GAAAspB,EAAA3iB,EAAA6f,QAAA/e,GACA+J,EAAArH,EAAAnK,GAAAupB,EAAA5iB,EAAA6f,QAAAhV,GACA8X,GAAAC,EACApkB,IAAAsC,EAAA+hB,IAAAhY,EAAAiY,KACA7hB,MACA,IAAA0hB,GAAAC,EACA,KAAAtpB,OAAA,2BAGA,OAAAkF,IAAAyC,EAAA,IAKAsG,EAAAjE,KAAA,SAAAoc,EAAAznB,GACAA,EAAA+H,EAAA2f,EAAA1nB,IAAA+H,EAAAuhB,QACA,IAOAloB,GAAA0a,EAAAgP,EAPA5pB,EAAAumB,EAAA5f,IAAA,SAAAiU,EAAA1a,GACA,OAAA2pB,IAAA3pB,EAAA8kB,IAAAlmB,EAAA8b,MAEArW,KAAAsC,EAAAijB,WAAA,QAEAnqB,EAAA4mB,EAAAhmB,OACAX,EAAAkF,MAAAnF,GACAoqB,EAAA,GAAAxR,IAEA,KAAArY,EAAA,EAAAP,EAAAO,IAAAA,EAAA,CAEA,GADA0a,EAAA5a,EAAAE,GAAA8kB,IACA,EAAA+E,GAAAxR,IAAAqC,EACAmP,EAAA7pB,EAAA,MACA,IAAA6pB,EAAA,IAAAxR,IAAAqC,EAAA,CAEA,IADAgP,EAAA,GAAA1pB,EAAA,EAAA6pB,GAAA,EACA7pB,EAAA6pB,IAAAA,EAAAnqB,EAAAI,EAAA+pB,GAAAF,KAAAD,CACAG,GAAA,GAEAnqB,EAAAI,EAAAE,GAAA2pB,KAAA3pB,EAAA,EACAqY,EAAAqC,EAGA,GAAAmP,EAAA,GAEA,IADAH,EAAA,GAAAjqB,EAAA,EAAAoqB,GAAA,EACApqB,EAAAoqB,IAAAA,EAAAnqB,EAAAI,EAAA+pB,GAAAF,KAAAD,CAGA,OAAAhqB,IAIAwO,EAAA4b,IAAA,SAAAzD,EAAAvmB,EAAA4H,GACA,GAAAqiB,GAAAriB,CACAA,GAAAqiB,EAAA1D,EAAA5f,IAAAE,EAAA2f,EAAA5e,IAAA5H,EACAA,EAAAiqB,EAAA1D,EAAA5f,IAAAE,EAAA2f,EAAAxmB,IAAAumB,CAEA,IAAAwC,GAAA3a,EAAA2a,IAAA/oB,EAAA4H,GACAsiB,EAAA9b,EAAA8I,KAAAlX,GACAmqB,EAAA/b,EAAA8I,KAAAtP,GACAwiB,EAAAhc,EAAA6I,MAAAjX,GACAqqB,EAAAjc,EAAA6I,MAAArP,GACAjI,EAAA4mB,EAAAhmB,MAEA,QAAAwoB,EAAAppB,EAAAuqB,EAAAC,KAAAxqB,EAAA,GAAAyqB,EAAAC,IAIAjc,EAAA4b,IAAA7f,KAAA,SAAAoc,EAAAvmB,EAAA4H,GACA,GAEA1H,GAAAL,EAAAgI,EAFAyiB,EAAA1iB,EAAAwG,EAAAjE,KAAAoc,EAAA1f,EAAA2f,EAAAxmB,IAAAoO,EAAAjE,KAAAoc,GACAgE,EAAA3iB,EAAAwG,EAAAjE,KAAAoc,EAAA1f,EAAA2f,EAAA5e,IAAAwG,EAAAjE,KAAAnK,GACAL,EAAA4mB,EAAAhmB,MAEA,KAAAL,EAAA,EAAAL,EAAA,EAAAF,EAAAO,IAAAA,EACA2H,EAAAyiB,EAAApqB,GAAAqqB,EAAArqB,GACAL,GAAAgI,EAAAA,CAGA,OAAA,GAAA,EAAAhI,GAAAF,GAAAA,EAAAA,EAAA,KAKAyO,EAAA4b,IAAAjnB,KAAA,SAAAwjB,EAAAvmB,EAAA4H,GACA,GAMA1H,GAAAsqB,EAAAC,EAAAC,EANAtgB,EAAAxC,EAAA2e,EAAA5f,IAAAE,EAAA2f,EAAAxmB,IAAAumB,EACAlc,EAAAzC,EAAA2e,EAAA5f,IAAAE,EAAA2f,EAAA5e,IAAA5H,EAEA2qB,EAAAvc,EAAArL,KAAA6nB,IAAAxgB,GACAygB,EAAAzc,EAAArL,KAAA6nB,IAAAvgB,GACA1K,EAAAgrB,EAAApqB,MAGA,KAAAL,EAAA,EAAAsqB,EAAA,EAAAC,EAAA,EAAAC,EAAA,EAAA/qB,EAAAO,IAAAA,EACAsqB,GAAAG,EAAAzqB,GAAAyqB,EAAAzqB,GACAuqB,GAAAI,EAAA3qB,GAAA2qB,EAAA3qB,GACAwqB,GAAAC,EAAAzqB,GAAA2qB,EAAA3qB,EAGA,OAAAkB,MAAAE,KAAAopB,EAAAtpB,KAAAE,KAAAkpB,EAAAC,KAMArc,EAAA0c,iBAAA,SAAAvE,EAAAvmB,EAAA4H,GACA,GASAmjB,GAAA7qB,EATAkK,EAAAxC,EAAA2e,EAAA5f,IAAAE,EAAA2f,EAAAxmB,IAAAumB,EACAlc,EAAAzC,EAAA2e,EAAA5f,IAAAE,EAAA2f,EAAA5e,IAAA5H,EACAL,EAAAyK,EAAA7J,OACAyqB,EAAA5c,EAAAmb,WAAAnf,EAAAC,GACA4gB,EAAA7c,EAAA6I,MAAA7M,GACA8gB,EAAA9c,EAAA6I,MAAA5M,GACA8gB,EAAAH,GAAAC,EAAAA,GACAG,EAAAhd,EAAA8I,KAAA7M,GAAA8gB,EAAA/c,EAAA8I,KAAA9M,GACAihB,GAAAF,MAAAA,EAAAG,UAAAF,EAAAG,EAAAP,GAAAC,EAAAC,GAAAM,IAAA,EAGA,KAAAtrB,EAAA,EAAAP,EAAAO,IAAAA,EACA2G,EAAA6f,QAAAtc,EAAAlK,KAAA2G,EAAA6f,QAAArc,EAAAnK,MACA6qB,EAAAI,EAAA/gB,EAAAlK,GAAAkrB,EAAA/gB,EAAAnK,GACAmrB,EAAAG,KAAAT,EAAAA,EAIA,OAAAM,IAIAjd,EAAA4X,KAIA5X,EAAA4X,EAAAtiB,GAAA,SAAA1D,EAAAyrB,GACA,GAAAzF,GAAAyF,EAAAvhB,EAAAzF,OAAAihB,OAAA,EAAA,GAAAH,KAAA,EAAAkG,EAAA,GAAA,KACA7B,EAAAxb,EAAA8I,KAAAlX,GACA0rB,EAAAtd,EAAA6I,MAAAjX,GAAAoB,KAAAE,KAAA8M,EAAAe,MAAA0Y,MAAA7nB,GACA,QAAA4pB,EAAA5D,EAAA0F,EAAA9B,EAAA5D,EAAA0F,IAOAtd,EAAA4X,EAAArJ,KAAA,SAAA3c,EAAA4H,GACA,GAAA+jB,GAAA/jB,EAAAA,EAAA,EACAgkB,EAAA1hB,EAAAzF,OAAAihB,OAAA,EAAA,GACAkE,EAAAxb,EAAA8I,KAAAlX,GACA0rB,EAAAtd,EAAA6I,MAAAjX,GAAAoB,KAAAE,KAAA8M,EAAAe,MAAA0Y,MAAA7nB,GAEA,IAAA,IAAA0rB,EAEA,MAAA9B,GAAA+B,IAAA,EAAA,EAAA,CAGA,IAAA3F,IAAA4D,EAAA+B,GAAAD,CACA,OAAA,GAAAE,EAAAtG,KAAAlkB,KAAAI,IAAAwkB,KAKA5X,EAAA4X,EAAA6F,WAAA,SAAAtF,EAAAvmB,EAAA4H,GACA,GAIA1H,GAJAkK,EAAAxC,EAAA2e,EAAA5f,IAAAE,EAAA2f,EAAAxmB,IAAAumB,EACAlc,EAAAzC,EAAA2e,EAAA5f,IAAAE,EAAA2f,EAAA5e,IAAA5H,EACAqpB,EAAAjb,EAAAe,MAAA/E,GACAkf,EAAAlb,EAAAe,MAAA9E,GACAyhB,EAAAhnB,OAEA,IAAAukB,IAAAC,EACA,KAAAnpB,OAAA,4BAEA,KAAAD,EAAA,EAAAmpB,EAAAnpB,IAAAA,EAEA2G,EAAA6f,QAAAtc,EAAAlK,KAAA2G,EAAA6f,QAAArc,EAAAnK,KACA4rB,EAAA5mB,KAAAkF,EAAAlK,GAAAmK,EAAAnK,GAGA,OAAAkO,GAAA4X,EAAArJ,KAAAmP,IAKA1d,EAAA4X,EAAA+F,cAAA,SAAAxF,EAAAvmB,EAAA4H,GACA,GAAAwC,GAAAxC,EAAA2e,EAAA5f,IAAAE,EAAA2f,EAAAxmB,IAAAumB,EACAlc,EAAAzC,EAAA2e,EAAA5f,IAAAE,EAAA2f,EAAA5e,IAAA5H,EACAqpB,EAAAjb,EAAAe,MAAA0Y,MAAAzd,GACAkf,EAAAlb,EAAAe,MAAA0Y,MAAAxd,GACAuhB,EAAA1hB,EAAAzF,OAAAihB,OAAA,EAAA,GACAsG,EAAA5d,EAAA8I,KAAA9M,GAAAgE,EAAA8I,KAAA7M,GACAqhB,EAAAtqB,KAAAE,KAAA8M,EAAAoa,SAAApe,GAAAif,EAAAjb,EAAAoa,SAAAne,GAAAif,EAEA,IAAA,IAAAoC,EAEA,MAAA,KAAAM,EAAA,EAAA,CAGA,IAAAhG,GAAAgG,EAAAN,CACA,OAAA,GAAAE,EAAAtG,KAAAlkB,KAAAI,IAAAwkB,KAIA5X,EAAArL,KAAA6nB,IAAA,SAAAxgB,GACA,GAIAwQ,GAAA1a,EAAA4C,EAJAnD,EAAAyK,EAAA7J,OACAwX,EAAApY,EAAAA,EACAgrB,EAAA7lB,MAAAiT,GACAwT,EAAArhB,EAAA+a,MAAAtlB,GACAiZ,EAAA,CAEA,KAAA1Y,EAAA,EAAAP,EAAAO,IAAAA,EAEA,IADAyqB,EAAAzqB,EAAAP,EAAAO,GAAA,EACA4C,EAAA5C,EAAA,EAAAP,EAAAmD,IAAAA,EACA6nB,EAAAzqB,EAAAP,EAAAmD,GAAA8X,EAAAxZ,KAAAI,IAAA4I,EAAAlK,GAAAkK,EAAAtH,IACA6nB,EAAA7nB,EAAAnD,EAAAO,GAAA0a,EACA2Q,EAAArrB,IAAA0a,EACA2Q,EAAAzoB,IAAA8X,CAIA,KAAA1a,EAAA,EAAAP,EAAAO,IAAAA,EACA0Y,GAAA2S,EAAArrB,GACAqrB,EAAArrB,IAAAP,CAIA,KAFAiZ,GAAAb,EAEA7X,EAAA,EAAAP,EAAAO,IAAAA,EACA,IAAA4C,EAAA5C,EAAAP,EAAAmD,IAAAA,EACA6nB,EAAAzqB,EAAAP,EAAAmD,IAAA8V,EAAA2S,EAAArrB,GAAAqrB,EAAAzoB,GACA6nB,EAAA7nB,EAAAnD,EAAAO,GAAAyqB,EAAAzqB,EAAAP,EAAAmD,EAIA,OAAA6nB,IAIAvc,EAAA6d,QAAA,SAAAC,EAAAptB,GACAA,EAAA+H,EAAA2f,EAAA1nB,EACA,IAAAoB,GAAAqY,EAAA1Y,EAAA,EAAAwoB,EAAA,EAAA1oB,EAAAusB,EAAA3rB,MACA,KAAAL,EAAA,EAAAP,EAAAO,IAAAA,EACAL,GAAAf,EAAAA,EAAAotB,EAAAhsB,IAAAgsB,EAAAhsB,EAEA,IAAA,IAAAL,EAAA,MAAA,EACA,KAAAK,EAAA,EAAAP,EAAAO,IAAAA,EACAqY,GAAAzZ,EAAAA,EAAAotB,EAAAhsB,IAAAgsB,EAAAhsB,IAAAL,EACA0Y,IAAA8P,GAAA9P,EAAAnX,KAAAmiB,IAAAhL,GAEA,QAAA8P,EAAAjnB,KAAA+qB,KAOA/d,EAAAge,OAAA,SAAA7F,EAAAvmB,EAAA4H,EAAAskB,GACA,GAOA3T,GAAA7Y,EAAAQ,EAPAyH,EAAAukB,EAAA3F,EAAA5f,IAAAE,EAAA2f,EAAAxmB,IAAAumB,EACA7U,EAAAwa,EAAA3F,EAAA5f,IAAAE,EAAA2f,EAAA5e,IAAA5H,EACAgmB,EAAAkG,EAAA3F,EAAA5f,IAAAE,EAAA2f,EAAA0F,IAAAtkB,EAEAykB,KACAC,KACA3sB,EAAAqmB,EAAAzlB,OACAV,EAAA,EAAA0sB,EAAA,EAAAlE,EAAA,CAEA,KAAAnoB,EAAA,EAAAP,EAAAO,IAAAA,EACAmsB,EAAA1kB,EAAAzH,IAAA,EACAosB,EAAA5a,EAAAxR,IAAA,CAGA,KAAAA,EAAA,EAAAP,EAAAO,IAAAA,EACAmsB,EAAA1kB,EAAAzH,KAAA8lB,EAAA9lB,GACAosB,EAAA5a,EAAAxR,KAAA8lB,EAAA9lB,GACAL,GAAAmmB,EAAA9lB,EAIA,KADAR,EAAA,GAAAG,EAAAuB,KAAA+qB,KACAjsB,EAAA,EAAAP,EAAAO,IAAAA,EACA,IAAA8lB,EAAA9lB,KACAqY,EAAA1Y,EAAAmmB,EAAA9lB,IAAAmsB,EAAA1kB,EAAAzH,IAAAosB,EAAA5a,EAAAxR,KACAqsB,GAAAvG,EAAA9lB,GAAAR,EAAA0B,KAAAmiB,IAAAhL,GACA8P,GAAArC,EAAA9lB,GAAAR,EAAA0B,KAAAmiB,IAAAyC,EAAA9lB,GAAAL,GAGA,QAAA0sB,EAAA,EAAAA,EAAAlE,IAIAja,EAAAge,OAAAI,KAAA,SAAAjG,EAAAvmB,EAAA4H,EAAAskB,GACA,MAAA9d,GAAAge,OAAA7F,EAAAvmB,EAAA4H,EAAAskB,GAAA,IAKA9d,EAAAge,OAAArpB,KAAA,SAAAwjB,EAAAvmB,EAAA4H,EAAAskB,GACA,MAAA9d,GAAAge,OAAA7F,EAAAvmB,EAAA4H,EAAAskB,GAAA,IAIA9d,EAAAqe,QAAA,SAAAlG,EAAAznB,GACA,GAQAypB,GAAAmE,EAAAxsB,EAAA0a,EAAAjT,EARAuP,EAAA,EACA2Q,EAAA,EACAC,EAAA,EACAC,EAAA,EACA3kB,EAAA,KACA3B,EAAA,KACAgnB,EAAA,EACAkE,KACA5sB,IAGA,KAAAG,EAAA,EAAAA,EAAAqmB,EAAAhmB,SAAAL,EACA0a,EAAA9b,EAAAA,EAAAynB,EAAArmB,IAAAqmB,EAAArmB,GAGAH,EAAA6a,GAAAA,IAAA7a,GAAAA,EAAA6a,GAAA,GAAAmN,GAAA,EAAA,GAEA,MAAAnN,IACAkN,EACAjhB,EAAA6f,QAAA9L,KAEAjT,EAAA,gBAAAiT,GAAAA,EAAAra,OAAAqa,GACA,OAAAxX,GAAAA,EAAAuE,KAAAvE,EAAAuE,IACA,OAAAlG,GAAAkG,EAAAlG,KAAAA,EAAAkG,GACA4gB,EAAA5gB,EAAAuP,EACAA,GAAAqR,IAAAV,EACAY,GAAAF,GAAA5gB,EAAAuP,GACAyV,EAAAznB,KAAAyC,GASA,OANA8gB,IAAAZ,EAAA,EACA6E,EAAAtrB,KAAAE,KAAAmnB,GAGAkE,EAAApoB,KAAAsC,EAAAmd,MAGA7Y,KAAAA,EAAAob,EAAAznB,GACA6oB,OAAA5nB,EACAoP,MAAAoX,EAAAhmB,OACAsnB,MAAAA,EACAC,QAAAA,EACAC,SAAAA,EACA3kB,IAAAA,EACA3B,IAAAA,EACAyV,KAAAA,EACAD,MAAAyV,EACA1E,OAAApN,EAAAxM,EAAA6Z,SAAA0E,EAAA,IACAC,GAAAxe,EAAA6Z,SAAA0E,EAAA,KACAE,GAAAze,EAAA6Z,SAAA0E,EAAA,KACAjE,SAAA,IAAAgE,EAAA,GAAAxV,EAAA0D,GAAA8R,IAKAte,EAAA0e,QAAA,SAAAlhB,EAAAmb,GACAA,EAAAA,GAAAlgB,EAAAoC,KAAA2C,EAAA,GACA,IAAA/L,GAAAknB,EAAApgB,IAAA,SAAA7H,GACA,GAAAyZ,GAAAnK,EAAAqe,QAAA7gB,EAAA/E,EAAA2f,EAAA1nB,GACA,OAAAyZ,GAAA7O,MAAA5K,EAAAyZ,GAEA,OAAA1Y,GAAAktB,aAAA,EAAAltB,GAGAb,EAAAD,QAAAqP,IvBiiFG4e,aAAa,GAAGC,gBAAgB,GAAGlf,SAAS,KAAKmf,IAAI,SAASjtB,EAAQjB,EAAOD,GwBnpGhF,QAAAkd,GAAApU,GACA,MAAAslB,GAAAvQ,SAAA/U,GAAAslB,EAIA,QAAAC,GAAAjiB,EAAA8Q,EAAA2H,EAAArH,EAAAnZ,EAAA3B,GACA,GAAAhC,IACA0L,KAAAA,EACA8Q,KAAAA,EACA2H,KAAAA,EASA,OAPArH,GACA9c,EAAA8c,KAAAA,EAEA9c,EAAAujB,QAAA,EAEA,MAAA5f,IAAA3D,EAAA2D,IAAAA,GACA,MAAA3B,IAAAhC,EAAAgC,IAAAA,GACAhC,EAGA,QAAAwb,GAAA9P,EAAAyY,EAAAP,EAAA9G,EAAAnZ,EAAA3B,GACA,MAAA2rB,GAAAjiB,EACA,SAAAtD,GAAA,MAAA+b,GAAAtH,OAAA+G,EAAAxb,IACA,SAAAA,GAAA,MAAA+b,GAAAzU,MAAAkU,EAAAxb,IACA0U,EAAAnZ,EAAA3B,GA2GA,QAAAkjB,GAAAN,EAAAZ,EAAAgB,EAAAtB,GACA,GAAAjjB,GAAAP,EAAAojB,EAAAxG,EAAA8Q,EAAA,EAEA,KAAAntB,EAAA,EAAAP,EAAA0tB,EAAA9sB,OAAAZ,EAAAO,IAAAA,EAEA,GADAqc,EAAA8Q,EAAAntB,GACAujB,EAAAlH,EAAA,GAAA,CAEA,GADAwG,EAAAU,EAAAlH,EAAA,GACAwG,EAAAI,EACA,MAAAkB,GAAAgJ,EAAAntB,EAAA,GAAA,GAEA,IAAA6iB,GAAA0B,EACA,MAAAJ,GAAA9H,EAAA,IAIA,MAAA8H,GAAAgJ,EAAA1tB,EAAA,GAAA,IAGA,QAAA2tB,GAAAjJ,GACA,GAAAnkB,GAAAP,EAAAgH,IACA,KAAAzG,EAAA,EAAAP,EAAA0kB,EAAA9jB,OAAAZ,EAAAO,IAAAA,EACAyG,EAAA0d,EAAAnkB,GAAAiL,MAAAkZ,EAAAnkB,EAKA,OAHAyG,GAAAge,KAAA,SAAAlB,EAAAgB,EAAAtB,GACA,MAAAwB,GAAAN,EAAAZ,EAAAgB,EAAAtB,IAEAxc,EApKA,GAAAiV,GAAA3b,EAAA,WAEAktB,EAAA,GAAAjR,MACAqR,EAAA,GAAArR,MAAA,EAAA,EAAA,GAAAkD,YAAA,GACAoO,EAAA,GAAAtR,MAAAA,KAAAuR,IAAA,EAAA,EAAA,IAAA9M,eAAA,GA8BA+M,GACAzS,EAAA,SAAAW,EAAAkC,OAAAyP,GACAtS,EAAA,SAAAW,EAAAqC,OAAAsP,GACAtS,EAAA,OAAAW,EAAAwC,KAAAmP,GACAtS,EAAA,MAAAW,EAAA2C,IAAAgP,GAAA,EAAA,IACAtS,EAAA,QAAAW,EAAAmD,MAAAwO,GAAA,EAAA,EAAA,IACAtS,EAAA,OAAAW,EAAAuD,KAAAoO,GAGAH,EAAA,UACA,SAAAvlB,GAAA,MAAA,IAAAqU,MAAA,KAAA,EAAA,EAAA,EAAA,EAAArU,IACA,SAAAA,GAAA,MAAAoU,GAAApU,GAAAmW,cACA,KAAA,EAAA,IAEAoP,EAAA,UACA,SAAAvlB,GAAA,MAAA,IAAAqU,MAAA,KAAA,EAAA,EAAA,EAAArU,IACA,SAAAA,GAAA,MAAAoU,GAAApU,GAAAsW,cACA,KAAA,EAAA,IAEAiP,EAAA,QACA,SAAAvlB,GAAA,MAAA,IAAAqU,MAAA,KAAA,EAAA,EAAArU,IACA,SAAAA,GAAA,MAAAoU,GAAApU,GAAAyW,YACA,KAAA,EAAA,IAEA8O,EAAA,WACA,SAAAvlB,GAAA,MAAA,IAAAqU,MAAA,KAAA,EAAA,EAAArU,IACA,SAAAA,GAAA,MAAAoU,GAAApU,GAAAyV,WACA,GAAA,EAAA,GAEA8P,EAAA,QACA,SAAAvlB,GAAA,MAAA,IAAAqU,MAAA,KAAA,EAAArU,IACA,SAAAA,GAAA,MAAAoU,GAAApU,GAAAwV,YACA,GAAA,EAAA,IAEA+P,EAAA,SACA,SAAAvlB,GAAA,MAAA,IAAAqU,MAAA,KAAArU,EAAA,GAAA,IACA,SAAAA,GAAA,MAAAoU,GAAApU,GAAAoX,aACA,GAAA,EAAA,KAIAqF,GACArJ,EAAA,SAAAW,EAAAyD,UAAAmO,GACAvS,EAAA,SAAAW,EAAA4D,UAAAgO,GACAvS,EAAA,OAAAW,EAAA+D,QAAA6N,GACAvS,EAAA,MAAAW,EAAAkE,OAAA0N,GAAA,EAAA,IACAvS,EAAA,QAAAW,EAAA0E,SAAAkN,GAAA,EAAA,EAAA,IACAvS,EAAA,OAAAW,EAAA8E,QAAA8M,GAGAJ,EAAA,UACA,SAAAvlB,GAAA,MAAA,IAAAqU,MAAAA,KAAAuR,IAAA,KAAA,EAAA,EAAA,EAAA,EAAA5lB,KACA,SAAAA,GAAA,MAAAoU,GAAApU,GAAA0X,iBACA,KAAA,EAAA,IAEA6N,EAAA,UACA,SAAAvlB,GAAA,MAAA,IAAAqU,MAAAA,KAAAuR,IAAA,KAAA,EAAA,EAAA,EAAA5lB,KACA,SAAAA,GAAA,MAAAoU,GAAApU,GAAA6X,iBACA,KAAA,EAAA,IAEA0N,EAAA,QACA,SAAAvlB,GAAA,MAAA,IAAAqU,MAAAA,KAAAuR,IAAA,KAAA,EAAA,EAAA5lB,KACA,SAAAA,GAAA,MAAAoU,GAAApU,GAAAgY,eACA,KAAA,EAAA,IAEAuN,EAAA,WACA,SAAAvlB,GAAA,MAAA,IAAAqU,MAAAA,KAAAuR,IAAA,KAAA,EAAA,EAAA5lB,KACA,SAAAA,GAAA,MAAAoU,GAAApU,GAAA+V,cACA,GAAA,EAAA,GAEAwP,EAAA,QACA,SAAAvlB,GAAA,MAAA,IAAAqU,MAAAA,KAAAuR,IAAA,KAAA,EAAA5lB,KACA,SAAAA,GAAA,MAAAoU,GAAApU,GAAA8V,eACA,GAAA,EAAA,IAEAyP,EAAA,SACA,SAAAvlB,GAAA,MAAA,IAAAqU,MAAAA,KAAAuR,IAAA,KAAA5lB,EAAA,GAAA,KACA,SAAAA,GAAA,MAAAoU,GAAApU,GAAA2Y,gBACA,GAAA,EAAA,KAIA6M,IACA,QAAA,IACA,OAAA,IACA,OAAA,IACA,QAAA,IACA,OAAA,IACA,OAAA,IACA,MAAA,IACA,MAAA,IACA,MAAA,IACA,MAAA,IACA,KAAA,IACA,KAAA,IACA,IAAA,IACA,IAAA,IACA,IAAA,IACA,IAAA,IACA,KAAA,IACA,IAAA,IACA,IAAA,GAgCAruB,GAAAD,QAAAuuB,EAAAI,GACA1uB,EAAAD,QAAAulB,IAAAgJ,EAAAhJ,KxB4pGGqJ,UAAU,KAAKC,IAAI,SAAS3tB,EAAQjB,EAAOD,GyB9rG9C,QAAA8uB,GAAAlmB,GACA,MAAAA,GAAAmmB,QAAAC,EAAA,SAiJA,QAAAC,GAAAruB,EAAAsuB,GACA,GAAA/tB,GAAAL,EAAA,EACA,KAAAK,EAAA,EAAAP,EAAAO,IAAAA,EAAAL,GAAAouB,CACA,OAAApuB,GAsBA,QAAAquB,GAAAruB,EAAAwI,EAAA8lB,GACA,GAAAC,GAAA,EAAAC,EAAAxuB,EAAAyuB,MAAAC,EAQA,OANA1uB,GADAsuB,GACAE,EAAAA,EAAAG,WACArnB,OAAA,SAAAsnB,GAAA,MAAAL,IAAAK,EAAAluB,OAAA8H,GAAA+lB,IACAI,UAEAH,EAAAlnB,OAAA,SAAAsnB,GAAA,MAAAL,IAAAK,EAAAluB,OAAA8H,GAAA+lB,IAEAvuB,EAAAU,OAAAV,EAAA4O,KAAA,IAAAigB,OAAAL,EAAA,GAAA/pB,MAAA,EAAA+D,GA1TA,GAAAsmB,GAAA1uB,EAAA,UACAmkB,EAAAnkB,EAAA,UACAqkB,EAAAF,EAAAE,IAEAvkB,EAAAf,EAAAD,WAIA6vB,EAAA,UAEA7uB,GAAA8uB,UAAA,SAAAC,EAAAhwB,GAAA,MAAAA,GAAA8vB,GAAAE,EAAAhwB,GAEAiB,EAAA+uB,KAAA,SAAAhwB,GAAA,MAAA,OAAAA,EAAA,KAAAA,EAAA8vB,IAEA7uB,EAAAqoB,SAAA,SAAAzgB,GAAA,MAAAA,IAEA5H,EAAAA,QAAAA,EAAA8uB,UAAA,OAAA,WAAA,OAAA,IAEA9uB,EAAAA,SAAAA,EAAA8uB,UAAA,QAAA,WAAA,OAAA,IAEA9uB,EAAA+J,UAAA,SAAAqQ,GACA,MAAA5U,MAAAI,MAAAJ,KAAAC,UAAA2U,KAGApa,EAAAgvB,MAAA,SAAA/uB,EAAA4H,GACA,MAAArC,MAAAC,UAAAxF,KAAAuF,KAAAC,UAAAoC,IAGA7H,EAAA+Q,OAAA,SAAAqJ,GACA,IAAA,GAAAxS,GAAAmnB,EAAA5uB,EAAA,EAAAmI,EAAA6c,UAAA3kB,OAAA8H,EAAAnI,IAAAA,EAAA,CACAyH,EAAAud,UAAAhlB,EACA,KAAA4uB,IAAAnnB,GAAAwS,EAAA2U,GAAAnnB,EAAAmnB,GAEA,MAAA3U,IAGApa,EAAAQ,OAAA,SAAAoH,GACA,MAAA,OAAAA,GAAA,MAAAA,EAAApH,OAAAoH,EAAApH,OAAA,MAGAR,EAAAkJ,KAAA,SAAAtB,GACA,GAAAtD,GAAA4E,IACA,KAAA5E,IAAAsD,GAAAsB,EAAA/D,KAAAb,EACA,OAAA4E,IAGAlJ,EAAA4sB,KAAA,SAAAhlB,GACA,GAAAtD,GAAAsoB,IACA,KAAAtoB,IAAAsD,GAAAglB,EAAAznB,KAAAyC,EAAAtD,GACA,OAAAsoB,IAGA5sB,EAAAivB,MAAA,SAAAlY,EAAAhY,GACA,OAAAA,EAAAiB,EAAAymB,EAAA1nB,IACAgY,EAAA5O,OAAA,SAAAiS,EAAAxS,GAAA,MAAAwS,GAAArb,EAAA6I,IAAA,EAAAwS,OACArD,EAAA5O,OAAA,SAAAiS,EAAAxS,GAAA,MAAAwS,GAAAxS,GAAA,EAAAwS,QAGApa,EAAAkvB,OAAA,SAAA1I,GAEA,GAAA5mB,GAAA4mB,EAAAhmB,MACA,KAAAZ,EAAA,MAAA,EACA,KAAA,GAAAE,GAAAqvB,OAAA3I,EAAA,IAAArmB,EAAA,EAAAP,EAAAO,IAAAA,EACAL,GAAA,IAAAqvB,OAAA3I,EAAArmB,GAEA,OAAAL,GAKA,IAAAua,GAAAY,OAAA9Y,UAAAkY,QAEAra,GAAAovB,SAAA,SAAAhV,GACA,MAAAA,KAAAa,OAAAb,IAGApa,EAAAipB,WAAA,SAAA7O,GACA,MAAA,sBAAAC,EAAA9Z,KAAA6Z,IAGApa,EAAA0mB,SAAA,SAAAtM,GACA,MAAA,gBAAAxX,QAAA,oBAAAyX,EAAA9Z,KAAA6Z,IAGApa,EAAAma,QAAApV,MAAAoV,SAAA,SAAAC,GACA,MAAA,mBAAAC,EAAA9Z,KAAA6Z,IAGApa,EAAA6mB,SAAA,SAAAzM,GACA,MAAA,gBAAAA,IAAA,oBAAAC,EAAA9Z,KAAA6Z,IAGApa,EAAA8mB,UAAA,SAAA1M,GACA,MAAAA,MAAA,GAAAA,KAAA,GAAA,oBAAAC,EAAA9Z,KAAA6Z,IAGApa,EAAA4mB,OAAA,SAAAxM,GACA,MAAA,kBAAAC,EAAA9Z,KAAA6Z,IAGApa,EAAA2mB,QAAA,SAAAvM,GACA,MAAA,OAAAA,GAAAA,IAAAA,GAGApa,EAAAqvB,SAAAT,EAAAU,QAAAV,EAAAU,OAAAD,UAAArvB,EAAAA,SAIAA,EAAAsnB,OAAA,SAAAxnB,GACA,MAAA,OAAAA,GAAA,KAAAA,EAAA,MAAAA,GAGAE,EAAAA,WAAA,SAAAF,GACA,MAAA,OAAAA,GAAA,KAAAA,EAAA,KAAA,UAAAA,GAAA,IAAAA,GAIAE,EAAAkc,KAAA,SAAApc,EAAAyvB,GACA,GAAAznB,GAAAynB,EAAAA,EAAApT,IACA,OAAA,OAAArc,GAAA,KAAAA,EAAA,KAAAgI,EAAAlC,MAAA9F,IAGAE,EAAAua,MAAA,SAAA3S,GACA,MAAA,OAAAA,EAAA5H,EAAAma,QAAAvS,GAAAA,GAAAA,OAGA5H,EAAAkuB,IAAA,SAAAtmB,GACA,MAAA5H,GAAAma,QAAAvS,GAAA,IAAAA,EAAAhB,IAAA5G,EAAAkuB,KAAA,IACAluB,EAAAovB,SAAAxnB,GAAApC,KAAAC,UAAAmC,GACA5H,EAAA0mB,SAAA9e,GAAA,IAAAkmB,EAAAlmB,GAAA,IAAAA,EAGA,IAAAomB,GAAA,cAQAwB,EAAA,oBAEAxvB,GAAA2J,MAAA,SAAA5K,GACA,MAAAowB,QAAApwB,GAAA0wB,MAAAD,GAAA5oB,IAAA,SAAAkB,GACA,MAAA,MAAAA,EAAA,GAAAA,EACA,MAAAA,EAAA,IAAA,MAAAA,EAAA,GAAAA,EAAAvD,MAAA,EAAA,IACAuD,EAAAvD,MAAA,EAAA,IAAAwpB,QAAA,YAAA,SAIA/tB,EAAA0vB,SAAA,SAAA3wB,GACA,GAAAe,EACA,OAAA,OAAAf,GAAAiB,EAAAipB,WAAAlqB,GAAAA,EACAiB,EAAA8uB,UAAA/vB,GAAAe,EAAAE,EAAA2J,MAAA5K,IAAAyB,OAAA,EACA,SAAAoH,GAAA,MAAA9H,GAAAqI,OAAA,SAAAP,EAAA7I,GAAA,MAAA6I,GAAA7I,IAAA6I,IACA,SAAAA,GAAA,MAAAA,GAAA7I,MAKAiB,EAAAymB,EAAAzmB,EAAA0vB,SAEA1vB,EAAA2vB,QAAA,SAAA5wB,GACA,GAAAe,EACA,OAAAE,GAAA0mB,SAAA3nB,KAAAe,EAAAE,EAAA2J,MAAA5K,IAAAyB,OAAA,EACA,SAAAoH,EAAAiT,GACA,IAAA,GAAA1a,GAAA,EAAAA,EAAAL,EAAAU,OAAA,IAAAL,EAAAyH,EAAAA,EAAA9H,EAAAK,GACAyH,GAAA9H,EAAAK,IAAA0a,GAEA,SAAAjT,EAAAiT,GAAAjT,EAAA7I,GAAA8b,IAIA7a,EAAA4vB,MAAA,SAAAb,EAAAc,GACA,MAAA,UAAA9wB,GACAA,EAAAiB,EAAAymB,EAAA1nB,IAAAiB,EAAAqoB,QACA,IAAAzoB,GAAAmvB,GAAA/uB,EAAA+uB,KAAAhwB,GAAA,IAAAiB,EAAA+uB,KAAAhwB,GAAA,GACA,OAAAiB,GAAA8uB,UAAAlvB,EAAA,SAAAkI,GAAA,MAAA+nB,GAAA9wB,EAAA+I,QAIA9H,EAAA8vB,OAAA9vB,EAAA4vB,MAAA,QAAA5vB,EAAA2mB,SACA3mB,EAAA+vB,QAAA/vB,EAAA4vB,MAAA,SAAA5vB,EAAAQ,QAEAR,EAAAgwB,IAAA,SAAAjxB,EAAAynB,GACAznB,EAAAiB,EAAAymB,EAAA1nB,EACA,IAAA6H,GAAA5G,EAAAma,QAAAqM,GAAAxmB,EAAAivB,MAAAzI,GAAAA,CACA,OAAA,UAAA1e,GAAA,QAAAlB,EAAA7H,EAAA+I,MAGA9H,EAAAiwB,MAAAjwB,EAAA4vB,MAAA,OAAAvL,EAAAjF,KAAAyE,MACA7jB,EAAAkwB,OAAAlwB,EAAA4vB,MAAA,QAAAvL,EAAA3C,OAAAmC,MACA7jB,EAAAmwB,MAAAnwB,EAAA4vB,MAAA,OAAAvL,EAAA+L,MAAAvM,MACA7jB,EAAAqwB,KAAArwB,EAAA4vB,MAAA,MAAAvL,EAAAiM,SAAAzM,MACA7jB,EAAAuwB,MAAAvwB,EAAA4vB,MAAA,OAAAvL,EAAArD,MAAA6C,MACA7jB,EAAAwwB,QAAAxwB,EAAA4vB,MAAA,SAAAvL,EAAAtD,QAAA8C,MACA7jB,EAAAywB,QAAAzwB,EAAA4vB,MAAA,SAAAvL,EAAAvD,QAAA+C,MAEA7jB,EAAA0wB,SAAA1wB,EAAA4vB,MAAA,UAAArL,EAAAnF,KAAAyE,MACA7jB,EAAA2wB,UAAA3wB,EAAA4vB,MAAA,WAAArL,EAAA7C,OAAAmC,MACA7jB,EAAA4wB,SAAA5wB,EAAA4vB,MAAA,UAAArL,EAAA6L,MAAAvM,MACA7jB,EAAA6wB,QAAA7wB,EAAA4vB,MAAA,SAAArL,EAAA+L,SAAAzM,MACA7jB,EAAA8wB,SAAA9wB,EAAA4vB,MAAA,UAAArL,EAAAvD,MAAA6C,MACA7jB,EAAA+wB,WAAA/wB,EAAA4vB,MAAA,YAAArL,EAAAxD,QAAA8C,MACA7jB,EAAAgxB,WAAAhxB,EAAA4vB,MAAA,YAAArL,EAAAzD,QAAA+C,MAIA7jB,EAAA+pB,WAAA,SAAAvlB,GACA,GAAAysB,KASA,OARAhvB,UAAAuC,IAAAA,MACAA,EAAAxE,EAAAua,MAAA/V,GAAAoC,IAAA,SAAA7H,GACA,GAAAe,GAAA,CAIA,OAHA,MAAAf,EAAA,IAAAe,EAAA,GAAAf,EAAAA,EAAAwF,MAAA,IACA,MAAAxF,EAAA,KAAAe,EAAA,EAAAf,EAAAA,EAAAwF,MAAA,IACA0sB,EAAA9rB,KAAArF,GACAE,EAAA0vB,SAAA3wB,KAEA,SAAAkB,EAAA4H,GACA,GAAA1H,GAAAP,EAAAb,EAAA6I,EAAA+J,CACA,KAAAxR,EAAA,EAAAP,EAAA4E,EAAAhE,OAAAZ,EAAAO,IAAAA,EAAA,CAEA,GADApB,EAAAyF,EAAArE,GAAAyH,EAAA7I,EAAAkB,GAAA0R,EAAA5S,EAAA8I,GACA8J,EAAA/J,EAAA,MAAA,GAAAqpB,EAAA9wB,EACA,IAAAyH,EAAA+J,EAAA,MAAAsf,GAAA9wB,GAEA,MAAA,KAIAH,EAAAikB,IAAA,SAAAhkB,EAAA4H,GACA,MAAAA,GAAA5H,EACA,GACAA,EAAA4H,EACA,EACA5H,GAAA4H,EACA,EACA,OAAA5H,EACA,GACA,OAAA4H,EACA,EAEA4d,KAGAzlB,EAAAkxB,OAAA,SAAAjxB,EAAA4H,GAAA,MAAA5H,GAAA4H,GAEA7H,EAAAmxB,WAAA,SAAA5W,EAAA6W,EAAAC,GACA,GAAAxb,GAAA0E,EAAApS,OAAA,SAAA2hB,EAAAjP,EAAA1a,GACA,MAAA2pB,GAAAuH,EAAAxW,IAAA1a,EAAA2pB,MAUA,OAPAvP,GAAA/V,KAAA,SAAAvE,EAAA4H,GACA,GAAAypB,GAAAF,EAAAnxB,GACAsxB,EAAAH,EAAAvpB,EACA,OAAA0pB,GAAAD,EAAA,GAAAA,EAAAC,EAAA,EACA1b,EAAAwb,EAAApxB,IAAA4V,EAAAwb,EAAAxpB,MAGA0S,GAMAva,EAAAwxB,IAAA,SAAA1xB,EAAAU,EAAAyY,EAAAwY,GACAA,EAAAA,GAAA,GACA,IAAA3pB,GAAAtH,EAAAV,EAAAU,MACA,IAAA,GAAAsH,EAAA,MAAAhI,EACA,QAAAmZ,GACA,IAAA,OACA,MAAAgV,GAAAnmB,EAAA2pB,GAAA3xB,CACA,KAAA,SACA,IAAA,SACA,MAAAmuB,GAAA5sB,KAAA+a,MAAAtU,EAAA,GAAA2pB,GACA3xB,EAAAmuB,EAAA5sB,KAAAwD,KAAAiD,EAAA,GAAA2pB,EACA,SACA,MAAA3xB,GAAAmuB,EAAAnmB,EAAA2pB,KAUAzxB,EAAA0xB,SAAA,SAAA5xB,EAAAU,EAAAyY,EAAA0Y,EAAAC,GACA,GAAAtpB,GAAAxI,EAAAU,MACA,IAAAA,GAAA8H,EAAA,MAAAxI,EACA8xB,GAAA3vB,SAAA2vB,EAAAzC,OAAAyC,GAAA,GACA,IAAAtxB,GAAAe,KAAAK,IAAA,EAAAlB,EAAAoxB,EAAApxB,OAEA,QAAAyY,GACA,IAAA,OACA,MAAA2Y,IAAAD,EAAAxD,EAAAruB,EAAAQ,EAAA,GAAAR,EAAAyE,MAAA+D,EAAAhI,GACA,KAAA,SACA,IAAA,SACA,GAAAuxB,GAAAxwB,KAAAwD,KAAAvE,EAAA,GAAAwxB,EAAAzwB,KAAA+a,MAAA9b,EAAA,EACA,QAAAqxB,EAAAxD,EAAAruB,EAAA+xB,GAAA/xB,EAAAyE,MAAA,EAAAstB,IACAD,GAAAD,EAAAxD,EAAAruB,EAAAgyB,EAAA,GAAAhyB,EAAAyE,MAAA+D,EAAAwpB,GACA,SACA,OAAAH,EAAAxD,EAAAruB,EAAAQ,GAAAR,EAAAyE,MAAA,EAAAjE,IAAAsxB,GAgBA,IAAApD,GAAA,qKzBu0GGuD,SAAS,GAAGnD,OAAS,IAAIoD,IAAI,SAAS9xB,EAAQjB,EAAOD,G0BpoHxDA,EAAAizB,eACA,SAAA,QAAA,QAAA,UAAA,WACA,MAAA,OAAA,UAAA,WAAA,YAAA,QACA,SAAA,SAAA,KAAA,KAAA,WAAA,MAAA,MACA,SAAA,UAEAjzB,EAAAkzB,mBACA,OAAA,UAAA,QAAA,SAAA,SAAA,KAAA,KAAA,MAAA,Y1BwoHMC,IAAI,SAASjyB,EAAQjB,EAAOD,G2B/oHlCA,EAAAozB,gBAAA,Q3BkpHMC,IAAI,SAASnyB,EAAQjB,EAAOD,G4B3nHlC,QAAAszB,GAAAjpB,EAAAW,GACA,QAAAuoB,EAAAlpB,GAAAW,GAGA,QAAAuoB,GAAAlpB,GACA,OAAAA,GACA,IAAArK,GAAAqL,EACA,IAAArL,GAAAsL,EACA,OACA1F,OAAA,EAAAyQ,MAAA,EAAAqD,QAAA,EAAAC,QAAA,EACAzD,KAAA,EAAAC,MAAA,EAAAC,MAAA,EAEA,KAAApW,GAAAuL,IACA,IAAAvL,GAAAwzB,OACA,OACA5tB,OAAA,EAAAyQ,MAAA,EAAAqD,QAAA,EAAAC,QAAA,EACAzD,KAAA,EAAAC,MAAA,EAAAC,MAAA,EAAAvD,MAAA,EAEA,KAAA7S,GAAAyL,KACA,OACA7F,OAAA,EAAAyQ,MAAA,EAAAqD,QAAA,EAAAC,QAAA,EACAzD,KAAA,EAAArD,MAAA,EAEA,KAAA7S,GAAA2L,MACA,IAAA3L,GAAA6L,OACA,OACAjG,OAAA,EAAAyQ,MAAA,EAAAqD,QAAA,EAAAC,QAAA,EACAzD,KAAA,EAAAC,MAAA,EAAAC,MAAA,EAAAvD,MAAA,EAEA,KAAA7S,GAAA0L,MACA,OAAA9F,OAAA,EACA,KAAA5F,GAAA4L,KACA,OAAAiH,MAAA,GAEA,SAIA,QAAA4gB,GAAAppB,GACA,OAAAA,GACA,IAAArK,GAAAqL,EACA,IAAArL,GAAAsL,EACA,IAAAtL,GAAA2L,MACA,OACAkI,SAAA,EACAD,WAAA,EAEA,KAAA5T,GAAAuL,IACA,IAAAvL,GAAAwzB,OACA,IAAAxzB,GAAA0L,MACA,IAAA1L,GAAA6L,OACA,OACAgI,SAAA,EACAD,WAAA,EAEA,KAAA5T,GAAAyL,KACA,IAAAzL,GAAA4L,KACA,OACAiI,SAAA,EACAD,WAAA,GAGA,KAAA,IAAAxS,OAAA,2BAAAiJ,IArFA,SAAAqpB,GACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,IAAA,OAAA,MACAA,EAAAA,EAAA,OAAA,UAAA,SACAA,EAAAA,EAAA,MAAA,SAAA,QACAA,EAAAA,EAAA,KAAA,QAAA,OACAA,EAAAA,EAAA,MAAA,SAAA,QACAA,EAAAA,EAAA,KAAA,QAAA,OACAA,EAAAA,EAAA,OAAA,UAAA,UACA1zB,EAAA0zB,UAAA1zB,EAAA0zB,YACA,IAAAA,GAAA1zB,EAAA0zB,OACA1zB,GAAAqL,EAAAqoB,EAAAroB,EACArL,EAAAsL,EAAAooB,EAAApoB,EACAtL,EAAAuL,IAAAmoB,EAAAnoB,IACAvL,EAAAwzB,OAAAE,EAAAF,OACAxzB,EAAA0L,MAAAgoB,EAAAhoB,MACA1L,EAAAyL,KAAAioB,EAAAjoB,KACAzL,EAAA2L,MAAA+nB,EAAA/nB,MACA3L,EAAA4L,KAAA8nB,EAAA9nB,KACA5L,EAAA6L,OAAA6nB,EAAA7nB,OACA7L,EAAA2zB,UAAA3zB,EAAAqL,EAAArL,EAAAsL,EAAAtL,EAAAuL,IAAAvL,EAAAwzB,OAAAxzB,EAAAyL,KAAAzL,EAAA0L,MAAA1L,EAAA2L,MAAA3L,EAAA4L,KAAA5L,EAAA6L,QAKA7L,EAAAszB,YAAAA,EAiCAtzB,EAAAuzB,iBAAAA,EA4BAvzB,EAAAyzB,iBAAAA,O5BqpHMG,IAAI,SAAS1yB,EAAQjB,EAAOD,G6B5uHlC,GAAA6zB,GAAA3yB,EAAA,UACA4yB,EAAA5yB,EAAA,cACA6yB,EAAA7yB,EAAA,WACA+O,EAAA/O,EAAA,eACAqS,EAAArS,EAAA,eACA8yB,EAAA9yB,EAAA,YACA+yB,EAAA/yB,EAAA,WACAgzB,EAAAhzB,EAAA,oBACAizB,EAAAjzB,EAAA,wBACAkzB,EAAAlzB,EAAA,WACAmzB,EAAAnzB,EAAA,WACAmkB,EAAAnkB,EAAA,UACAozB,EAAA,WACA,QAAAA,GAAAzpB,EAAA0pB,GACA,GAAAC,GAAAN,EAAAO,aACAj0B,MAAAk0B,MAAAP,EAAAQ,MAAAH,EAAAD,MAAA1pB,GACA0I,EAAApP,QAAA3D,KAAAk0B,MAAAjqB,SAAA,SAAA+E,EAAAnF,GACAmF,EAAApD,OACAoD,EAAApD,KAAAgoB,EAAAQ,YAAAplB,EAAApD,SAGA5L,KAAAq0B,OAAAr0B,KAAAs0B,qBACAt0B,KAAAu0B,QAAAf,EAAAgB,cAAAx0B,MA4KA,MA1KA8zB,GAAAnxB,UAAA2xB,mBAAA,WACA,GAAAG,GAAAz0B,KAAA00B,IAAApB,EAAAnoB,OAAAmoB,EAAAnoB,MAAAnL,KAAA00B,IAAApB,EAAAjoB,QAAAioB,EAAAjoB,OAAA,IACA,IAAAopB,IACAz0B,KAAA20B,GAAAlB,EAAAmB,MAAA50B,KAAA20B,GAAAlB,EAAAoB,QACA70B,KAAAoM,OAAA,YAAA,GACApM,KAAAgT,cAAA,CACA,GAAA8hB,GAAA90B,KAAAgS,UAAAshB,EAAAzoB,GACAkqB,EAAA/0B,KAAAgS,UAAAshB,EAAAxoB,EACA,IAAAgqB,IAAAC,EACA,OACAC,eAAA1B,EAAAxoB,EACAmqB,aAAA3B,EAAAzoB,EACA4pB,aAAAA,EACAroB,OAAApM,KAAAoM,OAAA,SAGA,IAAA2oB,IAAAD,EACA,OACAE,eAAA1B,EAAAzoB,EACAoqB,aAAA3B,EAAAxoB,EACA2pB,aAAAA,EACAroB,OAAApM,KAAAoM,OAAA,UAIA,MAAA,OAEA0nB,EAAAnxB,UAAAuyB,OAAA,WACA,MAAAl1B,MAAAu0B,SAEAT,EAAAnxB,UAAAwyB,MAAA,WACA,MAAAn1B,MAAAq0B,QAEAP,EAAAnxB,UAAAyyB,OAAA,SAAAC,EAAAC,GACA,GAAAjrB,GAAAJ,EAAA4pB,EAAAtpB,UAAAvK,KAAAk0B,MAAAjqB,SACAI,IACAG,KAAAxK,KAAAk0B,MAAA1pB,KACAP,SAAAA,GAEAorB,IACAhrB,EAAA+B,OAAAynB,EAAAtpB,UAAAvK,KAAAk0B,MAAA9nB,SAEAkpB,IACAjrB,EAAAgC,KAAAwnB,EAAAtpB,UAAAvK,KAAAk0B,MAAA7nB,MAEA,IAAA2nB,GAAAN,EAAAO,aACA,OAAAN,GAAA4B,SAAAlrB,EAAA2pB,IAEAF,EAAAnxB,UAAA6H,KAAA,WACA,MAAAxK,MAAAk0B,MAAA1pB,MAEAspB,EAAAnxB,UAAA0H,KAAA,WACA,MAAArK,MAAAk0B,OAEAJ,EAAAnxB,UAAAgyB,GAAA,SAAAnqB,GACA,MAAAxK,MAAAk0B,MAAA1pB,OAAAA,GAEAspB,EAAAnxB,UAAA+xB,IAAA,SAAA7qB,GACA,MAAApH,UAAAzC,KAAAk0B,MAAAjqB,SAAAJ,GAAAM,OAEA2pB,EAAAnxB,UAAAqM,SAAA,SAAAnF,GACA,MAAA7J,MAAAk0B,MAAAjqB,SAAAJ,IAEAiqB,EAAAnxB,UAAAwH,MAAA,SAAAN,EAAArD,GACAA,EAAAA,KACA,IAAAwI,GAAAhP,KAAAgP,SAAAnF,GACAtK,GAAAiH,EAAAgvB,MAAA,SAAA,KAAAhvB,EAAAivB,OAAA,IAAAtrB,EAAA6E,EAAA7E,KACA,IAAAsF,EAAA6G,QAAAtH,GACA,MAAAzP,GAAA,OAEA,IAAAiH,EAAAkkB,GACA,MAAAnrB,GAAAiH,EAAAkkB,GAAA,IAAAvgB,CAEA,KAAA3D,EAAAkvB,MAAA1mB,EAAAqB,IAAA,CACA,GAAAslB,GAAAnvB,EAAAmvB,WAAA,QACA,OAAAp2B,GAAA,OAAA4K,EAAAwrB,EAEA,MAAAnvB,GAAAkvB,MAAAlvB,EAAAovB,cAAA5mB,EAAAW,WAGAnJ,EAAAkvB,MAAA1mB,EAAAmC,SACA5R,EAAAyP,EAAAmC,SAAA,IAAAhH,EAGA5K,EAAA4K,EANA5K,EAAAyP,EAAAW,UAAA,IAAAxF,GASA2pB,EAAAnxB,UAAAkzB,WAAA,SAAAhsB,GACA,GAAA4F,EAAA6G,QAAAtW,KAAAk0B,MAAAjqB,SAAAJ,IACA,MAAA4F,GAAAqmB,iBAEA,IAAApL,GAAA1qB,KAAAk0B,MAAAjqB,SAAAJ,GAAA8F,WAAA3P,KAAAk0B,MAAAjqB,SAAAJ,GAAAsH,UAAAnR,KAAAk0B,MAAAjqB,SAAAJ,GAAAwG,KAAA,KACA,OAAAqa,GACAA,EAAAqL,cAAA,IAAA/1B,KAAAk0B,MAAAjqB,SAAAJ,GAAAM,MAAA,IAGAnK,KAAAk0B,MAAAjqB,SAAAJ,GAAAM,OAGA2pB,EAAAnxB,UAAA0N,IAAA,SAAAxG,GACA,GAAAwG,GAAArQ,KAAAk0B,MAAAjqB,SAAAJ,GAAAwG,GACA,OAAAA,SACA,EACAA,KAAA,GAEAwT,QAAAwP,EAAAT,iBAEAviB,GAEAyjB,EAAAnxB,UAAAqzB,aAAA,SAAAnsB,GACA,MAAA7J,MAAAoM,OAAA,iBAGA0nB,EAAAnxB,UAAAyE,IAAA,SAAA7H,GACA,MAAAwT,GAAA3L,IAAApH,KAAAk0B,MAAAjqB,SAAA1K,IAEAu0B,EAAAnxB,UAAAgG,OAAA,SAAApJ,EAAA02B,GACA,MAAAljB,GAAApK,OAAA3I,KAAAk0B,MAAAjqB,SAAA1K,EAAA02B,IAEAnC,EAAAnxB,UAAAgB,QAAA,SAAApE,GACA,MAAAwT,GAAApP,QAAA3D,KAAAk0B,MAAAjqB,SAAA1K,IAEAu0B,EAAAnxB,UAAAuzB,eAAA,SAAArsB,GACA,GAAAmF,GAAAhP,KAAAgP,SAAAnF,EACA,OAAAmF,KAAA6kB,EAAAsC,UAAAvC,EAAAwC,QAAAxC,EAAAyC,SAAArnB,EAAApD,OACAoD,EAAApD,OAAAgoB,EAAA0C,UAAAtnB,EAAAmC,UACA,YAAA0T,EAAAjN,MAAAhM,KAAAoD,EAAAmC,SAAAtH,KAEAiqB,EAAAnxB,UAAA+M,YAAA,SAAA7F,GACA,MAAA7J,MAAA00B,IAAA7qB,IACA4F,EAAAC,YAAA1P,KAAAgP,SAAAnF,KAEAiqB,EAAAnxB,UAAAqP,UAAA,SAAAnI,GACA,MAAA7J,MAAA00B,IAAA7qB,IACA4F,EAAAuC,UAAAhS,KAAAgP,SAAAnF,KAEAiqB,EAAAnxB,UAAAqQ,YAAA,WACA,MAAAD,GAAAC,YAAAhT,KAAAk0B,MAAAjqB,WAEA6pB,EAAAnxB,UAAA4zB,QAAA,WACA,MAAAv2B,MAAA00B,IAAApB,EAAAvoB,MAAA/K,KAAA00B,IAAApB,EAAAN,SAEAc,EAAAnxB,UAAA6zB,UAAA,WACA,MAAAx2B,MAAAgT,cAAAugB,EAAAkD,QAAAlD,EAAAmD,QAEA5C,EAAAnxB,UAAA0J,KAAA,WACA,MAAArM,MAAAk0B,MAAA7nB,MAEAynB,EAAAnxB,UAAAg0B,UAAA,WACA,GAAAvJ,GAAAptB,KAAAqM,OAAA2a,MACA,OAAAoG,IAAAA,EAAApsB,QAEA8yB,EAAAnxB,UAAAyJ,OAAA,SAAAmjB,GACA,MAAAvvB,MAAAk0B,MAAA9nB,OAAAmjB,IAEAuE,EAAAnxB,UAAAi0B,YAAA,WACA,GAAAC,GAAA72B,KAAAoM,OAAA,SAAAyqB,OACA,OAAAA,GACAA,EAGAhD,EAAAsC,UAAA1C,EAAAqD,MAAArD,EAAAsD,KAAAtD,EAAAuD,OAAAvD,EAAAwD,QAAAj3B,KAAAwK,WACAxK,KAAAgT,eACAhT,KAAA00B,IAAApB,EAAAjoB,SAAArL,KAAA00B,IAAApB,EAAAnoB,QAAAnL,KAAA00B,IAAApB,EAAApoB,QACA,GAHA,QASA4oB,IAEAt0B,GAAAs0B,MAAAA,I7B+uHGoD,SAAS,GAAGC,aAAa,GAAGC,UAAU,GAAGC,cAAc,GAAGC,cAAc,GAAGC,UAAU,GAAGC,mBAAmB,GAAGC,uBAAuB,GAAGC,UAAU,GAAG3vB,UAAU,GAAG4vB,WAAW,GAAGpF,SAAS,KAAKqF,IAAI,SAASl3B,EAAQjB,EAAOD,G8Bh7H7N,QAAAg1B,GAAAqD,GACA,GAAAC,GAAAC,EAAAF,GACAG,EAAAC,EAAAJ,EACA,QACAC,UAAAA,EACAE,WAAAA,EACAE,MAAAC,EAAAN,EAAAC,GACAM,OAAAC,EAAAR,EAAAG,IAIA,QAAAD,GAAAF,GACA,MAAAA,GAAAnD,IAAApB,EAAAzoB,GACAgtB,EAAA3B,eAAA5C,EAAAzoB,IACAwB,KAAAknB,EAAA+E,OAAAnuB,MAAA,aAEA0tB,EAAAzrB,OAAA,QAAA8rB,MAEAL,EAAArtB,SAAAipB,EAAAroB,KACAysB,EAAAzrB,OAAA,iBAEAyrB,EAAA7oB,SAAAskB,EAAAzoB,GAAA+M,MAAA2gB,UAEA,QAAAJ,GAAAN,EAAAC,GACA,MAAAD,GAAAnD,IAAApB,EAAAN,SACA3mB,KAAAknB,EAAA+E,OAAAnuB,MAAA,SAEA2tB,EAEA,QAAAG,GAAAJ,GACA,MAAAA,GAAAnD,IAAApB,EAAAxoB,GACA+sB,EAAA3B,eAAA5C,EAAAxoB,IACAuB,KAAAknB,EAAA+E,OAAAnuB,MAAA,cAGA0tB,EAAAzrB,OAAA,QAAAgsB,OAGAP,EAAA7oB,SAAAskB,EAAAxoB,GAAA8M,MAAA2gB,UAEA,QAAAF,GAAAR,EAAAG,GACA,MAAAH,GAAAnD,IAAApB,EAAAvoB,MACAsB,KAAAknB,EAAA+E,OAAAnuB,MAAA,UAEA6tB,EA/CA,GAAA1E,GAAA5yB,EAAA,cACA+yB,EAAA/yB,EAAA,WACA6yB,EAAA7yB,EAAA,UAWAlB,GAAAg1B,cAAAA,I9By9HG2C,aAAa,GAAGC,UAAU,GAAGG,UAAU,KAAKiB,IAAI,SAAS93B,EAAQjB,EAAOD,G+Bp+H3E,QAAAsR,GAAA9B,EAAAH,EAAA4pB,EAAA7sB,GACA,GAAAuF,GAAAnC,EAAAmC,QACA,QAAAA,GACA,IAAA,UAAA,MAAA,GACA,KAAA,UAAA,MAAA,GACA,KAAA,QAAA,MAAA,GACA,KAAA,MAAA,MAAA,EACA,KAAA,OAAA,MAAA,GACA,KAAA,QAAA,MAAA,GACA,KAAA,OACA,GAAAsG,GAAA5I,EAAAG,EAAA7E,OAAAuuB,EAAA7pB,EAAA,QAAAG,EAAA7E,MACA,OAAAuuB,GAGAA,EAAAlQ,UACA/Q,EAAA8Q,QAAA,GAAAkQ,EAAA7sB,GAAA,EAAA,GAHA,KAKA,MAAA,MAGA,QAAA+sB,GAAAxnB,EAAAhH,GACA,GAAAugB,GAAA,MAAAvZ,CACA,OAAAuZ,GAAA,IAAAvgB,EAAA,IAwCA,QAAAyuB,GAAAznB,EAAA0nB,GACA,SAAAA,IAAAA,GAAA,EACA,IAAAC,GAAAD,EAAA,UAAA,EACA,QAAA1nB,GACA,IAAA,MACA,MAAA,MAAA2nB,CACA,KAAA,QACA,MAAA,QAAAA,EAEA,MAAA,MAzEA,GAAAxxB,GAAA5G,EAAA,WACA4yB,EAAA5yB,EAAA,aAoBAlB,GAAAsR,YAAAA,EAKAtR,EAAAm5B,QAAAA,CACA,IAAA/gB,IACA,SAAAA,GACA,QAAAhM,GAAAuF,EAAAtH,GACA,GAAAA,IAAAypB,EAAAnoB,MACA,MAAA,QAEA,IAAAtB,IAAAypB,EAAAN,QAAAnpB,IAAAypB,EAAAvoB,IACA,MAAA,SAEA,QAAAoG,GACA,IAAA,QACA,IAAA,MACA,IAAA,OACA,IAAA,QACA,MAAA,SACA,KAAA,OACA,IAAA,SACA,IAAA,SACA,MAAA,SAEA,MAAA,OAGA,QAAA4nB,GAAA5nB,EAAAtH,GACA,GAAAmvB,GAAAnvB,IAAAypB,EAAAnoB,KACA,QAAAgG,GACA,IAAA,UACA,IAAA,UAAA,MAAA6nB,IAAA,EAAA,IAAA1xB,EAAA2V,MAAA,EAAA,GACA,KAAA,QAAA,MAAA+b,IAAA,EAAA,IAAA1xB,EAAA2V,MAAA,EAAA,GACA,KAAA,MAAA,MAAA+b,IAAA,EAAA,GAAA1xB,EAAA2V,MAAA,EAAA,EACA,KAAA,OAAA,MAAA+b,IAAA,EAAA,IAAA1xB,EAAA2V,MAAA,EAAA,GACA,KAAA,QAAA,MAAA+b,IAAA,EAAA,IAAA1xB,EAAA2V,MAAA,EAAA,IAEA,MAAA,MAXArF,EAAAhM,KAAAA,EAaAgM,EAAAmhB,OAAAA,GACAnhB,EAAApY,EAAAoY,QAAApY,EAAAoY,WAYApY,EAAAo5B,cAAAA,I/By+HGzB,aAAa,GAAGpvB,UAAU,KAAKkxB,IAAI,SAASv4B,EAAQjB,EAAOD,GgCpjI9D,GAAAo0B,GAAAlzB,EAAA,SACAlB,GAAAi3B,QAAA,UACAj3B,EAAAk3B,OAAA,SACAl3B,EAAA05B,QAAA,UACA15B,EAAA84B,OAAA,SACA94B,EAAAsnB,OACAe,UAAA+L,EAAAwC,QACAtO,OAAA8L,EAAAuF,aACAjT,QAAA0N,EAAAuF,aACAzc,KAAAkX,EAAA0C,SACAvO,OAAA6L,EAAAwC,WhCwjIGgD,SAAS,KAAKC,IAAI,SAAS34B,EAAQjB,EAAOD,GiCjkI7C,QAAA85B,GAAArvB,GACA,GAAA2F,GAAA,CAOA,OANA3F,GAAAC,OACA0F,IACA3F,EAAA3G,MACAsM,IACA3F,EAAA6H,OACAlC,IACAA,EAGA,QAAA8kB,GAAAzqB,EAAAJ,GACA,GAAAmF,GAAA/E,GAAAA,EAAAJ,EACA,OAAAmF,IAAAA,EAAA7E,MAGA,QAAA6I,GAAA/I,GACA,IAAA,GAAAnF,KAAAmF,GACA,GAAAyqB,EAAAzqB,EAAAnF,IAAAmF,EAAAnF,GAAA6K,UACA,OAAA,CAGA,QAAA,EAGA,QAAAf,GAAA3E,GACA,GAAAkR,KAMA,OALAmY,GAAAH,SAAAxvB,QAAA,SAAAmB,GACA4vB,EAAAzqB,EAAAnF,IACAqW,EAAAxV,KAAAsE,EAAAnF,MAGAqW,EAIA,QAAAxX,GAAAsG,EAAA1K,GACA,GAAAoB,GAAA,CACA2yB,GAAAH,SAAAxvB,QAAA,SAAAkG,GACA6qB,EAAAzqB,EAAAJ,IACAtK,EAAA0K,EAAAJ,GAAAA,EAAAlJ,OAKA,QAAAyG,GAAA6C,EAAA1K,GACA,GAAA4b,KAMA,OALAmY,GAAAH,SAAAxvB,QAAA,SAAAmB,GACA4vB,EAAAzqB,EAAAnF,IACAqW,EAAAxV,KAAApG,EAAA0K,EAAAnF,GAAAA,EAAAmF,MAGAkR,EAGA,QAAAxS,GAAAsB,EAAA1K,EAAA02B,GACA,GAAA51B,GAAA41B,CAMA,OALA3C,GAAAH,SAAAxvB,QAAA,SAAAmB,GACA4vB,EAAAzqB,EAAAnF,KACAzE,EAAAd,EAAAc,EAAA4J,EAAAnF,GAAAA,EAAAmF,MAGA5J,EA/DA,GAAAizB,GAAA5yB,EAAA,YAWAlB,GAAA85B,aAAAA,EAKA95B,EAAAk1B,IAAAA,EASAl1B,EAAAwT,YAAAA,EAUAxT,EAAAoP,UAAAA,EAUApP,EAAAmE,QAAAA,EAUAnE,EAAA4H,IAAAA,EAUA5H,EAAAmJ,OAAAA,IjCqkIG4wB,YAAY,KAAKC,IAAI,SAAS94B,EAAQjB,EAAOD,GkCloIhD,QAAAi6B,GAAAzqB,GACA,MAAA6kB,GAAAsC,UAAAvC,EAAAwC,QAAAxC,EAAAyC,SAAArnB,EAAApD,SAAAoD,EAAAqB,KACArB,EAAApD,OAAAgoB,EAAA0C,YAAAtnB,EAAAmC,SAEA,QAAAzB,GAAAV,GACA,MAAAA,IAAAyqB,EAAAzqB,GAGA,QAAAgD,GAAAhD,GACA,MAAAA,KAAAyqB,EAAAzqB,GAGA,QAAAY,KACA,OAAAzF,MAAA,IAAAwF,UAAA,QAAA/D,KAAAgoB,EAAAuF,aAAAO,YAAAl6B,EAAAs2B,mBAIA,QAAAxf,GAAAtH,GACA,MAAA,UAAAA,EAAAW,UAGA,QAAAmB,GAAA9B,EAAAH,EAAA4pB,GACA,SAAAA,IAAAA,KACA,IAAAhhB,GAAA5I,EAAAG,EAAA7E,OACAyB,EAAAoD,EAAApD,IACA,IAAAoD,EAAAqB,IAAA,CACA,GAAAA,GAAArB,EAAAqB,IACAwT,EAAA,iBAAAxT,GAAAgjB,EAAAT,gBAAAviB,EAAAwT,QACAL,EAAAqQ,EAAA8F,QAAAliB,EAAAoM,EACA,QAAAL,EAAArG,KAAAqG,EAAAtG,OAAAsG,EAAAxG,KAEA,GAAAhO,EAAApD,OAAAgoB,EAAA0C,SAAA,CACA,GAAAxlB,GAAA+T,EAAA/T,YAAA9B,EAAAH,EAAA4pB,EAAA7sB,EACA,IAAA,OAAAkF,EACA,MAAAA,GAEA,MAAA9B,GAAAW,UACA,EAEA8H,EAAA+Q,UACA/Q,EAAA8Q,QAAA,GAAAkQ,EAAA7sB,GAAA,EAAA,GA5CA,GAAAynB,GAAA3yB,EAAA,SACAmzB,EAAAnzB,EAAA,UACAmkB,EAAAnkB,EAAA,mBACAkzB,EAAAlzB,EAAA,SAQAlB,GAAAkQ,YAAAA,EAIAlQ,EAAAwS,UAAAA,EAIAxS,EAAAoQ,MAAAA,EACApQ,EAAAs2B,kBAAA,oBAIAt2B,EAAA8W,QAAAA,EAsBA9W,EAAAsR,YAAAA,IlCyoIG8oB,QAAQ,GAAGC,kBAAkB,GAAGT,SAAS,GAAG5qB,SAAS,KAAKsrB,IAAI,SAASp5B,EAAQjB,EAAOD,ImCvrIzF,SAAAu6B,GACAA,EAAAA,EAAA,KAAA,QAAA,OACAA,EAAAA,EAAA,IAAA,OAAA,MACAA,EAAAA,EAAA,KAAA,QAAA,OACAA,EAAAA,EAAA,MAAA,SAAA,QACAA,EAAAA,EAAA,KAAA,QAAA,OACAA,EAAAA,EAAA,KAAA,QAAA,OACAA,EAAAA,EAAA,OAAA,UAAA,SACAA,EAAAA,EAAA,OAAA,UAAA,UACAv6B,EAAAu6B,OAAAv6B,EAAAu6B,SACA,IAAAA,GAAAv6B,EAAAu6B,IACAv6B,GAAAq1B,KAAAkF,EAAAlF,KACAr1B,EAAAo1B,IAAAmF,EAAAnF,IACAp1B,EAAAw6B,KAAAD,EAAAC,KACAx6B,EAAAs3B,MAAAiD,EAAAjD,MACAt3B,EAAA4L,KAAA2uB,EAAA3uB,KACA5L,EAAAu3B,KAAAgD,EAAAhD,KACAv3B,EAAAw3B,OAAA+C,EAAA/C,OACAx3B,EAAAy3B,OAAA8C,EAAA9C,YnC0rIMgD,IAAI,SAASv5B,EAAQjB,EAAOD,GoC5sIlCA,EAAA06B,MACAtuB,KAAA,SACAC,YACAkkB,QACAnkB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,oHAKAmuB,MACAvuB,KAAA,UACAG,UAAAtJ,OACAuJ,YAAA,gPAEAouB,OACAxuB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,uGAEAquB,QACAzuB,KAAA,SACAG,UAAAtJ,OACA8J,QAAA,MAAA,QAAA,OAAA,UACAP,YAAA,8LAEAsuB,OACA1uB,KAAA,UACAG,UAAAtJ,OACA83B,QAAA,EACAvuB,YAAA,8MAEAwuB,OACA5uB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,yEAEAyuB,gBACA7uB,KAAA,UACAG,UAAA,GACAwuB,QAAA,EACAvuB,YAAA,sCAEA0uB,gBACA9uB,KAAA,UACAG,UAAAtJ,OACA83B,QAAA,EACAvuB,YAAA,kGAEA2uB,aACA/uB,KAAA,UACAG,UAAAtJ,OACAuJ,YAAA,sCAEA4uB,gBACAhvB,KAAA,UACAG,WAAA,EACAC,YAAA,gEAEAH,YACAD,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,sEpCktIM6uB,IAAI,SAASn6B,EAAQjB,EAAOD,GqCjxIlC,GAAA6zB,GAAA3yB,EAAA,UACAkzB,EAAAlzB,EAAA,WACAmzB,EAAAnzB,EAAA,UACAlB,GAAA6Q,KACAzE,MAAA,UAAA,UACAG,WAAA,EACAF,YACAgY,SACAjY,KAAA,UACAG,UAAAsnB,EAAAT,gBACA2H,QAAA,EACAvuB,YAAA,4BAGA8uB,eAAAjH,EAAApE,OAAAmE,EAAAuF,kBrCqxIGjC,SAAS,GAAGQ,UAAU,GAAG3vB,UAAU,KAAKgzB,IAAI,SAASr6B,EAAQjB,EAAOD,GsCnyIvEA,EAAAw7B,YACApvB,KAAA,SACAC,YACAqsB,OACAtsB,KAAA,UACAG,UAAA,KAEAqsB,QACAxsB,KAAA,UACAG,UAAA,KAEAkvB,SACArvB,KAAA,UACAG,UAAA,GACAC,YAAA,mCAEAkvB,WACAtvB,KAAA,SACA+M,KAAA,QACA5M,UAAA,WAEAovB,aACAvvB,KAAA,SACA2uB,QAAA,EACAa,QAAA,EACArvB,UAAA,KAEAsvB,YACAzvB,KAAA,SACAG,UAAA,GAEAuvB,MACA1vB,KAAA,SACA+M,KAAA,QACA5M,UAAA,iBAEAwvB,aACA3vB,KAAA,UAEA4vB,QACA5vB,KAAA,SACA+M,KAAA,SAEA8iB,aACA7vB,KAAA,WAEA8vB,eACA9vB,KAAA,UAEA+vB,YACA/vB,KAAA,QACAG,UAAAtJ,QAEAm5B,kBACAhwB,KAAA,UACAI,YAAA,yFtCyyIM6vB,IAAI,SAASn7B,EAAQjB,EAAOD,GuCh2IlCA,EAAAs8B,aACAlwB,KAAA,SACAC,YACAkwB,QACAnwB,KAAA,UACAG,WAAA,EACAC,YAAA,mFAEA+jB,QACAnkB,KAAA,SACAG,UAAA,GACAC,YAAA,+FAGAsvB,MACA1vB,KAAA,SACA+M,KAAA,QACA5M,UAAA,WAEA8qB,SACAjrB,KAAA,SACAG,UAAAtJ,OACA83B,QAAA,EACAa,QAAA,GAEAK,aACA7vB,KAAA,UACAG,UAAA,EACAwuB,QAAA,GAEAoB,YACA/vB,KAAA,QACAG,UAAAtJ,OACAuJ,YAAA,sFAEA4vB,kBACAhwB,KAAA,QACAG,UAAAtJ,OACAuJ,YAAA,kFAEAquB,QACAzuB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,mFAEAgwB,aACApwB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,8KAEAiwB,SACArwB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,oEAEAkwB,OACAtwB,KAAA,SACAG,UAAA,QACAQ,QAAA,OAAA,QAAA,UACAP,YAAA,qEAEAmwB,OACAvwB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,+CAEAowB,UACAxwB,KAAA,SACAG,UAAA,SACAQ,QAAA,MAAA,SAAA,UACAP,YAAA,mEAEAqwB,IACAzwB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA;EAEAswB,IACA1wB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,4IAEAuwB,MACA3wB,KAAA,SACAG,UAAAtJ,OACAkW,KAAA,OACA3M,YAAA,2DAEAwwB,WACA5wB,KAAA,SACAG,UAAAtJ,OACA8J,QAAA,SAAA,UACAP,YAAA,kCAEAywB,YACA7wB,KAAA,SACAW,QAAA,SAAA,QACAR,UAAAtJ,OACAuJ,YAAA,iCAEA0wB,QACA9wB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,sHAEA2wB,OACA/wB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,6QvCs2IM4wB,IAAI,SAASl8B,EAAQjB,EAAOD,GwCl9IlC,GAAAq9B,GAAAn8B,EAAA,yBACAo8B,EAAAp8B,EAAA,wBACAq8B,EAAAr8B,EAAA,wBACAlB,GAAA4M,QACAR,KAAA,SACAC,YACAmxB,UACApxB,KAAA,QACA/I,OACA+I,KAAA,WAEAG,UAAAtJ,OACAuJ,YAAA,oHAEAixB,YACArxB,KAAA,SACA+M,KAAA,QACA5M,UAAAtJ,OACAuJ,YAAA,yFAEAkxB,OACAtxB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,oLAEAysB,YACA7sB,KAAA,SACAC,YACAgL,SAAAjL,KAAA,UAAAG,WAAA,GACA+K,SAAAlL,KAAA,UAAAG,WAAA,GACAiL,cAAApL,KAAA,UAAAG,WAAA,GACAgL,UAAAnL,KAAA,UAAAG,WAAA,KAGAoxB,eACAvxB,KAAA,UACAG,UAAA,GACAwuB,QAAA,GAEA6C,YACAxxB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,oFAGAmpB,MAAA0H,EAAAQ,YACAC,KAAAR,EAAA9B,WACArnB,MAAAopB,EAAAjB,YACAyB,iBACA3xB,KAAA,UACAG,UAAA,EACAwuB,QAAA,GAEAiD,gBACA5xB,KAAA,UACAG,UAAA,GAEAiqB,cACApqB,KAAA,SACAG,UAAA,IACAC,YAAA,qDAEAyxB,YACA7xB,KAAA,SACAG,UAAA,WACAC,YAAA,oCxCw9IG0xB,uBAAuB,GAAGC,wBAAwB,GAAGC,wBAAwB,KAAKC,IAAI,SAASn9B,EAAQjB,EAAOD,GyCzhJjHA,EAAA69B,aACAzxB,MAAA,UAAA,UACAG,aACAC,YAAA,iDACAH,YACA7G,MACA84B,QACAlyB,KAAA,SACAW,QAAA,YAAA,gBAEAX,KAAA,QACA/I,OAAA+I,KAAA,YAEAI,YAAA,2LAKA+Q,QACAnR,KAAA,SACAW,QAAA,OAAA,SAAA,qBzC+hJMwxB,IAAI,SAASr9B,EAAQjB,EAAOD,G0CnjJlCA,EAAA6M,MACAT,KAAA,SACAC,YACAmyB,YACApyB,KAAA,SACAW,QAAA,OAAA,MAAA,OACAR,UAAA,QAEAkyB,KACAryB,KAAA,SACAG,UAAAtJ,QAEAukB,QACApb,KAAA,QACAG,UAAAtJ,OACAuJ,YAAA,oDACAnJ,OACA+I,KAAA,SACAsyB,sBAAA,IAGAt2B,QACAgE,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,oGAEAmyB,WACAvyB,KAAA,QACAG,UAAAtJ,OACAuJ,YAAA,mGACAnJ,OACA+I,KAAA,SACAC,YACA1B,OACAyB,KAAA,SACAI,YAAA,2DAEAoyB,MACAxyB,KAAA,SACAI,YAAA,iI1C4jJMqyB,IAAI,SAAS39B,EAAQjB,EAAOD,G2CnmJlC,GAAA8+B,GAAA59B,EAAA,gBACAmzB,EAAAnzB,EAAA,WACA69B,EAAA79B,EAAA,iBACA89B,EAAA99B,EAAA,mBACA+9B,EAAA/9B,EAAA,iBACAg+B,EAAAh+B,EAAA,qBACAi+B,GACAC,UAAA,QAAA,SAEAx2B,EAAAk2B,EAAAnK,MAAAN,EAAAtpB,UAAAm0B,EAAAG,cAAAF,GACA9yB,YACA+L,OACA/L,YACAovB,SAAAlvB,UAAA,GACAwsB,WAAAxsB,UAAA,MAGAmuB,KAAAqE,EAAArE,KACAl1B,KAAAy5B,EAAAz5B,QAGAmN,EAAA0hB,EAAAtpB,UAAAnC,GACA02B,EAAAR,EAAAnK,MAAAN,EAAAtpB,UAAAm0B,EAAAK,kBAAAJ,GACA9yB,YACAquB,KAAAqE,EAAArE,KACAl1B,KAAAy5B,EAAAz5B,QAGA0N,EAAA4rB,EAAAnK,MAAAN,EAAAtpB,UAAAu0B,IACAl1B,EAAA00B,EAAAnK,MAAAN,EAAAtpB,UAAAu0B,IACAx7B,EAAAg7B,EAAAnK,MAAAN,EAAAtpB,UAAAm0B,EAAAG,eACAhzB,YACAmzB,OAAAR,EAAAQ,OACAh6B,KAAAy5B,EAAAz5B,KACA5B,OACAwI,KAAA,UACAG,UAAA,GACAwuB,QAAA,EACAvuB,YAAA,qBAIA9B,EAAAo0B,EAAAnK,MAAAN,EAAAtpB,UAAAm0B,EAAAG,eACAhzB,YACAmzB,OAAAR,EAAAQ,OACAh6B,KAAAy5B,EAAAz5B,KACA5B,OACAwI,KAAA,SACA+M,KAAA,QACA5M,UAAA,UACAC,YAAA,+BAEA4L,OACAhM,KAAA,SACAC,YACAozB,mBACArzB,KAAA,QACAG,WAAA,UAAA,WACAC,YAAA,gDACAkzB,SAAA,EACAC,SAAA,EACAt8B,OACA+I,KAAA,SACA+M,KAAA,eAOA7G,EAAAwsB,EAAAnK,MAAAN,EAAAtpB,UAAAm0B,EAAAK,mBACAlzB,YACAmzB,OAAAR,EAAAQ,OACAh6B,KAAAy5B,EAAAz5B,KACA5B,OACAwI,KAAA,SACAW,QAAA,SAAA,SAAA,QAAA,UAAA,cAAA,iBACAR,UAAA,SACAC,YAAA,uBAIA5B,EAAAk0B,EAAAnK,MAAAN,EAAAtpB,UAAAm0B,EAAAK,mBACAlzB,YACA7G,KAAAy5B,EAAAz5B,QAGAqN,EAAAisB,EAAAnK,MAAAN,EAAAtpB,UAAAm0B,EAAAG,eACAhzB,YACA7G,KAAAy5B,EAAAz5B,KACA5B,OACAwI,KAAA,SACAG,UAAA,SAIAvM,GAAAyK,UACA2B,KAAA,SACAC,YACAzD,EAAAA,EACA+J,EAAAA,EACAO,IAAAA,EACA9I,OAAAA,EACAtG,KAAAA,EACA4G,MAAAA,EACA4H,MAAAA,EACAO,KAAAA,EACAjI,OAAAA,M3CwmJGrC,UAAU,GAAGq3B,gBAAgB,GAAGC,oBAAoB,GAAGC,kBAAkB,GAAGC,eAAe,GAAGC,gBAAgB,KAAKC,IAAI,SAAS/+B,EAAQjB,EAAOD,G4CntJlJ,GAAAkgC,GAAAh/B,EAAA,gBACAi/B,EAAAj/B,EAAA,kBACAk/B,EAAAl/B,EAAA,gBACAmzB,EAAAnzB,EAAA,WACA49B,EAAA59B,EAAA,gBACAm/B,EAAAn/B,EAAA,eACAkzB,EAAAlzB,EAAA,UACAlB,GAAAwP,UACApD,KAAA,SACAC,YACA1B,OACAyB,KAAA,UAEAA,MACAA,KAAA,SACAW,QAAAqnB,EAAAwC,QAAAxC,EAAAyC,QAAAzC,EAAAuF,aAAAvF,EAAA0C,WAEAnlB,UACAvF,KAAA,SACAW,OAAAszB,EAAAC,UACAhF,eAAAjH,EAAApE,OAAAmE,EAAA0C,YAEAjmB,IAAAqvB,EAAArvB,MAGA7Q,EAAAmQ,WACA/D,KAAA,SACAW,OAAAqzB,EAAAnN,cACAsN,gBACA/oB,aAAA4oB,EAAAnN,cACA3b,SAAA,SAAA,MAAA,OACAD,WACAE,UAAA,OAAA,SAAA,MAAA,OACAipB,IAAA,UAEAlF,eAAAjH,EAAApE,OAAAmE,EAAAuF,aAAAvF,EAAAwC,QAAAxC,EAAAyC,QAAAzC,EAAA0C,SAAA,MAEA92B,EAAAq/B,aAAAP,EAAAnK,MAAAN,EAAAtpB,UAAA/K,EAAAwP,WACAnD,YACA8D,UAAAnQ,EAAAmQ,UACAiI,MAAA+nB,EAAAM,gBAGAzgC,EAAAu/B,iBAAAT,EAAAnK,MAAAN,EAAAtpB,UAAA/K,EAAAwP,WACAnD,YACA+L,MAAA+nB,EAAAO,sB5CwtJGC,eAAe,GAAGC,cAAc,GAAG1I,UAAU,GAAG3vB,UAAU,GAAGs4B,eAAe,GAAGC,iBAAiB,GAAGf,eAAe,KAAKgB,IAAI,SAAS7/B,EAAQjB,EAAOD,G6CrwJtJA,EAAAw/B,QACAjzB,WAAA,EACAC,YAAA,6EACA8xB,QACAlyB,KAAA,SACAC,YACAwuB,QACAzuB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,mJAEAwuB,OACA5uB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,2EAEA+jB,QACAnkB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,oFAEAgb,QACApb,KAAA,QACAG,UAAAtJ,OACAuJ,YAAA,6CAEAH,YACAD,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,qEAIAJ,KAAA,kB7C0wJM40B,IAAI,SAAS9/B,EAAQjB,EAAOD,G8C3yJlCA,EAAAgL,MACAoB,KAAA,SACAW,QAAA,QAAA,OAAA,MAAA,OAAA,OAAA,SAAA,SAAA,c9C+yJMk0B,IAAI,SAAS//B,EAAQjB,EAAOD,G+CjzJlC,GAAAq0B,GAAAnzB,EAAA,WACA49B,EAAA59B,EAAA,gBACAkzB,EAAAlzB,EAAA,WACAkX,GACAhM,KAAA,SACAC,YACAD,MACAA,KAAA,SACAW,QAAA,SAAA,MAAA,MAAA,OAAA,YACAR,UAAA,SACA+uB,eAAAjH,EAAApE,OAAAmE,EAAAuF,gBAEAJ,QACAhtB,UAAAtJ,OACAmJ,MAAA,QAAA,UACAI,YAAA,mTAEAiR,OACAlR,UAAAtJ,OACAmJ,MAAA,QAAA,SAAA,UACAI,YAAA,2bAEA/G,OACA8G,UAAAtJ,OACAmJ,KAAA,UACAI,YAAA,4GAIA00B,GACA70B,YACA0sB,WACA3sB,KAAA,UACA2uB,QAAA,EACAxuB,UAAAtJ,QAEAk+B,cACA/0B,KAAA,SACAG,UAAAtJ,QAEAw4B,SACArvB,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,wsBAEAnH,QACA+G,KAAA,UACAG,UAAAtJ,OACAuJ,YAAA,6PAIA40B,GACA/0B,YACAg1B,OACAj1B,KAAA,UACAG,WAAA,EACAC,YAAA,wGAEA80B,MACA/0B,UAAAtJ,OACAq7B,QAEAlyB,KAAA,UACAI,YAAA,4GAEAJ,KAAA,SACAW,QAAA,SAAA,SAAA,OAAA,MAAA,OAAA,QAAA,QACAP,YAAA,iRAGA8uB,eAAAjH,EAAApE,OAAAmE,EAAAuF,aAAAvF,EAAA0C,WACAtqB,YAAA,IAEA+0B,UACAn1B,KAAA,SACAG,UAAAtJ,OACAuJ,YAAA,+FAEA6L,MACAjM,KAAA,UACAI,YAAA,mIACAD,UAAAtJ,OACAq4B,eAAAjH,EAAApE,OAAAmE,EAAAuF,aAAAvF,EAAA0C,YAEA0K,cACAp1B,KAAA,UACAG,WAAA,EACAC,YAAA,0MAOAxM,GAAA0gC,iBAAA5B,EAAAnK,MAAAN,EAAAtpB,UAAAqN,GAAA8oB,GACAlhC,EAAAygC,aAAA3B,EAAAnK,MAAAN,EAAAtpB,UAAAqN,GAAA8oB,EAAAE,K/CozJGlJ,UAAU,GAAG3vB,UAAU,GAAGw3B,eAAe,KAAK0B,IAAI,SAASvgC,EAAQjB,EAAOD,GgD13J7E,QAAAy0B,KACA,MAAAN,GAAAM,YAAAz0B,EAAAk0B,QA3BA,GAAAC,GAAAjzB,EAAA,gBACAwgC,EAAAxgC,EAAA,iBACAygC,EAAAzgC,EAAA,mBACA0gC,EAAA1gC,EAAA,iBACA2gC,EAAA3gC,EAAA,qBACAg+B,EAAAh+B,EAAA,oBACAlB,GAAAmQ,UAAA+uB,EAAA/uB,UACAnQ,EAAA8H,KAAAqsB,EACAn0B,EAAAk0B,QACA4N,QAAA,0CACAt1B,YAAA,qCACAJ,KAAA,SACAgzB,UAAA,OAAA,YACA/yB,YACA0jB,MACA3jB,KAAA,UAEAI,aACAJ,KAAA,UAEAS,KAAA+0B,EAAA/0B,KACA7B,KAAA02B,EAAA12B,KACAP,SAAAo3B,EAAAp3B,SACAmC,OAAA+0B,EAAA/0B,SAMA5M,EAAAy0B,YAAAA,IhDw5JGsN,kBAAkB,GAAGC,gBAAgB,GAAGC,oBAAoB,GAAGpC,oBAAoB,GAAGqC,gBAAgB,GAAGnC,eAAe,KAAKoC,IAAI,SAASjhC,EAAQjB,EAAOD,GiDp7J5J,QAAAoiC,GAAAhnB,GACA,MAAA,KAAAa,OAAA/R,KAAAkR,GAAA5Z,OAGA,QAAAuQ,GAAAswB,EAAAnO,GACA,MAAAS,GAAAF,EAAAP,GAAAmO,GAIA,QAAA5N,GAAAP,GACA,GAAAjO,EACA,IAAAhjB,SAAAixB,EAAA,CAGA,GAAA,WAAAA,GAEA,MADAjO,GAAAiO,EAAAA,WACApsB,EAAAsoB,SAAAnK,GAAAne,EAAAiD,UAAAkb,GAAAA,CAEA,IAAA,WAAAiO,EAAA9nB,KAAA,CACA,GAAAi2B,KACA,KAAA,GAAAtS,KAAAmE,GAAA7nB,WACA4Z,EAAAwO,EAAAP,EAAA7nB,WAAA0jB,IACA9sB,SAAAgjB,IACAoc,EAAAtS,GAAA9J,EAGA,OAAAoc,GAEA,UAAAnO,EAAA9nB,MAOA,QAAA2pB,GAAAsM,EAAA7N,GACA,GAAA8N,KACA,KAAA,GAAAC,KAAAF,GAAA,CACA,GAAAG,GAAAhO,EAAA+N,GACAE,EAAAJ,EAAAE,EACA,KAAA/N,GAAAgO,IAAAC,EACA,GAAA,gBAAAA,KAAA36B,EAAAqT,QAAAsnB,IAAAD,EAAA,CACA,GAAAz5B,GAAAgtB,EAAA0M,EAAAD,EACAJ,GAAAr5B,KACAu5B,EAAAC,GAAAx5B,OAGA,IAAAjB,EAAAqT,QAAAsnB,GAAA,CACA,GAAA36B,EAAAqT,QAAAqnB,IACAC,EAAAjhC,SAAAghC,EAAAhhC,OAAA,CAEA,IAAA,GADAwuB,IAAA,EACA7uB,EAAA,EAAAA,EAAAshC,EAAAjhC,OAAAL,IACA,GAAAshC,EAAAthC,KAAAqhC,EAAArhC,GAAA,CACA6uB,GAAA,CACA,OAGA,GAAAA,EACA,SAIAsS,EAAAC,GAAAE,MAGAH,GAAAC,GAAAE,EAIA,MAAAH,GAIA,QAAA3N,GAAA+N,GAEA,IAAA,GADAC,MACAC,EAAA,EAAAA,EAAAzc,UAAA3kB,OAAAohC,IACAD,EAAAC,EAAA,GAAAzc,UAAAyc,EAEA,KAAA,GAAAzhC,GAAA,EAAAA,EAAAwhC,EAAAnhC,OAAAL,IACAuhC,EAAAG,EAAAH,EAAAC,EAAAxhC,GAEA,OAAAuhC,GAIA,QAAAG,GAAAH,EAAAC,GACA,GAAA,gBAAAA,IAAA,OAAAA,EACA,MAAAD,EAEA,KAAA,GAAAlpB,KAAAmpB,GACAA,EAAAG,eAAAtpB,IAGAvW,SAAA0/B,EAAAnpB,KAGA,gBAAAmpB,GAAAnpB,IAAA,OAAAmpB,EAAAnpB,GACAkpB,EAAAlpB,GAAAmpB,EAAAnpB,GAEA,gBAAAkpB,GAAAlpB,IAAA,OAAAkpB,EAAAlpB,GACAkpB,EAAAlpB,GAAAmb,EAAAgO,EAAAnpB,GAAAupB,cAAAh9B,YAAA48B,EAAAnpB,IAGAmb,EAAA+N,EAAAlpB,GAAAmpB,EAAAnpB,IAGA,OAAAkpB,GA3GA,GAAA56B,GAAA5G,EAAA,UAQAlB,GAAA+R,OAAAA,EA0BA/R,EAAAy0B,YAAAA,EAsCAz0B,EAAA+1B,SAAAA,EAYA/1B,EAAA20B,MAAAA,IjDg9JGpsB,UAAU,KAAKy6B,IAAI,SAAS9hC,EAAQjB,EAAOD,GkDpiK9C,GAAAogC,GAAAl/B,EAAA,gBACAkzB,EAAAlzB,EAAA,WACAmzB,EAAAnzB,EAAA,UACAlB,GAAAwF,MACA+G,UAAA,YACA+uB,eAAAjH,EAAApE,OAAAmE,EAAAuF,aAAAvF,EAAAyC,UACAyH,QAEAlyB,KAAA,SACAW,QAAA,YAAA,aAAA,cAGAX,KAAA,SACAgzB,UAAA,QAAA,MACA/yB,YACA1B,OACAyB,KAAA,SACAI,YAAA,qCAEAqkB,IACAzkB,KAAA,SACAW,OAAAqzB,EAAAnN,cACAzmB,YAAA,qCAEAy2B,OACA72B,KAAA,SACAW,QAAA,YAAA,qBlD4iKG4zB,eAAe,GAAGzI,UAAU,GAAG3vB,UAAU,KAAK26B,IAAI,SAAShiC,EAAQjB,EAAOD,GmD7jK7E,QAAAwH,GAAAqD,GACA,MAAA,OAAA7K,EAAAmjC,OAAAt4B,EAAAG,KACAhL,EAAA2P,MAAAyzB,EAAAv4B,EAAAJ,UAGA,QAAA7D,GAAAy8B,EAAAx2B,EAAAD,GACA,GAAA2iB,GAAA8T,EAAA9T,MAAAvvB,EAAA2P,OAAA3E,EAAAukB,EAAA+T,QAAA/T,MAAAvvB,EAAAmjC,QAAA,GAAAxT,OAAAllB,EAAA84B,EAAAhU,EAAA7f,KAAA1P,EAAA2P,QACA9E,GACAG,KAAAipB,EAAAsG,KAAAvvB,GACAP,SAAAA,EAQA,OANAxH,UAAA4J,IACAhC,EAAAgC,KAAAA,GAEA5J,SAAA2J,IACA/B,EAAA+B,OAAAA,GAEA/B,EAGA,QAAAu4B,GAAA34B,GACA,MAAA8I,GAAA3L,IAAA6C,EAAA,SAAA+E,EAAAnF,GACA,MAAAA,GAAArK,EAAAmjC,OAAA1zB,EAAAD,KACAE,KAAA1P,EAAA2P,OAGA,QAAA4zB,GAAAC,GACA,MAAAA,GAAAjU,MAAAvvB,EAAA2P,OAAAxG,OAAA,SAAA6P,EAAAtY,GACA,GAAA6uB,GAAA7uB,EAAA6uB,MAAAvvB,EAAAmjC,QAAAM,EAAAlU,EAAA,GAAAI,OAAA+T,EAAAnU,EAAA,EAEA,OADAvW,GAAAyqB,GAAAE,EAAAD,GACA1qB,OAIA,QAAAvJ,GAAAD,GACA,OAAAA,EAAAW,UAAAX,EAAAW,UAAAnQ,EAAA4jC,KAAA,KACAp0B,EAAAmC,SAAAnC,EAAAmC,SAAA3R,EAAA4jC,KAAA,KACAp0B,EAAAqB,IAAA,MAAA7Q,EAAA4jC,KAAA,KACAp0B,EAAA7E,OAAA,IAAA3K,EAAA6jC,KAAAzP,EAAA0P,WAAAt0B,EAAApD,MAGA,QAAA23B,GAAA30B,EAAA40B,GAEA,MADA,UAAAA,IAAAA,EAAAhkC,EAAA2P,OACAP,EAAAxH,IAAA6H,GAAAC,KAAAs0B,GAGA,QAAAL,GAAAD,GACA,GAAAviC,GAAAouB,EAAAmU,EAAAnU,MAAAvvB,EAAA6jC,MACAr0B,GACA7E,MAAA4kB,EAAA,GAAAI,OACAvjB,KAAAgoB,EAAA6P,qBAAA1U,EAAA,GAAAI,QAEA,KAAAxuB,IAAAi/B,GAAAnN,cAAA,CACA,GAAAhyB,GAAAm/B,EAAAnN,cAAA9xB,EACA,IAAA,IAAAqO,EAAA7E,MAAA6Q,QAAAva,EAAA,KAAA,CACAuO,EAAA7E,MAAA6E,EAAA7E,MAAAu5B,OAAAjjC,EAAAO,OAAA,GACA,UAAAP,GAAA,IAAAuO,EAAA7E,MAAAnJ,SACAgO,EAAA7E,MAAA,KACA6E,EAAAW,UAAAlP,CACA,QAGA,IAAAE,IAAAk/B,GAAAC,UAAA,CACA,GAAA6D,GAAA9D,EAAAC,UAAAn/B,EACA,IAAAqO,EAAA7E,OAAA,IAAA6E,EAAA7E,MAAA6Q,QAAA2oB,EAAA,KAAA,CACA30B,EAAA7E,MAAA6E,EAAA7E,MAAAu5B,OAAA10B,EAAA7E,MAAAnJ,OAAA,GACAgO,EAAAmC,SAAAwyB,CACA,QAOA,MAJA30B,GAAA7E,OAAA,IAAA6E,EAAA7E,MAAA6Q,QAAA,UACAhM,EAAA7E,MAAA6E,EAAA7E,MAAAu5B,OAAA,GACA10B,EAAAqB,KAAA,GAEArB,EAnFA,GAAA4wB,GAAAl/B,EAAA,eACAm/B,EAAAn/B,EAAA,cACAkzB,EAAAlzB,EAAA,UACAqS,EAAArS,EAAA,cACA+yB,EAAA/yB,EAAA,SACAlB,GAAA2P,MAAA,IACA3P,EAAAmjC,OAAA,IACAnjC,EAAA6jC,KAAA,IACA7jC,EAAA4jC,KAAA,IAKA5jC,EAAAwH,QAAAA,EAeAxH,EAAA4G,MAAAA,EAMA5G,EAAAojC,gBAAAA,EAQApjC,EAAAujC,cAAAA,EAOAvjC,EAAAyP,gBAAAA,EAKAzP,EAAA+jC,iBAAAA,EA+BA/jC,EAAA2jC,cAAAA,InDykKGS,cAAc,GAAGC,aAAa,GAAGC,SAAS,GAAGC,aAAa,GAAG3K,SAAS,KAAK4K,IAAI,SAAStjC,EAAQjB,EAAOD,GoDzpK1G,QAAAykC,GAAA55B,GACA,MAAA0I,GAAAC,YAAA3I,EAAAJ,UAGA,QAAA2E,GAAAvE,GACA,MAAA0I,GAAAnE,UAAAvE,EAAAJ,UAIA,QAAAi6B,GAAA75B,GACA,MAAA,IAAA85B,GAAArQ,MAAAzpB,GAAA+qB,QAAA,GAGA,QAAArrB,GAAAM,GACA,OAAA0I,EAAA2hB,IAAArqB,EAAAJ,SAAAqpB,EAAAnoB,QAAA4H,EAAA2hB,IAAArqB,EAAAJ,SAAAqpB,EAAApoB,UACAb,EAAAG,OAAAipB,EAAAmB,KAAAvqB,EAAAG,OAAAipB,EAAAoB,SACAxqB,EAAA+B,SAAA/B,EAAA+B,OAAA+oB,QAAA,IACApiB,EAAAC,YAAA3I,EAAAJ,UAGA,QAAAm6B,GAAA/5B,GACA,GAAAg6B,GAAAh6B,EAAAJ,SAAAA,EAAA4pB,EAAAtpB,UAAAF,EAAAJ,SAMA,OALAA,GAAA7B,EAAAi8B,EAAAlyB,EACAlI,EAAAkI,EAAAkyB,EAAAj8B,EACA6B,EAAAyI,IAAA2xB,EAAAz6B,OACAK,EAAAL,OAAAy6B,EAAA3xB,IACArI,EAAAJ,SAAAA,EACAI,EAhCA,GAAA85B,GAAAzjC,EAAA,oBACA4yB,EAAA5yB,EAAA,aACAqS,EAAArS,EAAA,cACA+yB,EAAA/yB,EAAA,UACAmzB,EAAAnzB,EAAA,SAIAlB,GAAAykC,kBAAAA,EAIAzkC,EAAAoP,UAAAA,EAKApP,EAAA0kC,aAAAA,EAOA1kC,EAAAuK,QAAAA,EAUAvK,EAAA4kC,UAAAA,IpDiqKG7K,YAAY,GAAG+K,mBAAmB,GAAGT,aAAa,GAAGC,SAAS,GAAGt1B,SAAS,KAAK+1B,IAAI,SAAS7jC,EAAQjB,EAAOD,GqDnsK9GA,EAAAsgC,WACA,OAAA,QAAA,MAAA,OAAA,QAAA,UAAA,gBrDusKM0E,IAAI,SAAS9jC,EAAQjB,EAAOD,GsDjrKlC,QAAA40B,GAAAxoB,GACA,GAAA64B,GAAA74B,CACA,OAAApM,GAAAikC,qBAAAgB,EAAA1O,gBACA0O,EAAAC,eA1BA,SAAAp5B,GACAA,EAAAA,EAAA,aAAA,gBAAA,eACAA,EAAAA,EAAA,QAAA,WAAA,UACAA,EAAAA,EAAA,SAAA,YAAA,WACAA,EAAAA,EAAA,QAAA,WAAA,WACA9L,EAAA8L,OAAA9L,EAAA8L,SACA,IAAAA,GAAA9L,EAAA8L,IACA9L,GAAA25B,aAAA7tB,EAAA6tB,aACA35B,EAAA62B,QAAA/qB,EAAA+qB,QACA72B,EAAA82B,SAAAhrB,EAAAgrB,SACA92B,EAAA42B,QAAA9qB,EAAA8qB,QACA52B,EAAA8jC,YACAtsB,aAAA,IACAD,SAAA,IACAF,QAAA,IACAC,QAAA,KAEAtX,EAAAikC,sBACAkB,EAAAnlC,EAAA25B,aACAyL,EAAAplC,EAAA82B,SACAuO,EAAArlC,EAAA62B,QACAyO,EAAAtlC,EAAA42B,SAOA52B,EAAA40B,YAAAA,OtD2sKM2Q,IAAI,SAASrkC,EAAQjB,EAAOD,GuDvuKlC,QAAAwlC,GAAAxsB,GACA,IAAA,GAAAQ,KAAAR,GAAAhZ,EAAA8iC,eAAAtpB,KAAAxZ,EAAAwZ,GAAAR,EAAAQ,IAKA,QAAAmd,GAAApb,EAAAD,GACA,MAAAC,GAAAC,QAAAF,GAAA,GAGA,QAAAnX,GAAAiX,EAAArb,EAAA2b,GACA,GAAAN,EAAAjX,QACAiX,EAAAjX,QAAA5C,KAAAma,EAAA3b,OAGA,KAAA,GAAAuF,KAAA8V,GACArb,EAAAwB,KAAAma,EAAAN,EAAA9V,GAAAA,EAAA8V,GAKA,QAAAjS,GAAAiS,EAAArb,EAAA02B,EAAA/a,GACA,GAAAN,EAAAjS,OACA,MAAAiS,GAAAjS,OAAA5H,KAAAma,EAAA3b,EAAA02B,EAGA,KAAA,GAAAnxB,KAAA8V,GACAqb,EAAA12B,EAAAwB,KAAAma,EAAA+a,EAAArb,EAAA9V,GAAAA,EAAA8V,EAEA,OAAAqb,GAIA,QAAA7uB,GAAAwT,EAAArb,EAAA2b,GACA,GAAAN,EAAAxT,IACA,MAAAwT,GAAAxT,IAAArG,KAAAma,EAAA3b,EAGA,IAAAoP,KACA,KAAA,GAAA7J,KAAA8V,GACAjM,EAAAhJ,KAAApG,EAAAwB,KAAAma,EAAAN,EAAA9V,GAAAA,EAAA8V,GAEA,OAAAjM,GAIA,QAAA6C,GAAA2J,EAAA5b,GACA,GAAAuF,GAAAnE,EAAA,CACA,KAAAmE,IAAAqW,GACA,GAAA5b,EAAA4b,EAAArW,GAAAA,EAAAnE,KACA,OAAA,CAEA,QAAA,EAGA,QAAAsnB,GAAA9M,EAAA5b,GACA,GAAAuF,GAAAnE,EAAA,CACA,KAAAmE,IAAAqW,GACA,IAAA5b,EAAA4b,EAAArW,GAAAA,EAAAnE,KACA,OAAA,CAEA,QAAA,EAIA,QAAAg5B,GAAA9qB,EAAAgV,GACA,MAAAohB,IACAphC,IAAAgL,EAAAhL,IACA3B,IAAA2M,EAAA3M,IACA2hB,QAAAA,IAIA,QAAAqhB,GAAAC,GACAC,QAAAF,MAAA,aAAAC,GAvEAH,EAAAtkC,EAAA,qBACAskC,EAAAtkC,EAAA,yBACAskC,EAAAtkC,EAAA,sBAIAlB,EAAA22B,SAAAA,EAWA32B,EAAAmE,QAAAA,EAYAnE,EAAAmJ,OAAAA,EAaAnJ,EAAA4H,IAAAA,EASA5H,EAAAgS,IAAAA,EASAhS,EAAAyoB,IAAAA,CACA,IAAAgd,GAAAvkC,EAAA,wBAQAlB,GAAAm6B,QAAAA,EAIAn6B,EAAA0lC,MAAAA,IvD0uKGG,wBAAwB,GAAGC,uBAAuB,GAAGC,oBAAoB,GAAGC,mBAAmB,KAAKC,IAAI,SAAS/kC,EAAQjB,EAAOD,GwDryKnI,QAAAsW,GAAAzL,EAAAq7B,EAAAC,GACA,SAAAD,IAAAA,EAAAlmC,EAAAomC,8BACA,SAAAD,IAAAA,EAAAnmC,EAAAqmC,+BACA,IAAAr7B,GAAAH,EAAAG,KACAP,EAAAI,EAAAJ,SACA67B,EAAAJ,EAAAl7B,GACAu7B,EAAAJ,EAAAn7B,EACA,KAAA,GAAA7J,KAAAmlC,GACA,KAAAA,EAAAnlC,IAAAsJ,IACA,MAAA,6BAAA67B,EAAAnlC,GACA,eAAA6J,EAAA,GAGA,KAAA,GAAAX,KAAAI,GACA,IAAA87B,EAAAl8B,GACA,MAAA,qBAAAA,EACA,oCAAAW,EAAA,GAGA,OAAAA,KAAAipB,EAAAmB,KAAA3qB,EAAA7B,GAAA6B,EAAAkI,EAGA,KAFA,+BArCA,GAAA0hB,GAAAnzB,EAAA,UACA+yB,EAAA/yB,EAAA,SACAlB,GAAAomC,8BACAvzB,MAAA,QACAsD,MAAA,IAAA,KACAC,MAAA,IAAA,MAEApW,EAAAqmC,gCACAnwB,IAAAme,EAAApE,OAAA,MAAA,SAAA,IAAA,IAAA,OAAA,QAAA,WACA9Z,KAAAke,EAAApE,OAAA,MAAA,SAAA,IAAA,IAAA,QAAA,WACA7Z,KAAAie,EAAApE,OAAA,MAAA,SAAA,IAAA,IAAA,QAAA,WACA5Z,KAAAge,EAAApE,OAAA,MAAA,SAAA,IAAA,IAAA,QAAA,WACAvW,OAAA2a,EAAApE,OAAA,MAAA,SAAA,IAAA,IAAA,QAAA,OAAA,WACAtW,OAAA0a,EAAApE,OAAA,MAAA,SAAA,IAAA,IAAA,QAAA,OAAA,WACArqB,MAAAyuB,EAAApE,OAAA,MAAA,SAAA,IAAA,IAAA,QAAA,OAAA,SAAA,UACApd,KAAAwhB,EAAApE,OAAA,MAAA,SAAA,OAAA,QAAA,UA0BAjwB,EAAAsW,wBAAAA,IxDyzKGguB,SAAS,GAAGt1B,SAAS,UAAU,KAAK","file":"compass.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.cp = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\n},{}],2:[function(require,module,exports){\nmodule.exports = {\n   hcluster: require(\"./hcluster\"),\n   Kmeans: require(\"./kmeans\"),\n   kmeans: require(\"./kmeans\").kmeans\n};\n},{\"./hcluster\":4,\"./kmeans\":5}],3:[function(require,module,exports){\nmodule.exports = {\n  euclidean: function(v1, v2) {\n      var total = 0;\n      for (var i = 0; i < v1.length; i++) {\n         total += Math.pow(v2[i] - v1[i], 2);      \n      }\n      return Math.sqrt(total);\n   },\n   manhattan: function(v1, v2) {\n     var total = 0;\n     for (var i = 0; i < v1.length ; i++) {\n        total += Math.abs(v2[i] - v1[i]);      \n     }\n     return total;\n   },\n   max: function(v1, v2) {\n     var max = 0;\n     for (var i = 0; i < v1.length; i++) {\n        max = Math.max(max , Math.abs(v2[i] - v1[i]));      \n     }\n     return max;\n   }\n};\n},{}],4:[function(require,module,exports){\nvar distances = require(\"./distance\");\n\nvar HierarchicalClustering = function(distance, linkage, threshold) {\n   this.distance = distance;\n   this.linkage = linkage;\n   this.threshold = threshold == undefined ? Infinity : threshold;\n}\n\nHierarchicalClustering.prototype = {\n   cluster : function(items, snapshotPeriod, snapshotCb) {\n      this.clusters = [];\n      this.dists = [];  // distances between each pair of clusters\n      this.mins = []; // closest cluster for each cluster\n      this.index = []; // keep a hash of all clusters by key\n      \n      for (var i = 0; i < items.length; i++) {\n         var cluster = {\n            value: items[i],\n            key: i,\n            index: i,\n            size: 1\n         };\n         this.clusters[i] = cluster;\n         this.index[i] = cluster;\n         this.dists[i] = [];\n         this.mins[i] = 0;\n      }\n\n      for (var i = 0; i < this.clusters.length; i++) {\n         for (var j = 0; j <= i; j++) {\n            var dist = (i == j) ? Infinity : \n               this.distance(this.clusters[i].value, this.clusters[j].value);\n            this.dists[i][j] = dist;\n            this.dists[j][i] = dist;\n\n            if (dist < this.dists[i][this.mins[i]]) {\n               this.mins[i] = j;               \n            }\n         }\n      }\n\n      var merged = this.mergeClosest();\n      var i = 0;\n      while (merged) {\n        if (snapshotCb && (i++ % snapshotPeriod) == 0) {\n           snapshotCb(this.clusters);           \n        }\n        merged = this.mergeClosest();\n      }\n    \n      this.clusters.forEach(function(cluster) {\n        // clean up metadata used for clustering\n        delete cluster.key;\n        delete cluster.index;\n      });\n\n      return this.clusters;\n   },\n  \n   mergeClosest: function() {\n      // find two closest clusters from cached mins\n      var minKey = 0, min = Infinity;\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key = this.clusters[i].key,\n             dist = this.dists[key][this.mins[key]];\n         if (dist < min) {\n            minKey = key;\n            min = dist;\n         }\n      }\n      if (min >= this.threshold) {\n         return false;         \n      }\n\n      var c1 = this.index[minKey],\n          c2 = this.index[this.mins[minKey]];\n\n      // merge two closest clusters\n      var merged = {\n         left: c1,\n         right: c2,\n         key: c1.key,\n         size: c1.size + c2.size\n      };\n\n      this.clusters[c1.index] = merged;\n      this.clusters.splice(c2.index, 1);\n      this.index[c1.key] = merged;\n\n      // update distances with new merged cluster\n      for (var i = 0; i < this.clusters.length; i++) {\n         var ci = this.clusters[i];\n         var dist;\n         if (c1.key == ci.key) {\n            dist = Infinity;            \n         }\n         else if (this.linkage == \"single\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] > this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];\n            }\n         }\n         else if (this.linkage == \"complete\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] < this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];              \n            }\n         }\n         else if (this.linkage == \"average\") {\n            dist = (this.dists[c1.key][ci.key] * c1.size\n                   + this.dists[c2.key][ci.key] * c2.size) / (c1.size + c2.size);\n         }\n         else {\n            dist = this.distance(ci.value, c1.value);            \n         }\n\n         this.dists[c1.key][ci.key] = this.dists[ci.key][c1.key] = dist;\n      }\n\n    \n      // update cached mins\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key1 = this.clusters[i].key;        \n         if (this.mins[key1] == c1.key || this.mins[key1] == c2.key) {\n            var min = key1;\n            for (var j = 0; j < this.clusters.length; j++) {\n               var key2 = this.clusters[j].key;\n               if (this.dists[key1][key2] < this.dists[key1][min]) {\n                  min = key2;                  \n               }\n            }\n            this.mins[key1] = min;\n         }\n         this.clusters[i].index = i;\n      }\n    \n      // clean up metadata used for clustering\n      delete c1.key; delete c2.key;\n      delete c1.index; delete c2.index;\n\n      return true;\n   }\n}\n\nvar hcluster = function(items, distance, linkage, threshold, snapshot, snapshotCallback) {\n   distance = distance || \"euclidean\";\n   linkage = linkage || \"average\";\n\n   if (typeof distance == \"string\") {\n     distance = distances[distance];\n   }\n   var clusters = (new HierarchicalClustering(distance, linkage, threshold))\n                  .cluster(items, snapshot, snapshotCallback);\n      \n   if (threshold === undefined) {\n      return clusters[0]; // all clustered into one\n   }\n   return clusters;\n}\n\nmodule.exports = hcluster;\n\n},{\"./distance\":3}],5:[function(require,module,exports){\nvar distances = require(\"./distance\");\n\nfunction KMeans(centroids) {\n   this.centroids = centroids || [];\n}\n\nKMeans.prototype.randomCentroids = function(points, k) {\n   var centroids = points.slice(0); // copy\n   centroids.sort(function() {\n      return (Math.round(Math.random()) - 0.5);\n   });\n   return centroids.slice(0, k);\n}\n\nKMeans.prototype.classify = function(point, distance) {\n   var min = Infinity,\n       index = 0;\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   for (var i = 0; i < this.centroids.length; i++) {\n      var dist = distance(point, this.centroids[i]);\n      if (dist < min) {\n         min = dist;\n         index = i;\n      }\n   }\n\n   return index;\n}\n\nKMeans.prototype.cluster = function(points, k, distance, snapshotPeriod, snapshotCb) {\n   k = k || Math.max(2, Math.ceil(Math.sqrt(points.length / 2)));\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   this.centroids = this.randomCentroids(points, k);\n\n   var assignment = new Array(points.length);\n   var clusters = new Array(k);\n\n   var iterations = 0;\n   var movement = true;\n   while (movement) {\n      // update point-to-centroid assignments\n      for (var i = 0; i < points.length; i++) {\n         assignment[i] = this.classify(points[i], distance);\n      }\n\n      // update location of each centroid\n      movement = false;\n      for (var j = 0; j < k; j++) {\n         var assigned = [];\n         for (var i = 0; i < assignment.length; i++) {\n            if (assignment[i] == j) {\n               assigned.push(points[i]);\n            }\n         }\n\n         if (!assigned.length) {\n            continue;\n         }\n\n         var centroid = this.centroids[j];\n         var newCentroid = new Array(centroid.length);\n\n         for (var g = 0; g < centroid.length; g++) {\n            var sum = 0;\n            for (var i = 0; i < assigned.length; i++) {\n               sum += assigned[i][g];\n            }\n            newCentroid[g] = sum / assigned.length;\n\n            if (newCentroid[g] != centroid[g]) {\n               movement = true;\n            }\n         }\n\n         this.centroids[j] = newCentroid;\n         clusters[j] = assigned;\n      }\n\n      if (snapshotCb && (iterations++ % snapshotPeriod == 0)) {\n         snapshotCb(clusters);\n      }\n   }\n\n   return clusters;\n}\n\nKMeans.prototype.toJSON = function() {\n   return JSON.stringify(this.centroids);\n}\n\nKMeans.prototype.fromJSON = function(json) {\n   this.centroids = JSON.parse(json);\n   return this;\n}\n\nmodule.exports = KMeans;\n\nmodule.exports.kmeans = function(vectors, k) {\n   return (new KMeans()).cluster(vectors, k);\n}\n},{\"./distance\":3}],6:[function(require,module,exports){\n\"use strict\";\n\nmodule.exports = cluster;\n\nvar vlShorthand = require('vega-lite/src/shorthand'),\n  clusterfck = require('clusterfck'),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\ncluster.distance = require('./distance');\n\nfunction cluster(specs, opt) {\n  // jshint unused:false\n  var dist = cluster.distance.table(specs);\n\n  var clusterTrees = clusterfck.hcluster(specs, function(e1, e2) {\n    var s1 = vlShorthand.shorten(e1),\n      s2 = vlShorthand.shorten(e2);\n    return dist[s1][s2];\n  }, 'average', consts.CLUSTER_THRESHOLD);\n\n  var clusters = clusterTrees.map(function(tree) {\n      return util.traverse(tree, []);\n    })\n   .map(function(cluster) {\n    return cluster.sort(function(spec1, spec2) {\n      // sort each cluster -- have the highest score as 1st item\n      return spec2._info.score - spec1._info.score;\n    });\n  }).filter(function(cluster) {  // filter empty cluster\n    return cluster.length >0;\n  }).sort(function(cluster1, cluster2) {\n    //sort by highest scoring item in each cluster\n    return cluster2[0]._info.score - cluster1[0]._info.score;\n  });\n\n  clusters.dist = dist; //append dist in the array for debugging\n\n  return clusters;\n}\n},{\"../util\":19,\"./clusterconsts\":7,\"./distance\":8,\"clusterfck\":2,\"vega-lite/src/shorthand\":52}],7:[function(require,module,exports){\n'use strict';\n\nvar c = module.exports = {};\n\nc.SWAPPABLE = 0.05;\nc.DIST_MISSING = 1;\nc.CLUSTER_THRESHOLD = 1;\n\nfunction reduceTupleToTable(r, x) {\n  var a = x[0], b = x[1], d = x[2];\n  r[a] = r[a] || {};\n  r[b] = r[b] || {};\n  r[a][b] = r[b][a] = d;\n  return r;\n}\n\nc.DIST_BY_CHANNEL = [\n  // positional\n  ['x', 'y', c.SWAPPABLE],\n  ['row', 'column', c.SWAPPABLE],\n\n  // ordinal mark properties\n  ['color', 'shape', c.SWAPPABLE],\n  ['color', 'detail', c.SWAPPABLE],\n  ['detail', 'shape', c.SWAPPABLE],\n\n  // quantitative mark properties\n  ['size', 'color', c.SWAPPABLE]\n].reduce(reduceTupleToTable, {});\n\n},{}],8:[function(require,module,exports){\n'use strict';\n\nvar vlSpec = require('vega-lite/src/spec'),\n  vlShorthand = require('vega-lite/src/shorthand'),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\nvar distance = {};\nmodule.exports = distance;\n\ndistance.table = function (specs) {\n  var len = specs.length,\n    extendedSpecs = specs.map(function(e) { return distance.extendSpecWithChannelByColumnName(e); }),\n    shorthands = specs.map(vlShorthand.shorten),\n    diff = {}, i, j;\n\n  for (i = 0; i < len; i++) diff[shorthands[i]] = {};\n\n  for (i = 0; i < len; i++) {\n    for (j = i + 1; j < len; j++) {\n      var sj = shorthands[j], si = shorthands[i];\n\n      diff[sj][si] = diff[si][sj] = distance.get(extendedSpecs[i], extendedSpecs[j]);\n    }\n  }\n  return diff;\n};\n\ndistance.get = function (extendedSpec1, extendedSpec2) {\n  var cols = util.union(util.keys(extendedSpec1.channelByField), util.keys(extendedSpec2.channelByField)),\n    dist = 0;\n\n  cols.forEach(function(column) {\n    var e1 = extendedSpec1.channelByField[column], e2 = extendedSpec2.channelByField[column];\n\n    if (e1 && e2) {\n      if (e1.channel != e2.channel) {\n        dist += (consts.DIST_BY_CHANNEL[e1.channel] || {})[e2.channel] || 1;\n      }\n    } else {\n      dist += consts.DIST_MISSING;\n    }\n  });\n\n  // do not group stacked chart with similar non-stacked chart!\n  var isStack1 = vlSpec.isStack(extendedSpec1),\n    isStack2 = vlSpec.isStack(extendedSpec2);\n\n  if (isStack1 || isStack2) {\n    if (isStack1 && isStack2) {\n      if ((extendedSpec1.encoding.color && extendedSpec2.encoding.color &&\n          extendedSpec1.encoding.color.field !== extendedSpec2.encoding.color.field) ||\n          (extendedSpec1.encoding.detail && extendedSpec2.encoding.detail &&\n          extendedSpec1.encoding.detail.field !== extendedSpec2.encoding.detail.field)\n         ) {\n        dist+=1;\n      }\n    } else {\n      dist+=1; // surely different\n    }\n  }\n  return dist;\n};\n\n// get encoding type by fieldname\ndistance.extendSpecWithChannelByColumnName = function(spec) {\n  var _channelByField = {},\n    encoding = spec.encoding;\n\n  util.keys(encoding).forEach(function(channel) {\n    var e = util.duplicate(encoding[channel]);\n    e.channel = channel;\n    _channelByField[e.field || ''] = e;\n    delete e.field;\n  });\n\n  return {\n    mark: spec.mark,\n    channelByField: _channelByField,\n    encoding: spec.encoding\n  };\n};\n},{\"../util\":19,\"./clusterconsts\":7,\"vega-lite/src/shorthand\":52,\"vega-lite/src/spec\":53}],9:[function(require,module,exports){\n'use strict';\n\nvar consts = module.exports = {\n  gen: {},\n  cluster: {},\n  rank: {}\n};\n\nconsts.X = 'x';\nconsts.Y = 'y';\nconsts.ROW = 'row';\nconsts.COL = 'column';\nconsts.SIZE = 'size';\nconsts.SHAPE = 'shape';\nconsts.COLOR = 'color';\nconsts.TEXT = 'text';\nconsts.DETAIL = 'detail';\n\n\n// rename these\nconsts.Type = {};\nconsts.Type.Nominal = 'nominal';\nconsts.Type.Ordinal = 'ordinal';\nconsts.Type.Quantitative = 'quantitative';\nconsts.Type.Temporal = 'temporal';\n\n\nconsts.gen.projections = {\n  type: 'object',\n  properties: {\n    omitDotPlot: { //FIXME remove this!\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    maxCardinalityForAutoAddOrdinal: {\n      type: 'integer',\n      default: 50,\n      description: 'max cardinality for an ordinal variable to be considered for auto adding'\n    },\n    alwaysAddHistogram: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nconsts.gen.aggregates = {\n  type: 'object',\n  properties: {\n    config: {\n      type: 'object'\n    },\n    data: {\n      type: 'object'\n    },\n    tableTypes: {\n      type: 'boolean',\n      default: 'both',\n      enum: ['both', 'aggregated', 'disaggregated']\n    },\n    genDimQ: {\n      type: 'string',\n      default: 'auto',\n      enum: ['auto', 'bin', 'cast', 'none'],\n      description: 'Use Q as Dimension either by binning or casting'\n    },\n    minCardinalityForBin: {\n      type: 'integer',\n      default: 20,\n      description: 'minimum cardinality of an ordinal variable if we were to bin'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitMeasureOnly: {\n      type: 'boolean',\n      default: false,\n      description: 'Omit aggregation with measure(s) only'\n    },\n    omitDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Omit aggregation with dimension(s) only'\n    },\n    addCountForDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Add count when there are dimension(s) only'\n    },\n    aggrList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: [undefined, 'mean']\n    },\n    timeUnitList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: ['year']\n    },\n    consistentAutoQ: {\n      type: 'boolean',\n      default: true,\n      description: \"generate similar auto transform for quant\"\n    }\n  }\n};\n\nconsts.gen.encodings = {\n  type: 'object',\n  properties: {\n    markList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['point', 'bar', 'line', 'area', 'text', 'tick'], //filled_map\n      description: 'allowed marks'\n    },\n    encodingTypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['x', 'y', 'row', 'column', 'size', 'color', 'text', 'detail'],\n      description: 'allowed encoding types'\n    },\n    requiredEncodings: {\n      type: 'object',\n      default: undefined,\n      description: 'required encodings for each mark type'\n    },\n    supportedEncodings: {\n      type: 'object',\n      default: undefined,\n      description: 'supported encoding for each mark type'\n    },\n    // TODO: is this used in generation?\n    maxGoodCardinalityForFacets: {\n      type: 'integer',\n      default: 5,\n      description: 'maximum cardinality of an ordinal variable to be put on facet (row/column) effectively'\n    },\n    maxCardinalityForFacets: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of an ordinal variable to be put on facet (row/column)'\n    },\n    maxGoodCardinalityForColor: {\n      type: 'integer',\n      default: 7,\n      description: 'maximum cardinality of an ordinal variable to be put on color effectively'\n    },\n    maxCardinalityForColor: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of an ordinal variable to be put on color'\n    },\n    maxCardinalityForShape: {\n      type: 'integer',\n      default: 6,\n      description: 'maximum cardinality of an ordinal variable to be put on shape'\n    },\n    omitTranpose:  {\n      type: 'boolean',\n      default: true,\n      description: 'Eliminate all transpose by (1) keeping horizontal dot plot only (2) for OxQ charts, always put O on Y (3) show only one DxD, MxM (currently sorted by name)'\n    },\n    // TODO: create chart type name\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitDotPlotWithExtraEncoding: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all dot plots with >1 encoding'\n    },\n    omitMultipleRetinalEncodings: {\n      type: 'boolean',\n      default: true,\n      description: 'omit using multiple retinal variables (size, color, shape)'\n    },\n    // TODO: revise\n    omitNonTextAggrWithAllDimsOnFacets: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all aggregated charts (except text tables) with all dims on facets (row, column)'\n    },\n    // TODO: revise\n    omitOneDimensionCount: {\n      type: 'boolean',\n      default: false,\n      description: 'omit one dimension count'\n    },\n    // TODO remove this and merge with supportedEncodings\n    omitSizeOnBar: {\n      type: 'boolean',\n      default: false,\n      description: 'do not use bar\\'s size'\n    },\n    // TODO: change to omit non-summative stack\n    omitStackedAverage: {\n      type: 'boolean',\n      default: true,\n      description: 'do not stack bar chart with average'\n    },\n    alwaysGenerateTableAsHeatmap: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\n},{}],10:[function(require,module,exports){\nmodule.exports = {\n  consts: require('./consts'),\n  cluster: require('./cluster/cluster'),\n  gen: require('./gen/gen'),\n  rank: require('./rank/rank'),\n  util: require('./util'),\n  auto: \"-, sum\"\n};\n\n\n\n},{\"./cluster/cluster\":6,\"./consts\":9,\"./gen/gen\":13,\"./rank/rank\":17,\"./util\":19}],11:[function(require,module,exports){\n'use strict';\n\nvar vlFieldDef = require('vega-lite/src/fielddef');\nvar vlSchemaUtil = require('vega-lite/src/schema/schemautil');\nvar vlShorthand = require('vega-lite/src/shorthand');\n\nvar consts = require('../consts');\nvar Type = consts.Type;\nvar util = require('../util');\n\nvar AUTO = '*';\n\nmodule.exports = genAggregates;\n\n\nfunction genAggregates(output, fieldDefs, stats, opt) {\n  opt = vlSchemaUtil.extend(opt||{}, consts.gen.aggregates);\n  var tf = new Array(fieldDefs.length);\n  var hasNorO = util.any(fieldDefs, function(f) {\n    return f.type === Type.Nominal || f.type == Type.Ordinal;\n  });\n\n  function emit(fieldSet) {\n    fieldSet = util.duplicate(fieldSet);\n    fieldSet.key = fieldSet.map(function(fieldDef) {\n      return vlShorthand.shortenFieldDef(fieldDef);\n    }).join(vlShorthand.DELIM);\n    output.push(fieldSet);\n  }\n\n  function checkAndPush() {\n    if (opt.omitMeasureOnly || opt.omitDimensionOnly) {\n      var hasMeasure = false, hasDimension = false, hasRaw = false;\n      tf.forEach(function(f) {\n        if (vlFieldDef.isDimension(f)) {\n          hasDimension = true;\n        } else {\n          hasMeasure = true;\n          if (!f.aggregate) hasRaw = true;\n        }\n      });\n      if (!hasDimension && !hasRaw && opt.omitMeasureOnly) return;\n      if (!hasMeasure) {\n        if (opt.addCountForDimensionOnly) {\n          tf.push(vlFieldDef.count());\n          emit(tf);\n          tf.pop();\n        }\n        if (opt.omitDimensionOnly) return;\n      }\n    }\n    if (opt.omitDotPlot && tf.length === 1) return;\n    emit(tf);\n  }\n\n  function assignAggrQ(i, hasAggr, autoMode, a) {\n    var canHaveAggr = hasAggr === true || hasAggr === null,\n      cantHaveAggr = hasAggr === false || hasAggr === null;\n    if (a) {\n      if (canHaveAggr) {\n        tf[i].aggregate = a;\n        assignField(i + 1, true, autoMode);\n        delete tf[i].aggregate;\n      }\n    } else { // if(a === undefined)\n      if (cantHaveAggr) {\n        assignField(i + 1, false, autoMode);\n      }\n    }\n  }\n\n  function assignBinQ(i, hasAggr, autoMode) {\n    tf[i].bin = true;\n    assignField(i + 1, hasAggr, autoMode);\n    delete tf[i].bin;\n  }\n\n  function assignQ(i, hasAggr, autoMode) {\n    var f = fieldDefs[i],\n      canHaveAggr = hasAggr === true || hasAggr === null;\n\n    tf[i] = {field: f.field, type: f.type};\n\n    if (f.aggregate === 'count') { // if count is included in the selected fields\n      if (canHaveAggr) {\n        tf[i].aggregate = f.aggregate;\n        assignField(i + 1, true, autoMode);\n      }\n    } else if (f._aggregate) {\n      // TODO support array of f._aggrs too\n      assignAggrQ(i, hasAggr, autoMode, f._aggregate);\n    } else if (f._raw) {\n      assignAggrQ(i, hasAggr, autoMode, undefined);\n    } else if (f._bin) {\n      assignBinQ(i, hasAggr, autoMode);\n    } else {\n      opt.aggrList.forEach(function(a) {\n        if (!opt.consistentAutoQ || autoMode === AUTO || autoMode === a) {\n          assignAggrQ(i, hasAggr, a /*assign autoMode*/, a);\n        }\n      });\n\n      if ((!opt.consistentAutoQ || util.isin(autoMode, [AUTO, 'bin', 'cast', 'autocast'])) && !hasNorO) {\n        var highCardinality = vlFieldDef.cardinality(f, stats) > opt.minCardinalityForBin;\n\n        var isAuto = opt.genDimQ === 'auto',\n          genBin = opt.genDimQ  === 'bin' || (isAuto && highCardinality),\n          genCast = opt.genDimQ === 'cast' || (isAuto && !highCardinality);\n\n        if (genBin && util.isin(autoMode, [AUTO, 'bin', 'autocast'])) {\n          assignBinQ(i, hasAggr, isAuto ? 'autocast' : 'bin');\n        }\n        if (genCast && util.isin(autoMode, [AUTO, 'cast', 'autocast'])) {\n          tf[i].type = Type.Ordinal;\n          assignField(i + 1, hasAggr, isAuto ? 'autocast' : 'cast');\n          tf[i].type = Type.Quantitative;\n        }\n      }\n    }\n  }\n\n  function assignTimeUnitT(i, hasAggr, autoMode, timeUnit) {\n    tf[i].timeUnit = timeUnit;\n    assignField(i+1, hasAggr, autoMode);\n    delete tf[i].timeUnit;\n  }\n\n  function assignT(i, hasAggr, autoMode) {\n    var f = fieldDefs[i];\n    tf[i] = {field: f.field, type: f.type};\n\n    // TODO support array of f._timeUnits\n    if (f._timeUnit) {\n      assignTimeUnitT(i, hasAggr, autoMode, f._timeUnit);\n    } else {\n      opt.timeUnitList.forEach(function(timeUnit) {\n        if (timeUnit === undefined) {\n          if (!hasAggr) { // can't aggregate over raw time\n            assignField(i+1, false, autoMode);\n          }\n        } else {\n          assignTimeUnitT(i, hasAggr, autoMode, timeUnit);\n        }\n      });\n    }\n\n    // FIXME what if you aggregate time?\n  }\n\n  function assignField(i, hasAggr, autoMode) {\n    if (i === fieldDefs.length) { // If all fields are assigned\n      checkAndPush();\n      return;\n    }\n\n    var f = fieldDefs[i];\n    // Otherwise, assign i-th field\n    switch (f.type) {\n      //TODO \"D\", \"G\"\n      case Type.Quantitative:\n        assignQ(i, hasAggr, autoMode);\n        break;\n\n      case Type.Temporal:\n        assignT(i, hasAggr, autoMode);\n        break;\n      case Type.Ordinal:\n        /* falls through */\n      case Type.Nominal:\n        /* falls through */\n      default:\n        tf[i] = f;\n        assignField(i + 1, hasAggr, autoMode);\n        break;\n    }\n  }\n\n  var hasAggr = opt.tableTypes === 'aggregated' ? true : opt.tableTypes === 'disaggregated' ? false : null;\n  assignField(0, hasAggr, AUTO);\n\n  return output;\n}\n\n},{\"../consts\":9,\"../util\":19,\"vega-lite/src/fielddef\":35,\"vega-lite/src/schema/schemautil\":50,\"vega-lite/src/shorthand\":52}],12:[function(require,module,exports){\n\"use strict\";\n\nvar vlFieldDef = require('vega-lite/src/fielddef');\nvar vlEncoding = require('vega-lite/src/encoding');\nvar util = require('../util');\n\nvar genMarks = require('./marks'),\n  isDimension = vlFieldDef.isDimension,\n  isMeasure = vlFieldDef.isMeasure;\n\nvar consts = require('../consts');\nvar Type = consts.Type;\n\nmodule.exports = genEncodings;\n\n// FIXME remove dimension, measure and use information in vega-lite instead!\nvar rules = {\n  x: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  y: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  row: {\n    dimension: true,\n    multiple: true\n  },\n  column: {\n    dimension: true,\n    multiple: true\n  },\n  shape: {\n    dimension: true,\n    rules: shapeRules\n  },\n  size: {\n    measure: true,\n    rules: retinalEncRules\n  },\n  color: {\n    dimension: true,\n    measure: true,\n    rules: colorRules\n  },\n  text: {\n    measure: true\n  },\n  detail: {\n    dimension: true\n  }\n  //geo: {\n  //  geo: true\n  //},\n  //arc: { // pie\n  //\n  //}\n};\n\nfunction retinalEncRules(encoding, fieldDef, stats, opt) {\n  if (opt.omitMultipleRetinalEncodings) {\n    if (encoding.color || encoding.size || encoding.shape) return false;\n  }\n  return true;\n}\n\nfunction colorRules(encoding, fieldDef, stats, opt) {\n  if(!retinalEncRules(encoding, fieldDef, stats, opt)) return false;\n\n  return vlFieldDef.isMeasure(fieldDef) ||\n    vlFieldDef.cardinality(fieldDef, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction shapeRules(encoding, fieldDef, stats, opt) {\n  if(!retinalEncRules(encoding, fieldDef, stats, opt)) return false;\n\n  if (fieldDef.bin && fieldDef.type === Type.Quantitative) return false;\n  if (fieldDef.timeUnit && fieldDef.type === Type.Temporal) return false;\n  return vlFieldDef.cardinality(fieldDef, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction dimMeaTransposeRule(encoding) {\n  // create horizontal histogram for ordinal\n  if ((encoding.y.type === Type.Nominal || encoding.y.type === Type.Ordinal) && isMeasure(encoding.x)) {\n    return true;\n  }\n\n  // vertical histogram for Q and T\n  if (isMeasure(encoding.y) &&\n      !(encoding.x.type === Type.Nominal || encoding.x.type === Type.Ordinal) &&\n      isDimension(encoding.x)\n      ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction generalRules(encoding, stats, opt) {\n  // encoding.text is only used for TEXT TABLE\n  if (encoding.text) {\n    return genMarks.satisfyRules(encoding, 'text', stats, opt);\n  }\n\n  // CARTESIAN PLOT OR MAP\n  if (encoding.x || encoding.y || encoding.geo || encoding.arc) {\n\n    if (encoding.row || encoding.column) { //have facet(s)\n\n      // don't use facets before filling up x,y\n      if (!encoding.x || !encoding.y) return false;\n\n      if (opt.omitNonTextAggrWithAllDimsOnFacets) {\n        // remove all aggregated charts with all dims on facets (row, column)\n        if (genEncodings.isAggrWithAllDimOnFacets(encoding)) return false;\n      }\n    }\n\n    if (encoding.x && encoding.y) {\n      var isDimX = !!isDimension(encoding.x),\n        isDimY = !!isDimension(encoding.y);\n\n      if (isDimX && isDimY && !vlEncoding.isAggregate(encoding)) {\n        // FIXME actually check if there would be occlusion #90\n        return false;\n      }\n\n      if (opt.omitTranpose) {\n        if (isDimX ^ isDimY) { // dim x mea\n          if (!dimMeaTransposeRule(encoding)) {\n            return false;\n          }\n        } else if (encoding.y.type=== Type.Temporal|| encoding.x.type === Type.Temporal) {\n          if (encoding.y.type=== Type.Temporal && encoding.x.type !== Type.Temporal) {\n            return false;\n          }\n        } else { // show only one OxO, QxQ\n          if (encoding.x.field > encoding.y.field) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    // DOT PLOTS\n    // // plot with one axis = dot plot\n    if (opt.omitDotPlot) {\n      return false;\n    }\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && encoding.y) {\n      return false;\n    }\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && util.keys(encoding).length > 1) {\n      return false;\n    }\n\n    if (opt.omitOneDimensionCount) {\n      // one dimension \"count\"\n      if (encoding.x && encoding.x.aggregate == 'count' && !encoding.y) {\n        return false;\n      }\n      if (encoding.y && encoding.y.aggregate == 'count' && !encoding.x) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  return false;\n}\n\ngenEncodings.isAggrWithAllDimOnFacets = function (encoding) {\n  var hasAggr = false, hasOtherO = false;\n  for (var channel in encoding) {\n    var fieldDef = encoding[channel];\n    if (fieldDef.aggregate) {\n      hasAggr = true;\n    }\n    if (vlFieldDef.isDimension(fieldDef) && (channel !== consts.ROW && channel !== consts.COL)) {\n      hasOtherO = true;\n    }\n    if (hasAggr && hasOtherO) break;\n  }\n\n  return hasAggr && !hasOtherO;\n};\n\n\nfunction genEncodings(encodings, fieldDefs, stats, opt) {\n  // generate a collection vega-lite's encoding\n  var tmpEncoding = {};\n\n  function assignField(i) {\n    // If all fields are assigned, save\n    if (i === fieldDefs.length) {\n      // at the minimal all chart should have x, y, geo, text or arc\n      if (generalRules(tmpEncoding, stats, opt)) {\n        encodings.push(util.duplicate(tmpEncoding));\n      }\n      return;\n    }\n\n    // Otherwise, assign i-th field\n    var fieldDef = fieldDefs[i];\n    for (var j in opt.encodingTypeList) {\n      var channel = opt.encodingTypeList[j],\n        isDim = isDimension(fieldDef);\n\n      //TODO: support \"multiple\" assignment\n      if (!(channel in tmpEncoding) && // encoding not used\n        ((isDim && rules[channel].dimension) || (!isDim && rules[channel].measure)) &&\n        (!rules[channel].rules || rules[channel].rules(tmpEncoding, fieldDef, stats, opt))\n      ) {\n        tmpEncoding[channel] = fieldDef;\n        assignField(i + 1);\n        delete tmpEncoding[channel];\n      }\n    }\n  }\n\n  assignField(0);\n\n  return encodings;\n}\n\n},{\"../consts\":9,\"../util\":19,\"./marks\":14,\"vega-lite/src/encoding\":34,\"vega-lite/src/fielddef\":35}],13:[function(require,module,exports){\n'use strict';\n\nvar util = require('../util');\n\n/**\n * Module for generating visualizations\n */\n\nvar gen = module.exports = {\n  // data variations\n  aggregates: require('./aggregates'),\n  projections: require('./projections'),\n  // encodings / visual variations\n  specs: require('./specs'),\n  encodings: require('./encodings'),\n  marks: require('./marks')\n};\n\n\n// TODO(kanitw): revise if this is still working\ngen.charts = function(fieldDefs, opt, config, flat) {\n  opt = util.gen.getOpt(opt);\n  flat = flat === undefined ? {encodings: 1} : flat;\n\n  // TODO generate\n\n  // generate permutation of encoding mappings\n  var fieldSets = opt.genAggr ? gen.aggregates([], fieldDefs, opt) : [fieldDefs],\n    encodings, charts, level = 0;\n\n  if (flat === true || (flat && flat.aggregate)) {\n    encodings = fieldSets.reduce(function(output, fieldDefs) {\n      return gen.encs(output, fieldDefs, opt);\n    }, []);\n  } else {\n    encodings = fieldSets.map(function(fieldDefs) {\n      return gen.encs([], fieldDefs, opt);\n    }, true);\n    level += 1;\n  }\n\n  if (flat === true || (flat && flat.encodings)) {\n    charts = util.nestedReduce(encodings, function(output, encoding) {\n      return gen.marks(output, encoding, opt, config);\n    }, level, true);\n  } else {\n    charts = util.nestedMap(encodings, function(encoding) {\n      return gen.marks([], encoding, opt, config);\n    }, level, true);\n    level += 1;\n  }\n  return charts;\n};\n},{\"../util\":19,\"./aggregates\":11,\"./encodings\":12,\"./marks\":14,\"./projections\":15,\"./specs\":16}],14:[function(require,module,exports){\n\"use strict\";\n\nvar vlEncoding = require('vega-lite/src/encoding');\nvar vlFieldDef = require('vega-lite/src/fielddef');\nvar vlValidate = require('vega-lite/src/validate');\n\nvar isDimension = vlFieldDef.isDimension;\nvar util = require('../util');\n\nvar consts = require('../consts');\nvar Type = consts.Type;\n\nvar genMarks = module.exports = getMarks;\n\nvar marksRule = genMarks.rule = {\n  point:  pointRule,\n  bar:    barRule,\n  line:   lineRule,\n  area:   areaRule, // area is similar to line\n  text:   textRule,\n  tick:   tickRule\n};\n\nfunction getMarks(encoding, stats, opt) {\n  return opt.markList.filter(function(mark){\n    return genMarks.satisfyRules(encoding, mark, stats, opt);\n  });\n}\n\ngenMarks.satisfyRules = function (encoding, mark, stats, opt) {\n  return vlValidate.getEncodingMappingError({\n      mark: mark,\n      encoding: encoding\n    }) === null &&\n    (!marksRule[mark] || marksRule[mark](encoding, stats, opt));\n};\n\nfunction facetRule(fieldDef, stats, opt) {\n  return vlFieldDef.cardinality(fieldDef, stats) <= opt.maxCardinalityForFacets;\n}\n\nfunction facetsRule(encoding, stats, opt) {\n  if(encoding.row && !facetRule(encoding.row, stats, opt)) return false;\n  if(encoding.column && !facetRule(encoding.column, stats, opt)) return false;\n  return true;\n}\n\nfunction pointRule(encoding, stats, opt) {\n  if(!facetsRule(encoding, stats, opt)) return false;\n  if (encoding.x && encoding.y) {\n    // have both x & y ==> scatter plot / bubble plot\n\n    var xIsDim = isDimension(encoding.x),\n      yIsDim = isDimension(encoding.y);\n\n    // For OxO\n    if (xIsDim && yIsDim) {\n      // shape doesn't work with both x, y as ordinal\n      if (encoding.shape) {\n        return false;\n      }\n\n      // TODO(kanitw): check that there is quant at least ...\n      if (encoding.color && isDimension(encoding.color)) {\n        return false;\n      }\n    }\n\n  } else { // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && encoding.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && util.keys(encoding).length > 1) return false;\n\n    // dot plot with shape is non-sense\n    if (encoding.shape) return false;\n  }\n  return true;\n}\n\nfunction tickRule(encoding, stats, opt) {\n  // jshint unused:false\n  if (encoding.x || encoding.y) {\n    if(vlEncoding.isAggregate(encoding)) return false;\n\n    var xIsDim = isDimension(encoding.x),\n      yIsDim = isDimension(encoding.y);\n\n    return (!xIsDim && (!encoding.y || yIsDim)) ||\n      (!yIsDim && (!encoding.x || xIsDim));\n  }\n  return false;\n}\n\nfunction barRule(encoding, stats, opt) {\n  if(!facetsRule(encoding, stats, opt)) return false;\n\n  // bar requires at least x or y\n  if (!encoding.x && !encoding.y) return false;\n\n  if (opt.omitSizeOnBar && encoding.size !== undefined) return false;\n\n  // FIXME actually check if there would be occlusion #90\n  // need to aggregate on either x or y\n  var aggEitherXorY =\n    (!encoding.x || encoding.x.aggregate === undefined) ^\n    (!encoding.y || encoding.y.aggregate === undefined);\n\n\n  if (aggEitherXorY) {\n    var eitherXorYisDimOrNull =\n      (!encoding.x || isDimension(encoding.x)) ^\n      (!encoding.y || isDimension(encoding.y));\n\n    if (eitherXorYisDimOrNull) {\n      var aggregate = encoding.x.aggregate || encoding.y.aggregate;\n      return !(opt.omitStackedAverage && aggregate ==='mean' && encoding.color);\n    }\n  }\n\n  return false;\n}\n\nfunction lineRule(encoding, stats, opt) {\n  if(!facetsRule(encoding, stats, opt)) return false;\n\n  // TODO(kanitw): add omitVerticalLine as config\n\n  // FIXME truly ordinal data is fine here too.\n  // Line chart should be only horizontal\n  // and use only temporal data\n  return encoding.x.type == Type.Temporal && encoding.x.timeUnit && encoding.y.type == Type.Quantitative && encoding.y.aggregate;\n}\n\nfunction areaRule(encoding, stats, opt) {\n  if(!facetsRule(encoding, stats, opt)) return false;\n\n  if(!lineRule(encoding, stats, opt)) return false;\n\n  return !(opt.omitStackedAverage && encoding.y.aggregate ==='mean' && encoding.color);\n}\n\nfunction textRule(encoding, stats, opt) {\n  // at least must have row or column and aggregated text values\n  return (encoding.row || encoding.column) && encoding.text && encoding.text.aggregate && !encoding.x && !encoding.y && !encoding.size &&\n    (!opt.alwaysGenerateTableAsHeatmap || !encoding.color);\n}\n\n},{\"../consts\":9,\"../util\":19,\"vega-lite/src/encoding\":34,\"vega-lite/src/fielddef\":35,\"vega-lite/src/validate\":57}],15:[function(require,module,exports){\n'use strict';\n\nvar vlFieldDef = require('vega-lite/src/fielddef');\nvar vlSchemaUtil = require('vega-lite/src/schema/schemautil');\n\nvar util = require('../util'),\n  consts = require('../consts'),\n  isDimension = vlFieldDef.isDimension;\n\nmodule.exports = projections;\n\n// TODO support other mode of projections generation\n// powerset, chooseK, chooseKorLess are already included in the util\n\n/**\n * fields\n * @param  {[type]} fieldDefs array of fields and query information\n * @return {[type]}        [description]\n */\nfunction projections(fieldDefs, stats, opt) {\n  opt = vlSchemaUtil.extend(opt||{}, consts.gen.projections);\n\n  // First categorize field, selected, fieldsToAdd, and save indices\n  var selected = [], fieldsToAdd = [], fieldSets = [],\n    hasSelectedDimension = false,\n    hasSelectedMeasure = false,\n    indices = {};\n\n  fieldDefs.forEach(function(fieldDef, index){\n    //save indices for stable sort later\n    indices[fieldDef.field] = index;\n\n    if (fieldDef.selected) {\n      selected.push(fieldDef);\n      if (isDimension(fieldDef) || fieldDef.type ==='temporal') { // FIXME / HACK\n        hasSelectedDimension = true;\n      } else {\n        hasSelectedMeasure = true;\n      }\n    } else if (fieldDef.selected !== false && !vlFieldDef.isCount(fieldDef)) {\n      if (vlFieldDef.isDimension(fieldDef) &&\n          !opt.maxCardinalityForAutoAddOrdinal &&\n          vlFieldDef.cardinality(fieldDef, stats, 15) > opt.maxCardinalityForAutoAddOrdinal\n        ) {\n        return;\n      }\n      fieldsToAdd.push(fieldDef);\n    }\n  });\n\n  fieldsToAdd.sort(compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices));\n\n  var setsToAdd = util.chooseKorLess(fieldsToAdd, 1);\n\n  setsToAdd.forEach(function(setToAdd) {\n    var fieldSet = selected.concat(setToAdd);\n    if (fieldSet.length > 0) {\n      if (opt.omitDotPlot && fieldSet.length === 1) return;\n      fieldSets.push(fieldSet);\n    }\n  });\n\n  fieldSets.forEach(function(fieldSet) {\n      // always append projection's key to each projection returned, d3 style.\n    fieldSet.key = projections.key(fieldSet);\n  });\n\n  return fieldSets;\n}\n\nvar typeIsMeasureScore = {\n  nominal: 0,\n  ordinal: 0,\n  temporal: 2,\n  quantitative: 3\n};\n\nfunction compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices) {\n  return function(a, b){\n    // sort by type of the data\n    if (a.type !== b.type) {\n      if (!hasSelectedDimension) {\n        return typeIsMeasureScore[a.type] - typeIsMeasureScore[b.type];\n      } else { //if (!hasSelectedMeasure) {\n        return typeIsMeasureScore[b.type] - typeIsMeasureScore[a.type];\n      }\n    }\n    //make the sort stable\n    return indices[a.field] - indices[b.field];\n  };\n}\n\nprojections.key = function(projection) {\n  return projection.map(function(fieldDef) {\n    return vlFieldDef.isCount(fieldDef) ? 'count' : fieldDef.field;\n  }).join(',');\n};\n\n\n},{\"../consts\":9,\"../util\":19,\"vega-lite/src/fielddef\":35,\"vega-lite/src/schema/schemautil\":50}],16:[function(require,module,exports){\n'use strict';\n\nvar vlFieldDef = require('vega-lite/src/fielddef');\nvar vlSchemaUtil = require('vega-lite/src/schema/schemautil');\nvar util = require('../util');\n\nvar genEncodings = require('./encodings'),\n  getMarks = require('./marks'),\n  rank = require('../rank/rank'),\n  consts = require('../consts');\n\nmodule.exports = genSpecsFromFieldDefs;\n\n/** Design Encodings for a set of field definition */\n\nfunction genSpecsFromFieldDefs(output, fieldDefs, stats, opt, nested) {\n  // opt must be augmented before being passed to genEncodings or getMarks\n  opt = vlSchemaUtil.extend(opt||{}, consts.gen.encodings);\n  var encodings = genEncodings([], fieldDefs, stats, opt);\n\n  if (nested) {\n    return encodings.reduce(function(dict, encoding) {\n      dict[encoding] = genSpecsFromEncodings([], encoding, stats, opt);\n      return dict;\n    }, {});\n  } else {\n    return encodings.reduce(function(list, encoding) {\n      return genSpecsFromEncodings(list, encoding, stats, opt);\n    }, []);\n  }\n}\n\nfunction genSpecsFromEncodings(output, encoding, stats, opt) {\n  getMarks(encoding, stats, opt)\n    .forEach(function(mark) {\n      var spec = util.duplicate({\n          // Clone config & encoding to unique objects\n          encoding: encoding,\n          config: opt.config\n        });\n\n      spec.mark = mark;\n      // Data object is the same across charts: pass by reference\n      spec.data = opt.data;\n\n      spec = finalTouch(spec, stats, opt);\n      var score = rank.encoding(spec, stats, opt);\n\n      spec._info = score;\n      output.push(spec);\n    });\n  return output;\n}\n\n//FIXME this should be refactors\nfunction finalTouch(spec, stats, opt) {\n  if (spec.mark === 'text' && opt.alwaysGenerateTableAsHeatmap) {\n    spec.encoding.color = spec.encoding.text;\n  }\n\n  // don't include zero if stdev/mean < 0.01\n  // https://github.com/uwdata/visrec/issues/69\n  var encoding = spec.encoding;\n  ['x', 'y'].forEach(function(channel) {\n    var fieldDef = encoding[channel];\n\n    // TODO add a parameter for this case\n    if (fieldDef && vlFieldDef.isMeasure(fieldDef) && !vlFieldDef.isCount(fieldDef)) {\n      var stat = stats[fieldDef.field];\n      if (stat && stat.stdev / stat.mean < 0.01) {\n        fieldDef.scale = {zero: false};\n      }\n    }\n  });\n  return spec;\n}\n\n},{\"../consts\":9,\"../rank/rank\":17,\"../util\":19,\"./encodings\":12,\"./marks\":14,\"vega-lite/src/fielddef\":35,\"vega-lite/src/schema/schemautil\":50}],17:[function(require,module,exports){\nmodule.exports = {\n  encoding: require('./rankEncodings')\n};\n\n\n\n},{\"./rankEncodings\":18}],18:[function(require,module,exports){\n// FIXME: rename to rankSpecs\n\n'use strict';\n\nvar vlEncoding = require('vega-lite/src/encoding'),\n  vlFieldDef = require('vega-lite/src/fielddef'),\n  vlChannel = require('vega-lite/src/channel'),\n  isDimension = vlFieldDef.isDimension,\n  util = require('../util');\n\nvar vlShorthand = require('vega-lite/src/shorthand');\n\nvar consts = require('../consts');\nvar Type = consts.Type;\n\nmodule.exports = rankEncodings;\n\n// bad score not specified in the table above\nvar UNUSED_POSITION = 0.5;\n\nvar MARK_SCORE = {\n  line: 0.99,\n  area: 0.98,\n  bar: 0.97,\n  tick: 0.96,\n  point: 0.95,\n  circle: 0.94,\n  square: 0.94,\n  text: 0.8\n};\n\nfunction rankEncodings(spec, stats, opt, selected) {\n  var features = [],\n    channels = util.keys(spec.encoding),\n    mark = spec.mark,\n    encoding = spec.encoding;\n\n  var encodingMappingByField = vlEncoding.reduce(spec.encoding, function(o, fieldDef, channel) {\n    var key = vlShorthand.shortenFieldDef(fieldDef);\n    var mappings = o[key] = o[key] || [];\n    mappings.push({channel: channel, fieldDef: fieldDef});\n    return o;\n  }, {});\n\n  // data - encoding mapping score\n  util.forEach(encodingMappingByField, function(mappings) {\n    var reasons = mappings.map(function(m) {\n        return m.channel + vlShorthand.Assign + vlShorthand.shortenFieldDef(m.fieldDef) +\n          ' ' + (selected && selected[m.fieldDef.field] ? '[x]' : '[ ]');\n      }),\n      scores = mappings.map(function(m) {\n        var role = vlFieldDef.isDimension(m.fieldDef) ? 'dimension' : 'measure';\n\n        var score = rankEncodings.score[role](m.fieldDef, m.channel, spec.mark, stats, opt);\n\n        return !selected || selected[m.fieldDef.field] ? score : Math.pow(score, 0.125);\n      });\n\n    features.push({\n      reason: reasons.join(\" | \"),\n      score: Math.max.apply(null, scores)\n    });\n  });\n\n  // plot type\n  if (mark === 'text') {\n    // TODO\n  } else {\n    if (encoding.x && encoding.y) {\n      if (isDimension(encoding.x) ^ isDimension(encoding.y)) {\n        features.push({\n          reason: 'OxQ plot',\n          score: 0.8\n        });\n      }\n    }\n  }\n\n  // penalize not using positional only penalize for non-text\n  if (channels.length > 1 && mark !== 'text') {\n    if ((!encoding.x || !encoding.y) && !encoding.geo && !encoding.text) {\n      features.push({\n        reason: 'unused position',\n        score: UNUSED_POSITION\n      });\n    }\n  }\n\n  // mark type score\n  features.push({\n    reason: 'mark='+mark,\n    score: MARK_SCORE[mark]\n  });\n\n  return {\n    score: features.reduce(function(p, f) {\n      return p * f.score;\n    }, 1),\n    features: features\n  };\n}\n\n\nvar D = {}, M = {}, BAD = 0.1, TERRIBLE = 0.01;\n\nD.minor = 0.01;\nD.pos = 1;\nD.Y_T = 0.8;\nD.facet_text = 1;\nD.facet_good = 0.675; // < color_ok, > color_bad\nD.facet_ok = 0.55;\nD.facet_bad = 0.4;\nD.color_good = 0.7;\nD.color_ok = 0.65; // > M.Size\nD.color_bad = 0.3;\nD.color_stack = 0.6;\nD.shape = 0.6;\nD.detail = 0.5;\nD.bad = BAD;\nD.terrible = TERRIBLE;\n\nM.pos = 1;\nM.size = 0.6;\nM.color = 0.5;\nM.text = 0.4;\nM.bad = BAD;\nM.terrible = TERRIBLE;\n\nrankEncodings.dimensionScore = function (fieldDef, channel, mark, stats, opt){\n  var cardinality = vlFieldDef.cardinality(fieldDef, stats);\n  switch (channel) {\n    case vlChannel.X:\n      if (fieldDef.type === Type.Nominal || fieldDef.type === Type.Ordinal)  {\n        return D.pos - D.minor;\n      }\n      return D.pos;\n\n    case vlChannel.Y:\n      if (fieldDef.type === Type.Nominal || fieldDef.type === Type.Ordinal) {\n        return D.pos - D.minor; //prefer ordinal on y\n      }\n      if (fieldDef.type === Type.Temporal) {\n        return D.Y_T; // time should not be on Y\n      }\n      return D.pos - D.minor;\n\n    case vlChannel.COL:\n      if (mark === 'text') return D.facet_text;\n      //prefer column over row due to scrolling issues\n      return cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad;\n\n    case vlChannel.ROW:\n      if (mark === 'text') return D.facet_text;\n      return (cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad) - D.minor;\n\n    case vlChannel.COLOR:\n      var hasOrder = (fieldDef.bin && fieldDef.type=== Type.Quantitative) || (fieldDef.timeUnit && fieldDef.type=== Type.Temporal);\n\n      //FIXME add stacking option once we have control ..\n      var isStacked = mark === 'bar' || mark === 'area';\n\n      // true ordinal on color is currently BAD (until we have good ordinal color scale support)\n      if (hasOrder) return D.color_bad;\n\n      //stacking gets lower score\n      if (isStacked) return D.color_stack;\n\n      return cardinality <= opt.maxGoodCardinalityForColor ? D.color_good: cardinality <= opt.maxCardinalityForColor ? D.color_ok : D.color_bad;\n    case vlChannel.SHAPE:\n      return cardinality <= opt.maxCardinalityForShape ? D.shape : TERRIBLE;\n    case vlChannel.DETAIL:\n      return D.detail;\n  }\n  return TERRIBLE;\n};\n\nrankEncodings.dimensionScore.consts = D;\n\nrankEncodings.measureScore = function (fieldDef, channel, mark, stats, opt) {\n  // jshint unused:false\n  switch (channel){\n    case vlChannel.X: return M.pos;\n    case vlChannel.Y: return M.pos;\n    case vlChannel.SIZE:\n      if (mark === 'bar') return BAD; //size of bar is very bad\n      if (mark === 'text') return BAD;\n      if (mark === 'line') return BAD;\n      return M.size;\n    case vlChannel.COLOR: return M.color;\n    case vlChannel.TEXT: return M.text;\n  }\n  return BAD;\n};\n\nrankEncodings.measureScore.consts = M;\n\n\nrankEncodings.score = {\n  dimension: rankEncodings.dimensionScore,\n  measure: rankEncodings.measureScore,\n};\n\n},{\"../consts\":9,\"../util\":19,\"vega-lite/src/channel\":29,\"vega-lite/src/encoding\":34,\"vega-lite/src/fielddef\":35,\"vega-lite/src/shorthand\":52}],19:[function(require,module,exports){\n\"use strict\";\n\nvar consts = require('./consts');\n\nvar util = module.exports = {\n  gen: {}\n};\n\n// FIXME: remove redundant methods\n\nutil.isArray = Array.isArray || function (obj) {\n  return {}.toString.call(obj) == '[object Array]';\n};\n\nutil.isin = function (item, array) {\n    return array.indexOf(item) !== -1;\n};\n\nutil.json = function(s, sp) {\n  return JSON.stringify(s, null, sp);\n};\n\nutil.keys = function(obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n};\n\nutil.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  }\n  else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k, obj);\n    }\n  }\n};\n\nutil.any = function (arr, f) {\n    var i = 0, k;\n    for (k in arr) {\n        if (f(arr[k], k, i++))\n            return true;\n    }\n    return false;\n};\n\nutil.nestedMap = function (collection, f, level, filter) {\n  return level === 0 ?\n    collection.map(f) :\n    collection.map(function(v) {\n      var r = util.nestedMap(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nestedReduce = function (collection, f, level, filter) {\n  return level === 0 ?\n    collection.reduce(f, []) :\n    collection.map(function(v) {\n      var r = util.nestedReduce(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nonEmpty = function(grp) {\n  return !util.isArray(grp) || grp.length > 0;\n};\n\n\nutil.traverse = function (node, arr) {\n  if (node.value !== undefined) {\n    arr.push(node.value);\n  } else {\n    if (node.left) util.traverse(node.left, arr);\n    if (node.right) util.traverse(node.right, arr);\n  }\n  return arr;\n};\n\nutil.union = function (a, b) {\n  var o = {};\n  a.forEach(function(x) { o[x] = true;});\n  b.forEach(function(x) { o[x] = true;});\n  return util.keys(o);\n};\n\n\nutil.gen.getOpt = function (opt) {\n  //merge with default\n  return (opt ? util.keys(opt) : []).reduce(function(c, k) {\n    c[k] = opt[k];\n    return c;\n  }, Object.create(consts.gen.DEFAULT_OPT));\n};\n\n/**\n * powerset code from http://rosettacode.org/wiki/Power_Set#JavaScript\n *\n *   var res = powerset([1,2,3,4]);\n *\n * returns\n *\n * [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],\n * [2,4],[1,2,4],[3,4],[1,3,4],[2,3,4],[1,2,3,4]]\n[edit]\n*/\n\nutil.powerset = function(list) {\n  var ps = [\n    []\n  ];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = ps.length; j < len; j++) {\n      ps.push(ps[j].concat(list[i]));\n    }\n  }\n  return ps;\n};\n\nutil.chooseKorLess = function(list, k) {\n  var subset = [[]];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length <= k){\n        subset.push(sub);\n      }\n    }\n  }\n  return subset;\n};\n\nutil.chooseK = function(list, k) {\n  var subset = [[]];\n  var kArray =[];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length < k){\n        subset.push(sub);\n      }else if (sub.length === k){\n        kArray.push(sub);\n      }\n    }\n  }\n  return kArray;\n};\n\nutil.cross = function(a,b){\n  var x = [];\n  for(var i=0; i< a.length; i++){\n    for(var j=0;j< b.length; j++){\n      x.push(a[i].concat(b[j]));\n    }\n  }\n  return x;\n};\n\n\n},{\"./consts\":9}],20:[function(require,module,exports){\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('d3-time', ['exports'], factory) :\n  factory((global.d3_time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t0 = new Date;\n  var t1 = new Date;\n  function newInterval(floori, offseti, count, field) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) {\n      interval.count = function(start, end) {\n        t0.setTime(+start), t1.setTime(+end);\n        floori(t0), floori(t1);\n        return Math.floor(count(t0, t1));\n      };\n\n      interval.every = function(step) {\n        step = Math.floor(step);\n        return !isFinite(step) || !(step > 0) ? null\n            : !(step > 1) ? interval\n            : interval.filter(field\n                ? function(d) { return field(d) % step === 0; }\n                : function(d) { return interval.count(0, d) % step === 0; });\n      };\n    }\n\n    return interval;\n  };\n\n  var millisecond = newInterval(function() {\n    // noop\n  }, function(date, step) {\n    date.setTime(+date + step);\n  }, function(start, end) {\n    return end - start;\n  });\n\n  // An optimized implementation for this simple case.\n  millisecond.every = function(k) {\n    k = Math.floor(k);\n    if (!isFinite(k) || !(k > 0)) return null;\n    if (!(k > 1)) return millisecond;\n    return newInterval(function(date) {\n      date.setTime(Math.floor(date / k) * k);\n    }, function(date, step) {\n      date.setTime(+date + step * k);\n    }, function(start, end) {\n      return (end - start) / k;\n    });\n  };\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getSeconds();\n  });\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getMinutes();\n  });\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getHours();\n  });\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  }, function(date) {\n    return date.getDate() - 1;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n  var tuesday = weekday(2);\n  var wednesday = weekday(3);\n  var thursday = weekday(4);\n  var friday = weekday(5);\n  var saturday = weekday(6);\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  }, function(date) {\n    return date.getMonth();\n  });\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  }, function(date) {\n    return date.getFullYear();\n  });\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getUTCSeconds();\n  });\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getUTCMinutes();\n  });\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getUTCHours();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  }, function(date) {\n    return date.getUTCDate() - 1;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n  var utcTuesday = utcWeekday(2);\n  var utcWednesday = utcWeekday(3);\n  var utcThursday = utcWeekday(4);\n  var utcFriday = utcWeekday(5);\n  var utcSaturday = utcWeekday(6);\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  }, function(date) {\n    return date.getUTCMonth();\n  });\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  }, function(date) {\n    return date.getUTCFullYear();\n  });\n\n  var milliseconds = millisecond.range;\n  var seconds = second.range;\n  var minutes = minute.range;\n  var hours = hour.range;\n  var days = day.range;\n  var sundays = sunday.range;\n  var mondays = monday.range;\n  var tuesdays = tuesday.range;\n  var wednesdays = wednesday.range;\n  var thursdays = thursday.range;\n  var fridays = friday.range;\n  var saturdays = saturday.range;\n  var weeks = sunday.range;\n  var months = month.range;\n  var years = year.range;\n\n  var utcMillisecond = millisecond;\n  var utcMilliseconds = milliseconds;\n  var utcSeconds = utcSecond.range;\n  var utcMinutes = utcMinute.range;\n  var utcHours = utcHour.range;\n  var utcDays = utcDay.range;\n  var utcSundays = utcSunday.range;\n  var utcMondays = utcMonday.range;\n  var utcTuesdays = utcTuesday.range;\n  var utcWednesdays = utcWednesday.range;\n  var utcThursdays = utcThursday.range;\n  var utcFridays = utcFriday.range;\n  var utcSaturdays = utcSaturday.range;\n  var utcWeeks = utcSunday.range;\n  var utcMonths = utcMonth.range;\n  var utcYears = utcYear.range;\n\n  var version = \"0.1.0\";\n\n  exports.version = version;\n  exports.milliseconds = milliseconds;\n  exports.seconds = seconds;\n  exports.minutes = minutes;\n  exports.hours = hours;\n  exports.days = days;\n  exports.sundays = sundays;\n  exports.mondays = mondays;\n  exports.tuesdays = tuesdays;\n  exports.wednesdays = wednesdays;\n  exports.thursdays = thursdays;\n  exports.fridays = fridays;\n  exports.saturdays = saturdays;\n  exports.weeks = weeks;\n  exports.months = months;\n  exports.years = years;\n  exports.utcMillisecond = utcMillisecond;\n  exports.utcMilliseconds = utcMilliseconds;\n  exports.utcSeconds = utcSeconds;\n  exports.utcMinutes = utcMinutes;\n  exports.utcHours = utcHours;\n  exports.utcDays = utcDays;\n  exports.utcSundays = utcSundays;\n  exports.utcMondays = utcMondays;\n  exports.utcTuesdays = utcTuesdays;\n  exports.utcWednesdays = utcWednesdays;\n  exports.utcThursdays = utcThursdays;\n  exports.utcFridays = utcFridays;\n  exports.utcSaturdays = utcSaturdays;\n  exports.utcWeeks = utcWeeks;\n  exports.utcMonths = utcMonths;\n  exports.utcYears = utcYears;\n  exports.millisecond = millisecond;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.sunday = sunday;\n  exports.monday = monday;\n  exports.tuesday = tuesday;\n  exports.wednesday = wednesday;\n  exports.thursday = thursday;\n  exports.friday = friday;\n  exports.saturday = saturday;\n  exports.week = sunday;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcSunday = utcSunday;\n  exports.utcMonday = utcMonday;\n  exports.utcTuesday = utcTuesday;\n  exports.utcWednesday = utcWednesday;\n  exports.utcThursday = utcThursday;\n  exports.utcFriday = utcFriday;\n  exports.utcSaturday = utcSaturday;\n  exports.utcWeek = utcSunday;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n  exports.interval = newInterval;\n\n}));\n},{}],21:[function(require,module,exports){\nvar util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n\n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n\n},{\"../time\":25,\"../util\":26}],22:[function(require,module,exports){\nvar gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x >= min && x <= max) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    return x < min ? 0 : x > max ? 1 : (x - min) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? min + p*d : NaN;\n  };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x === Math.floor(x) && x >= a && x < b) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    var v = Math.floor(x);\n    return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? a - 1 + Math.floor(p*d) : NaN;\n  };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    var exp = Math.exp(Math.pow(x-mean, 2) / (-2 * Math.pow(stdev, 2)));\n    return (1 / (stdev * Math.sqrt(2*Math.PI))) * exp;\n  };\n  f.cdf = function(x) {\n    // Approximation from West (2009)\n    // Better Approximations to Cumulative Normal Functions\n    var cd,\n        z = (x - mean) / stdev,\n        Z = Math.abs(z);\n    if (Z > 37) {\n      cd = 0;\n    } else {\n      var sum, exp = Math.exp(-Z*Z/2);\n      if (Z < 7.07106781186547) {\n        sum = 3.52624965998911e-02 * Z + 0.700383064443688;\n        sum = sum * Z + 6.37396220353165;\n        sum = sum * Z + 33.912866078383;\n        sum = sum * Z + 112.079291497871;\n        sum = sum * Z + 221.213596169931;\n        sum = sum * Z + 220.206867912376;\n        cd = exp * sum;\n        sum = 8.83883476483184e-02 * Z + 1.75566716318264;\n        sum = sum * Z + 16.064177579207;\n        sum = sum * Z + 86.7807322029461;\n        sum = sum * Z + 296.564248779674;\n        sum = sum * Z + 637.333633378831;\n        sum = sum * Z + 793.826512519948;\n        sum = sum * Z + 440.413735824752;\n        cd = cd / sum;\n      } else {\n        sum = Z + 0.65;\n        sum = Z + 4 / sum;\n        sum = Z + 3 / sum;\n        sum = Z + 2 / sum;\n        sum = Z + 1 / sum;\n        cd = exp / sum / 2.506628274631;\n      }\n    }\n    return z > 0 ? 1 - cd : cd;\n  };\n  f.icdf = function(p) {\n    // Approximation of Probit function using inverse error function.\n    if (p <= 0 || p >= 1) return NaN;\n    var x = 2*p - 1,\n        v = (8 * (Math.PI - 3)) / (3 * Math.PI * (4-Math.PI)),\n        a = (2 / (Math.PI*v)) + (Math.log(1 - Math.pow(x,2)) / 2),\n        b = Math.log(1 - (x*x)) / v,\n        s = (x > 0 ? 1 : -1) * Math.sqrt(Math.sqrt((a*a) - b) - a);\n    return mean + stdev * Math.SQRT2 * s;\n  };\n  return f;\n};\n},{}],23:[function(require,module,exports){\nvar util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n\n},{\"../util\":26}],24:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\n\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Compute the Cohen's d effect size between two arrays of numbers.\nstats.cohensd = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      x1 = stats.mean(X),\n      x2 = stats.mean(Y),\n      n1 = stats.count.valid(X),\n      n2 = stats.count.valid(Y);\n\n  if ((n1+n2-2) <= 0) {\n    // if both arrays are size 1, or one is empty, there's no effect size\n    return 0;\n  }\n  // pool standard deviation\n  var s1 = stats.variance(X),\n      s2 = stats.variance(Y),\n      s = Math.sqrt((((n1-1)*s1) + ((n2-1)*s2)) / (n1+n2-2));\n  // if there is no variance, there's no effect size\n  return s===0 ? 0 : (x1 - x2) / s;\n};\n\n// Computes the covariance between two arrays of numbers\nstats.covariance = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n = X.length,\n      xm = stats.mean(X),\n      ym = stats.mean(Y),\n      sum = 0, c = 0, i, x, y, vx, vy;\n\n  if (n !== Y.length) {\n    throw Error('Input lengths must match.');\n  }\n\n  for (i=0; i<n; ++i) {\n    x = X[i]; vx = util.isValid(x);\n    y = Y[i]; vy = util.isValid(y);\n    if (vx && vy) {\n      sum += (x-xm) * (y-ym);\n      ++c;\n    } else if (vx || vy) {\n      throw Error('Valid values must align.');\n    }\n  }\n  return sum / (c-1);\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Simple linear regression.\n// Returns a \"fit\" object with slope (m), intercept (b),\n// r value (R), and sum-squared residual error (rss).\nstats.linearRegression = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n = X.length,\n      xy = stats.covariance(X, Y), // will throw err if valid vals don't align\n      sx = stats.stdev(X),\n      sy = stats.stdev(Y),\n      slope = xy / (sx*sx),\n      icept = stats.mean(Y) - slope * stats.mean(X),\n      fit = {slope: slope, intercept: icept, R: xy / (sx*sy), rss: 0},\n      res, i;\n\n  for (i=0; i<n; ++i) {\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\n      res = (slope*X[i] + icept) - Y[i];\n      fit.rss += res * res;\n    }\n  }\n\n  return fit;\n};\n\n// Namespace for z-tests\nstats.z = {};\n\n// Construct a z-confidence interval at a given significance level\n// Arguments are an array and an optional alpha (defaults to 0.05).\nstats.z.ci = function(a, alpha) {\n  var z = alpha ? gen.random.normal(0, 1).icdf(1-(alpha/2)) : 1.96,\n      mu = stats.mean(a),\n      SE = stats.stdev(a) / Math.sqrt(stats.count.valid(a));\n  return [mu - (z*SE), mu + (z*SE)];\n};\n\n// Perform a z-test of means. Returns the p-value.\n// Assuming we have a list of values, and a null hypothesis. If no null\n// hypothesis, assume our null hypothesis is mu=0.\n// http://en.wikipedia.org/wiki/Z-test\nstats.z.test = function(a, b) {\n  var nullH = b ? b : 0,\n      gaussian = gen.random.normal(0, 1),\n      mu = stats.mean(a),\n      SE = stats.stdev(a) / Math.sqrt(stats.count.valid(a));\n\n  if (SE===0) {\n    // Test not well defined when standard error is 0.\n    return (mu - nullH) === 0 ? 1 : 0;\n  }\n  // Two-sided, so twice the one-sided cdf.\n  var z = (mu - nullH) / SE;\n  return 2 * gaussian.cdf(-Math.abs(z));\n};\n\n// Perform a two sample paired z-test of means. Returns the p-value.\n// http://en.wikipedia.org/wiki/Paired_difference_test\nstats.z.pairedTest = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n1 = stats.count(X),\n      n2 = stats.count(Y),\n      diffs = Array(), i;\n\n  if (n1 !== n2) {\n    throw Error('Array lengths must match.');\n  }\n  for (i=0; i<n1; ++i) {\n    // Only valid differences should contribute to the test statistic\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\n      diffs.push(X[i] - Y[i]);\n    }\n  }\n  return stats.z.test(diffs);\n};\n\n// Perform a two sample z-test of means. Returns the p-value.\n// http://en.wikipedia.org/wiki/Z-test\nstats.z.twoSampleTest = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n1 = stats.count.valid(X),\n      n2 = stats.count.valid(Y),\n      gaussian = gen.random.normal(0, 1),\n      meanDiff = stats.mean(X) - stats.mean(Y),\n      SE = Math.sqrt(stats.variance(X)/n1 + stats.variance(Y)/n2);\n\n  if (SE===0) {\n    // Not well defined when pooled standard error is 0.\n    return meanDiff===0 ? 1 : 0;\n  }\n  // Two-tailed, so twice the one-sided cdf.\n  var z = meanDiff / SE;\n  return 2 * gaussian.cdf(-Math.abs(z));\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance]\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;\n\n},{\"./generate\":22,\"./import/type\":23,\"./util\":26}],25:[function(require,module,exports){\nvar d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);\n\n},{\"d3-time\":20}],26:[function(require,module,exports){\nvar buffer = require('buffer'),\n    time = require('./time'),\n    utc = time.utc;\n\nvar u = module.exports = {};\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (buffer.Buffer && buffer.Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\n// parse a date with optional d3.time-format format\nu.date = function(s, format) {\n  var d = format ? format : Date;\n  return s == null || s === '' ? null : d.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\nu.$year   = u.$func('year', time.year.unit);\nu.$month  = u.$func('month', time.months.unit);\nu.$date   = u.$func('date', time.dates.unit);\nu.$day    = u.$func('day', time.weekdays.unit);\nu.$hour   = u.$func('hour', time.hours.unit);\nu.$minute = u.$func('minute', time.minutes.unit);\nu.$second = u.$func('second', time.seconds.unit);\n\nu.$utcYear   = u.$func('utcYear', utc.year.unit);\nu.$utcMonth  = u.$func('utcMonth', utc.months.unit);\nu.$utcDate   = u.$func('utcDate', utc.dates.unit);\nu.$utcDay    = u.$func('utcDay', utc.weekdays.unit);\nu.$utcHour   = u.$func('utcHour', utc.hours.unit);\nu.$utcMinute = u.$func('utcMinute', utc.minutes.unit);\nu.$utcSecond = u.$func('utcSecond', utc.seconds.unit);\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n},{\"./time\":25,\"buffer\":1}],27:[function(require,module,exports){\nexports.AGGREGATE_OPS = [\r\n    'values', 'count', 'valid', 'missing', 'distinct',\r\n    'sum', 'mean', 'average', 'variance', 'variancep', 'stdev',\r\n    'stdevp', 'median', 'q1', 'q3', 'modeskew', 'min', 'max',\r\n    'argmin', 'argmax'\r\n];\r\nexports.SHARED_DOMAIN_OPS = [\r\n    'mean', 'average', 'stdev', 'stdevp', 'median', 'q1', 'q3', 'min', 'max'\r\n];\r\n\n},{}],28:[function(require,module,exports){\nexports.MAXBINS_DEFAULT = 15;\r\n\n},{}],29:[function(require,module,exports){\n(function (Channel) {\r\n    Channel[Channel[\"X\"] = 'x'] = \"X\";\r\n    Channel[Channel[\"Y\"] = 'y'] = \"Y\";\r\n    Channel[Channel[\"ROW\"] = 'row'] = \"ROW\";\r\n    Channel[Channel[\"COLUMN\"] = 'column'] = \"COLUMN\";\r\n    Channel[Channel[\"SHAPE\"] = 'shape'] = \"SHAPE\";\r\n    Channel[Channel[\"SIZE\"] = 'size'] = \"SIZE\";\r\n    Channel[Channel[\"COLOR\"] = 'color'] = \"COLOR\";\r\n    Channel[Channel[\"TEXT\"] = 'text'] = \"TEXT\";\r\n    Channel[Channel[\"DETAIL\"] = 'detail'] = \"DETAIL\";\r\n})(exports.Channel || (exports.Channel = {}));\r\nvar Channel = exports.Channel;\r\nexports.X = Channel.X;\r\nexports.Y = Channel.Y;\r\nexports.ROW = Channel.ROW;\r\nexports.COLUMN = Channel.COLUMN;\r\nexports.SHAPE = Channel.SHAPE;\r\nexports.SIZE = Channel.SIZE;\r\nexports.COLOR = Channel.COLOR;\r\nexports.TEXT = Channel.TEXT;\r\nexports.DETAIL = Channel.DETAIL;\r\nexports.CHANNELS = [exports.X, exports.Y, exports.ROW, exports.COLUMN, exports.SIZE, exports.SHAPE, exports.COLOR, exports.TEXT, exports.DETAIL];\r\n;\r\nfunction supportMark(channel, mark) {\r\n    return !!getSupportedMark(channel)[mark];\r\n}\r\nexports.supportMark = supportMark;\r\nfunction getSupportedMark(channel) {\r\n    switch (channel) {\r\n        case exports.X:\r\n        case exports.Y:\r\n            return {\r\n                point: true, tick: true, circle: true, square: true,\r\n                bar: true, line: true, area: true\r\n            };\r\n        case exports.ROW:\r\n        case exports.COLUMN:\r\n            return {\r\n                point: true, tick: true, circle: true, square: true,\r\n                bar: true, line: true, area: true, text: true\r\n            };\r\n        case exports.SIZE:\r\n            return {\r\n                point: true, tick: true, circle: true, square: true,\r\n                bar: true, text: true\r\n            };\r\n        case exports.COLOR:\r\n        case exports.DETAIL:\r\n            return {\r\n                point: true, tick: true, circle: true, square: true,\r\n                bar: true, line: true, area: true, text: true\r\n            };\r\n        case exports.SHAPE:\r\n            return { point: true };\r\n        case exports.TEXT:\r\n            return { text: true };\r\n    }\r\n    return {};\r\n}\r\nexports.getSupportedMark = getSupportedMark;\r\n;\r\nfunction getSupportedRole(channel) {\r\n    switch (channel) {\r\n        case exports.X:\r\n        case exports.Y:\r\n        case exports.COLOR:\r\n            return {\r\n                measure: true,\r\n                dimension: true\r\n            };\r\n        case exports.ROW:\r\n        case exports.COLUMN:\r\n        case exports.SHAPE:\r\n        case exports.DETAIL:\r\n            return {\r\n                measure: false,\r\n                dimension: true\r\n            };\r\n        case exports.SIZE:\r\n        case exports.TEXT:\r\n            return {\r\n                measure: true,\r\n                dimension: false\r\n            };\r\n    }\r\n    throw new Error('Invalid encoding channel' + channel);\r\n}\r\nexports.getSupportedRole = getSupportedRole;\r\n\n},{}],30:[function(require,module,exports){\nvar bin_1 = require('../bin');\r\nvar channel_1 = require('../channel');\r\nvar data_1 = require('../data');\r\nvar vlFieldDef = require('../fielddef');\r\nvar vlEncoding = require('../encoding');\r\nvar layout_1 = require('./layout');\r\nvar mark_1 = require('../mark');\r\nvar schema = require('../schema/schema');\r\nvar schemaUtil = require('../schema/schemautil');\r\nvar type_1 = require('../type');\r\nvar util_1 = require('../util');\r\nvar time = require('./time');\r\nvar Model = (function () {\r\n    function Model(spec, theme) {\r\n        var defaults = schema.instantiate();\r\n        this._spec = schemaUtil.merge(defaults, theme || {}, spec);\r\n        vlEncoding.forEach(this._spec.encoding, function (fieldDef, channel) {\r\n            if (fieldDef.type) {\r\n                fieldDef.type = type_1.getFullName(fieldDef.type);\r\n            }\r\n        });\r\n        this._stack = this.getStackProperties();\r\n        this._layout = layout_1.compileLayout(this);\r\n    }\r\n    Model.prototype.getStackProperties = function () {\r\n        var stackChannel = (this.has(channel_1.COLOR)) ? channel_1.COLOR : (this.has(channel_1.DETAIL)) ? channel_1.DETAIL : null;\r\n        if (stackChannel &&\r\n            (this.is(mark_1.BAR) || this.is(mark_1.AREA)) &&\r\n            this.config('stack') !== false &&\r\n            this.isAggregate()) {\r\n            var isXMeasure = this.isMeasure(channel_1.X);\r\n            var isYMeasure = this.isMeasure(channel_1.Y);\r\n            if (isXMeasure && !isYMeasure) {\r\n                return {\r\n                    groupbyChannel: channel_1.Y,\r\n                    fieldChannel: channel_1.X,\r\n                    stackChannel: stackChannel,\r\n                    config: this.config('stack')\r\n                };\r\n            }\r\n            else if (isYMeasure && !isXMeasure) {\r\n                return {\r\n                    groupbyChannel: channel_1.X,\r\n                    fieldChannel: channel_1.Y,\r\n                    stackChannel: stackChannel,\r\n                    config: this.config('stack')\r\n                };\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    Model.prototype.layout = function () {\r\n        return this._layout;\r\n    };\r\n    Model.prototype.stack = function () {\r\n        return this._stack;\r\n    };\r\n    Model.prototype.toSpec = function (excludeConfig, excludeData) {\r\n        var encoding = util_1.duplicate(this._spec.encoding), spec;\r\n        spec = {\r\n            mark: this._spec.mark,\r\n            encoding: encoding\r\n        };\r\n        if (!excludeConfig) {\r\n            spec.config = util_1.duplicate(this._spec.config);\r\n        }\r\n        if (!excludeData) {\r\n            spec.data = util_1.duplicate(this._spec.data);\r\n        }\r\n        var defaults = schema.instantiate();\r\n        return schemaUtil.subtract(spec, defaults);\r\n    };\r\n    Model.prototype.mark = function () {\r\n        return this._spec.mark;\r\n    };\r\n    Model.prototype.spec = function () {\r\n        return this._spec;\r\n    };\r\n    Model.prototype.is = function (mark) {\r\n        return this._spec.mark === mark;\r\n    };\r\n    Model.prototype.has = function (channel) {\r\n        return this._spec.encoding[channel].field !== undefined;\r\n    };\r\n    Model.prototype.fieldDef = function (channel) {\r\n        return this._spec.encoding[channel];\r\n    };\r\n    Model.prototype.field = function (channel, opt) {\r\n        opt = opt || {};\r\n        var fieldDef = this.fieldDef(channel);\r\n        var f = (opt.datum ? 'datum.' : '') + (opt.prefn || ''), field = fieldDef.field;\r\n        if (vlFieldDef.isCount(fieldDef)) {\r\n            return f + 'count';\r\n        }\r\n        else if (opt.fn) {\r\n            return f + opt.fn + '_' + field;\r\n        }\r\n        else if (!opt.nofn && fieldDef.bin) {\r\n            var binSuffix = opt.binSuffix || '_start';\r\n            return f + 'bin_' + field + binSuffix;\r\n        }\r\n        else if (!opt.nofn && !opt.noAggregate && fieldDef.aggregate) {\r\n            return f + fieldDef.aggregate + '_' + field;\r\n        }\r\n        else if (!opt.nofn && fieldDef.timeUnit) {\r\n            return f + fieldDef.timeUnit + '_' + field;\r\n        }\r\n        else {\r\n            return f + field;\r\n        }\r\n    };\r\n    Model.prototype.fieldTitle = function (channel) {\r\n        if (vlFieldDef.isCount(this._spec.encoding[channel])) {\r\n            return vlFieldDef.COUNT_DISPLAYNAME;\r\n        }\r\n        var fn = this._spec.encoding[channel].aggregate || this._spec.encoding[channel].timeUnit || (this._spec.encoding[channel].bin && 'bin');\r\n        if (fn) {\r\n            return fn.toUpperCase() + '(' + this._spec.encoding[channel].field + ')';\r\n        }\r\n        else {\r\n            return this._spec.encoding[channel].field;\r\n        }\r\n    };\r\n    Model.prototype.bin = function (channel) {\r\n        var bin = this._spec.encoding[channel].bin;\r\n        if (bin === {})\r\n            return false;\r\n        if (bin === true)\r\n            return {\r\n                maxbins: bin_1.MAXBINS_DEFAULT\r\n            };\r\n        return bin;\r\n    };\r\n    Model.prototype.numberFormat = function (channel) {\r\n        return this.config('numberFormat');\r\n    };\r\n    ;\r\n    Model.prototype.map = function (f) {\r\n        return vlEncoding.map(this._spec.encoding, f);\r\n    };\r\n    Model.prototype.reduce = function (f, init) {\r\n        return vlEncoding.reduce(this._spec.encoding, f, init);\r\n    };\r\n    Model.prototype.forEach = function (f) {\r\n        return vlEncoding.forEach(this._spec.encoding, f);\r\n    };\r\n    Model.prototype.isOrdinalScale = function (channel) {\r\n        var fieldDef = this.fieldDef(channel);\r\n        return fieldDef && (util_1.contains([type_1.NOMINAL, type_1.ORDINAL], fieldDef.type) ||\r\n            (fieldDef.type === type_1.TEMPORAL && fieldDef.timeUnit &&\r\n                time.scale.type(fieldDef.timeUnit, channel) === 'ordinal'));\r\n    };\r\n    Model.prototype.isDimension = function (channel) {\r\n        return this.has(channel) &&\r\n            vlFieldDef.isDimension(this.fieldDef(channel));\r\n    };\r\n    Model.prototype.isMeasure = function (channel) {\r\n        return this.has(channel) &&\r\n            vlFieldDef.isMeasure(this.fieldDef(channel));\r\n    };\r\n    Model.prototype.isAggregate = function () {\r\n        return vlEncoding.isAggregate(this._spec.encoding);\r\n    };\r\n    Model.prototype.isFacet = function () {\r\n        return this.has(channel_1.ROW) || this.has(channel_1.COLUMN);\r\n    };\r\n    Model.prototype.dataTable = function () {\r\n        return this.isAggregate() ? data_1.SUMMARY : data_1.SOURCE;\r\n    };\r\n    Model.prototype.data = function () {\r\n        return this._spec.data;\r\n    };\r\n    Model.prototype.hasValues = function () {\r\n        var vals = this.data().values;\r\n        return vals && vals.length;\r\n    };\r\n    Model.prototype.config = function (name) {\r\n        return this._spec.config[name];\r\n    };\r\n    Model.prototype.markOpacity = function () {\r\n        var opacity = this.config('marks').opacity;\r\n        if (opacity) {\r\n            return opacity;\r\n        }\r\n        else {\r\n            if (util_1.contains([mark_1.POINT, mark_1.TICK, mark_1.CIRCLE, mark_1.SQUARE], this.mark())) {\r\n                if (!this.isAggregate() ||\r\n                    (this.has(channel_1.DETAIL) || this.has(channel_1.COLOR) || this.has(channel_1.SHAPE))) {\r\n                    return 0.7;\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    return Model;\r\n})();\r\nexports.Model = Model;\r\n\n},{\"../bin\":28,\"../channel\":29,\"../data\":33,\"../encoding\":34,\"../fielddef\":35,\"../mark\":36,\"../schema/schema\":49,\"../schema/schemautil\":50,\"../type\":55,\"../util\":56,\"./layout\":31,\"./time\":32}],31:[function(require,module,exports){\nvar channel_1 = require('../channel');\r\nvar mark_1 = require('../mark');\r\nvar data_1 = require('../data');\r\nfunction compileLayout(model) {\r\n    var cellWidth = getCellWidth(model);\r\n    var cellHeight = getCellHeight(model);\r\n    return {\r\n        cellWidth: cellWidth,\r\n        cellHeight: cellHeight,\r\n        width: getWidth(model, cellWidth),\r\n        height: getHeight(model, cellHeight)\r\n    };\r\n}\r\nexports.compileLayout = compileLayout;\r\nfunction getCellWidth(model) {\r\n    if (model.has(channel_1.X)) {\r\n        if (model.isOrdinalScale(channel_1.X)) {\r\n            return { data: data_1.LAYOUT, field: 'cellWidth' };\r\n        }\r\n        return model.config('cell').width;\r\n    }\r\n    if (model.mark() === mark_1.TEXT) {\r\n        return model.config('textCellWidth');\r\n    }\r\n    return model.fieldDef(channel_1.X).scale.bandWidth;\r\n}\r\nfunction getWidth(model, cellWidth) {\r\n    if (model.has(channel_1.COLUMN)) {\r\n        return { data: data_1.LAYOUT, field: 'width' };\r\n    }\r\n    return cellWidth;\r\n}\r\nfunction getCellHeight(model) {\r\n    if (model.has(channel_1.Y)) {\r\n        if (model.isOrdinalScale(channel_1.Y)) {\r\n            return { data: data_1.LAYOUT, field: 'cellHeight' };\r\n        }\r\n        else {\r\n            return model.config('cell').height;\r\n        }\r\n    }\r\n    return model.fieldDef(channel_1.Y).scale.bandWidth;\r\n}\r\nfunction getHeight(model, cellHeight) {\r\n    if (model.has(channel_1.ROW)) {\r\n        return { data: data_1.LAYOUT, field: 'height' };\r\n    }\r\n    return cellHeight;\r\n}\r\n\n},{\"../channel\":29,\"../data\":33,\"../mark\":36}],32:[function(require,module,exports){\nvar util = require('../util');\r\nvar channel_1 = require('../channel');\r\nfunction cardinality(fieldDef, stats, filterNull, type) {\r\n    var timeUnit = fieldDef.timeUnit;\r\n    switch (timeUnit) {\r\n        case 'seconds': return 60;\r\n        case 'minutes': return 60;\r\n        case 'hours': return 24;\r\n        case 'day': return 7;\r\n        case 'date': return 31;\r\n        case 'month': return 12;\r\n        case 'year':\r\n            var stat = stats[fieldDef.field], yearstat = stats['year_' + fieldDef.field];\r\n            if (!yearstat) {\r\n                return null;\r\n            }\r\n            return yearstat.distinct -\r\n                (stat.missing > 0 && filterNull[type] ? 1 : 0);\r\n    }\r\n    return null;\r\n}\r\nexports.cardinality = cardinality;\r\nfunction formula(timeUnit, field) {\r\n    var fn = 'utc' + timeUnit;\r\n    return fn + '(' + field + ')';\r\n}\r\nexports.formula = formula;\r\nvar scale;\r\n(function (scale) {\r\n    function type(timeUnit, channel) {\r\n        if (channel === channel_1.COLOR) {\r\n            return 'linear';\r\n        }\r\n        if (channel === channel_1.COLUMN || channel === channel_1.ROW) {\r\n            return 'ordinal';\r\n        }\r\n        switch (timeUnit) {\r\n            case 'hours':\r\n            case 'day':\r\n            case 'date':\r\n            case 'month':\r\n                return 'ordinal';\r\n            case 'year':\r\n            case 'second':\r\n            case 'minute':\r\n                return 'linear';\r\n        }\r\n        return 'time';\r\n    }\r\n    scale.type = type;\r\n    function domain(timeUnit, channel) {\r\n        var isColor = channel === channel_1.COLOR;\r\n        switch (timeUnit) {\r\n            case 'seconds':\r\n            case 'minutes': return isColor ? [0, 59] : util.range(0, 60);\r\n            case 'hours': return isColor ? [0, 23] : util.range(0, 24);\r\n            case 'day': return isColor ? [0, 6] : util.range(0, 7);\r\n            case 'date': return isColor ? [1, 31] : util.range(1, 32);\r\n            case 'month': return isColor ? [0, 11] : util.range(0, 12);\r\n        }\r\n        return null;\r\n    }\r\n    scale.domain = domain;\r\n})(scale = exports.scale || (exports.scale = {}));\r\nfunction labelTemplate(timeUnit, abbreviated) {\r\n    if (abbreviated === void 0) { abbreviated = false; }\r\n    var postfix = abbreviated ? '-abbrev' : '';\r\n    switch (timeUnit) {\r\n        case 'day':\r\n            return 'day' + postfix;\r\n        case 'month':\r\n            return 'month' + postfix;\r\n    }\r\n    return null;\r\n}\r\nexports.labelTemplate = labelTemplate;\r\n\n},{\"../channel\":29,\"../util\":56}],33:[function(require,module,exports){\nvar type_1 = require('./type');\r\nexports.SUMMARY = 'summary';\r\nexports.SOURCE = 'source';\r\nexports.STACKED = 'stacked';\r\nexports.LAYOUT = 'layout';\r\nexports.types = {\r\n    'boolean': type_1.NOMINAL,\r\n    'number': type_1.QUANTITATIVE,\r\n    'integer': type_1.QUANTITATIVE,\r\n    'date': type_1.TEMPORAL,\r\n    'string': type_1.NOMINAL\r\n};\r\n\n},{\"./type\":55}],34:[function(require,module,exports){\nvar channel_1 = require('./channel');\r\nfunction countRetinal(encoding) {\r\n    var count = 0;\r\n    if (encoding.color)\r\n        count++;\r\n    if (encoding.size)\r\n        count++;\r\n    if (encoding.shape)\r\n        count++;\r\n    return count;\r\n}\r\nexports.countRetinal = countRetinal;\r\nfunction has(encoding, channel) {\r\n    var fieldDef = encoding && encoding[channel];\r\n    return fieldDef && fieldDef.field;\r\n}\r\nexports.has = has;\r\nfunction isAggregate(encoding) {\r\n    for (var k in encoding) {\r\n        if (has(encoding, k) && encoding[k].aggregate) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.isAggregate = isAggregate;\r\nfunction fieldDefs(encoding) {\r\n    var arr = [];\r\n    channel_1.CHANNELS.forEach(function (k) {\r\n        if (has(encoding, k)) {\r\n            arr.push(encoding[k]);\r\n        }\r\n    });\r\n    return arr;\r\n}\r\nexports.fieldDefs = fieldDefs;\r\n;\r\nfunction forEach(encoding, f) {\r\n    var i = 0;\r\n    channel_1.CHANNELS.forEach(function (channel) {\r\n        if (has(encoding, channel)) {\r\n            f(encoding[channel], channel, i++);\r\n        }\r\n    });\r\n}\r\nexports.forEach = forEach;\r\nfunction map(encoding, f) {\r\n    var arr = [];\r\n    channel_1.CHANNELS.forEach(function (k) {\r\n        if (has(encoding, k)) {\r\n            arr.push(f(encoding[k], k, encoding));\r\n        }\r\n    });\r\n    return arr;\r\n}\r\nexports.map = map;\r\nfunction reduce(encoding, f, init) {\r\n    var r = init;\r\n    channel_1.CHANNELS.forEach(function (k) {\r\n        if (has(encoding, k)) {\r\n            r = f(r, encoding[k], k, encoding);\r\n        }\r\n    });\r\n    return r;\r\n}\r\nexports.reduce = reduce;\r\n\n},{\"./channel\":29}],35:[function(require,module,exports){\nvar bin_1 = require('./bin');\r\nvar util_1 = require('./util');\r\nvar time = require('./compiler/time');\r\nvar type_1 = require('./type');\r\nfunction _isFieldDimension(fieldDef) {\r\n    return util_1.contains([type_1.NOMINAL, type_1.ORDINAL], fieldDef.type) || !!fieldDef.bin ||\r\n        (fieldDef.type === type_1.TEMPORAL && !!fieldDef.timeUnit);\r\n}\r\nfunction isDimension(fieldDef) {\r\n    return fieldDef && _isFieldDimension(fieldDef);\r\n}\r\nexports.isDimension = isDimension;\r\nfunction isMeasure(fieldDef) {\r\n    return fieldDef && !_isFieldDimension(fieldDef);\r\n}\r\nexports.isMeasure = isMeasure;\r\nfunction count() {\r\n    return { field: '*', aggregate: 'count', type: type_1.QUANTITATIVE, displayName: exports.COUNT_DISPLAYNAME };\r\n}\r\nexports.count = count;\r\nexports.COUNT_DISPLAYNAME = 'Number of Records';\r\nfunction isCount(fieldDef) {\r\n    return fieldDef.aggregate === 'count';\r\n}\r\nexports.isCount = isCount;\r\nfunction cardinality(fieldDef, stats, filterNull) {\r\n    if (filterNull === void 0) { filterNull = {}; }\r\n    var stat = stats[fieldDef.field];\r\n    var type = fieldDef.type;\r\n    if (fieldDef.bin) {\r\n        var bin = fieldDef.bin;\r\n        var maxbins = (typeof bin === 'boolean') ? bin_1.MAXBINS_DEFAULT : bin.maxbins;\r\n        var bins = util_1.getbins(stat, maxbins);\r\n        return (bins.stop - bins.start) / bins.step;\r\n    }\r\n    if (fieldDef.type === type_1.TEMPORAL) {\r\n        var cardinality = time.cardinality(fieldDef, stats, filterNull, type);\r\n        if (cardinality !== null)\r\n            return cardinality;\r\n    }\r\n    if (fieldDef.aggregate) {\r\n        return 1;\r\n    }\r\n    return stat.distinct -\r\n        (stat.missing > 0 && filterNull[type] ? 1 : 0);\r\n}\r\nexports.cardinality = cardinality;\r\n\n},{\"./bin\":28,\"./compiler/time\":32,\"./type\":55,\"./util\":56}],36:[function(require,module,exports){\n(function (Mark) {\r\n    Mark[Mark[\"AREA\"] = 'area'] = \"AREA\";\r\n    Mark[Mark[\"BAR\"] = 'bar'] = \"BAR\";\r\n    Mark[Mark[\"LINE\"] = 'line'] = \"LINE\";\r\n    Mark[Mark[\"POINT\"] = 'point'] = \"POINT\";\r\n    Mark[Mark[\"TEXT\"] = 'text'] = \"TEXT\";\r\n    Mark[Mark[\"TICK\"] = 'tick'] = \"TICK\";\r\n    Mark[Mark[\"CIRCLE\"] = 'circle'] = \"CIRCLE\";\r\n    Mark[Mark[\"SQUARE\"] = 'square'] = \"SQUARE\";\r\n})(exports.Mark || (exports.Mark = {}));\r\nvar Mark = exports.Mark;\r\nexports.AREA = Mark.AREA;\r\nexports.BAR = Mark.BAR;\r\nexports.LINE = Mark.LINE;\r\nexports.POINT = Mark.POINT;\r\nexports.TEXT = Mark.TEXT;\r\nexports.TICK = Mark.TICK;\r\nexports.CIRCLE = Mark.CIRCLE;\r\nexports.SQUARE = Mark.SQUARE;\r\n\n},{}],37:[function(require,module,exports){\nexports.axis = {\r\n    type: 'object',\r\n    properties: {\r\n        format: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'The formatting pattern for axis labels. ' +\r\n                'If not undefined, this will be determined by ' +\r\n                'the max value ' +\r\n                'of the field.'\r\n        },\r\n        grid: {\r\n            type: 'boolean',\r\n            default: undefined,\r\n            description: 'A flag indicate if gridlines should be created in addition to ticks. If `grid` is unspecified, the default value is `true` for ROW and COL. For X and Y, the default value is `true` for quantitative and time fields and `false` otherwise.'\r\n        },\r\n        layer: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'A string indicating if the axis (and any gridlines) should be placed above or below the data marks.'\r\n        },\r\n        orient: {\r\n            type: 'string',\r\n            default: undefined,\r\n            enum: ['top', 'right', 'left', 'bottom'],\r\n            description: 'The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).'\r\n        },\r\n        ticks: {\r\n            type: 'integer',\r\n            default: undefined,\r\n            minimum: 0,\r\n            description: 'A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale\\'s range.'\r\n        },\r\n        title: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'A title for the axis. (Shows field name and its function by default.)'\r\n        },\r\n        labelMaxLength: {\r\n            type: 'integer',\r\n            default: 25,\r\n            minimum: 0,\r\n            description: 'Truncate labels that are too long.'\r\n        },\r\n        titleMaxLength: {\r\n            type: 'integer',\r\n            default: undefined,\r\n            minimum: 0,\r\n            description: 'Max length for axis title if the title is automatically generated from the field\\'s description'\r\n        },\r\n        titleOffset: {\r\n            type: 'integer',\r\n            default: undefined,\r\n            description: 'A title offset value for the axis.'\r\n        },\r\n        shortTimeNames: {\r\n            type: 'boolean',\r\n            default: false,\r\n            description: 'Whether month names and weekday names should be abbreviated.'\r\n        },\r\n        properties: {\r\n            type: 'object',\r\n            default: undefined,\r\n            description: 'Optional mark property definitions for custom axis styling.'\r\n        }\r\n    }\r\n};\r\n\n},{}],38:[function(require,module,exports){\nvar bin_1 = require('../bin');\r\nvar type_1 = require('../type');\r\nvar util_1 = require('../util');\r\nexports.bin = {\r\n    type: ['boolean', 'object'],\r\n    default: false,\r\n    properties: {\r\n        maxbins: {\r\n            type: 'integer',\r\n            default: bin_1.MAXBINS_DEFAULT,\r\n            minimum: 2,\r\n            description: 'Maximum number of bins.'\r\n        }\r\n    },\r\n    supportedTypes: util_1.toMap([type_1.QUANTITATIVE])\r\n};\r\n\n},{\"../bin\":28,\"../type\":55,\"../util\":56}],39:[function(require,module,exports){\nexports.cellConfig = {\r\n    type: 'object',\r\n    properties: {\r\n        width: {\r\n            type: 'integer',\r\n            default: 200\r\n        },\r\n        height: {\r\n            type: 'integer',\r\n            default: 200\r\n        },\r\n        padding: {\r\n            type: 'integer',\r\n            default: 16,\r\n            description: 'default padding between facets.'\r\n        },\r\n        gridColor: {\r\n            type: 'string',\r\n            role: 'color',\r\n            default: '#000000'\r\n        },\r\n        gridOpacity: {\r\n            type: 'number',\r\n            minimum: 0,\r\n            maximum: 1,\r\n            default: 0.25\r\n        },\r\n        gridOffset: {\r\n            type: 'number',\r\n            default: 6\r\n        },\r\n        fill: {\r\n            type: 'string',\r\n            role: 'color',\r\n            default: 'rgba(0,0,0,0)'\r\n        },\r\n        fillOpacity: {\r\n            type: 'number',\r\n        },\r\n        stroke: {\r\n            type: 'string',\r\n            role: 'color',\r\n        },\r\n        strokeWidth: {\r\n            type: 'integer'\r\n        },\r\n        strokeOpacity: {\r\n            type: 'number'\r\n        },\r\n        strokeDash: {\r\n            type: 'array',\r\n            default: undefined\r\n        },\r\n        strokeDashOffset: {\r\n            type: 'integer',\r\n            description: 'The offset (in pixels) into which to begin drawing with the stroke dash array.'\r\n        }\r\n    }\r\n};\r\n\n},{}],40:[function(require,module,exports){\nexports.marksConfig = {\r\n    type: 'object',\r\n    properties: {\r\n        filled: {\r\n            type: 'boolean',\r\n            default: false,\r\n            description: 'Whether the shape\\'s color should be used as fill color instead of stroke color.'\r\n        },\r\n        format: {\r\n            type: 'string',\r\n            default: '',\r\n            description: 'The formatting pattern for text value.' +\r\n                'If not defined, this will be determined automatically'\r\n        },\r\n        fill: {\r\n            type: 'string',\r\n            role: 'color',\r\n            default: '#000000'\r\n        },\r\n        opacity: {\r\n            type: 'number',\r\n            default: undefined,\r\n            minimum: 0,\r\n            maximum: 1\r\n        },\r\n        strokeWidth: {\r\n            type: 'integer',\r\n            default: 2,\r\n            minimum: 0\r\n        },\r\n        strokeDash: {\r\n            type: 'array',\r\n            default: undefined,\r\n            description: 'An array of alternating stroke, space lengths for creating dashed or dotted lines.'\r\n        },\r\n        strokeDashOffset: {\r\n            type: 'array',\r\n            default: undefined,\r\n            description: 'The offset (in pixels) into which to begin drawing with the stroke dash array.'\r\n        },\r\n        orient: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'The orientation of this area mark. One of horizontal (the default) or vertical.'\r\n        },\r\n        interpolate: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'The line interpolation method to use. One of linear, step-before, step-after, basis, basis-open, basis-closed, bundle, cardinal, cardinal-open, cardinal-closed, monotone.'\r\n        },\r\n        tension: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'Depending on the interpolation type, sets the tension parameter.'\r\n        },\r\n        align: {\r\n            type: 'string',\r\n            default: 'right',\r\n            enum: ['left', 'right', 'center'],\r\n            description: 'The horizontal alignment of the text. One of left, right, center.'\r\n        },\r\n        angle: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'The rotation angle of the text, in degrees.'\r\n        },\r\n        baseline: {\r\n            type: 'string',\r\n            default: 'middle',\r\n            enum: ['top', 'middle', 'bottom'],\r\n            description: 'The vertical alignment of the text. One of top, middle, bottom.'\r\n        },\r\n        dx: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the angle property.'\r\n        },\r\n        dy: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the angle property.'\r\n        },\r\n        font: {\r\n            type: 'string',\r\n            default: undefined,\r\n            role: 'font',\r\n            description: 'The typeface to set the text in (e.g., Helvetica Neue).'\r\n        },\r\n        fontStyle: {\r\n            type: 'string',\r\n            default: undefined,\r\n            enum: ['normal', 'italic'],\r\n            description: 'The font style (e.g., italic).'\r\n        },\r\n        fontWeight: {\r\n            type: 'string',\r\n            enum: ['normal', 'bold'],\r\n            default: undefined,\r\n            description: 'The font weight (e.g., bold).'\r\n        },\r\n        radius: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'Polar coordinate radial offset, in pixels, of the text label from the origin determined by the x and y properties.'\r\n        },\r\n        theta: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'Polar coordinate angle, in radians, of the text label from the origin determined by the x and y properties. Values for theta follow the same convention of arc mark startAngle and endAngle properties: angles are measured in radians, with 0 indicating \"north\".'\r\n        }\r\n    }\r\n};\r\n\n},{}],41:[function(require,module,exports){\nvar config_stack_schema_1 = require('./config.stack.schema');\r\nvar config_cell_schema_1 = require('./config.cell.schema');\r\nvar config_marks_schema_1 = require('./config.marks.schema');\r\nexports.config = {\r\n    type: 'object',\r\n    properties: {\r\n        viewport: {\r\n            type: 'array',\r\n            items: {\r\n                type: 'integer'\r\n            },\r\n            default: undefined,\r\n            description: 'The width and height of the on-screen viewport, in pixels. If necessary, clipping and scrolling will be applied.'\r\n        },\r\n        background: {\r\n            type: 'string',\r\n            role: 'color',\r\n            default: undefined,\r\n            description: 'CSS color property to use as background of visualization. Default is `\"transparent\"`.'\r\n        },\r\n        scene: {\r\n            type: 'object',\r\n            default: undefined,\r\n            description: 'An object to style the top-level scenegraph root. Available properties include `fill`, `fillOpacity`, `stroke`, `strokeOpacity`, `strokeWidth`, `strokeDash`, `strokeDashOffset`'\r\n        },\r\n        filterNull: {\r\n            type: 'object',\r\n            properties: {\r\n                nominal: { type: 'boolean', default: false },\r\n                ordinal: { type: 'boolean', default: false },\r\n                quantitative: { type: 'boolean', default: true },\r\n                temporal: { type: 'boolean', default: true }\r\n            }\r\n        },\r\n        textCellWidth: {\r\n            type: 'integer',\r\n            default: 90,\r\n            minimum: 0\r\n        },\r\n        sortLineBy: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'Data field to sort line by. ' +\r\n                '\\'-\\' prefix can be added to suggest descending order.'\r\n        },\r\n        stack: config_stack_schema_1.stackConfig,\r\n        cell: config_cell_schema_1.cellConfig,\r\n        marks: config_marks_schema_1.marksConfig,\r\n        singleBarOffset: {\r\n            type: 'integer',\r\n            default: 5,\r\n            minimum: 0\r\n        },\r\n        characterWidth: {\r\n            type: 'integer',\r\n            default: 6\r\n        },\r\n        numberFormat: {\r\n            type: 'string',\r\n            default: 's',\r\n            description: 'D3 Number format for axis labels and text tables.'\r\n        },\r\n        timeFormat: {\r\n            type: 'string',\r\n            default: '%Y-%m-%d',\r\n            description: 'Date format for axis labels.'\r\n        }\r\n    }\r\n};\r\n\n},{\"./config.cell.schema\":39,\"./config.marks.schema\":40,\"./config.stack.schema\":42}],42:[function(require,module,exports){\nexports.stackConfig = {\r\n    type: ['boolean', 'object'],\r\n    default: {},\r\n    description: 'Enable stacking (for bar and area marks only).',\r\n    properties: {\r\n        sort: {\r\n            oneOf: [{\r\n                    type: 'string',\r\n                    enum: ['ascending', 'descending']\r\n                }, {\r\n                    type: 'array',\r\n                    items: { type: 'string' },\r\n                }],\r\n            description: 'Order of the stack. ' +\r\n                'This can be either a string (either \"descending\" or \"ascending\")' +\r\n                'or a list of fields to determine the order of stack layers.' +\r\n                'By default, stack uses descending order.'\r\n        },\r\n        offset: {\r\n            type: 'string',\r\n            enum: ['zero', 'center', 'normalize']\r\n        }\r\n    }\r\n};\r\n\n},{}],43:[function(require,module,exports){\nexports.data = {\r\n    type: 'object',\r\n    properties: {\r\n        formatType: {\r\n            type: 'string',\r\n            enum: ['json', 'csv', 'tsv'],\r\n            default: 'json'\r\n        },\r\n        url: {\r\n            type: 'string',\r\n            default: undefined\r\n        },\r\n        values: {\r\n            type: 'array',\r\n            default: undefined,\r\n            description: 'Pass array of objects instead of a url to a file.',\r\n            items: {\r\n                type: 'object',\r\n                additionalProperties: true\r\n            }\r\n        },\r\n        filter: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'A string containing the filter Vega expression. Use `datum` to refer to the current data object.'\r\n        },\r\n        calculate: {\r\n            type: 'array',\r\n            default: undefined,\r\n            description: 'Calculate new field(s) using the provided expresssion(s). Calculation are applied before filter.',\r\n            items: {\r\n                type: 'object',\r\n                properties: {\r\n                    field: {\r\n                        type: 'string',\r\n                        description: 'The field in which to store the computed formula value.'\r\n                    },\r\n                    expr: {\r\n                        type: 'string',\r\n                        description: 'A string containing an expression for the formula. Use the variable `datum` to to refer to the current data object.'\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\n},{}],44:[function(require,module,exports){\nvar schemautil_1 = require('./schemautil');\r\nvar util_1 = require('../util');\r\nvar axis_schema_1 = require('./axis.schema');\r\nvar legend_schema_1 = require('./legend.schema');\r\nvar sort_schema_1 = require('./sort.schema');\r\nvar fielddef_schema_1 = require('./fielddef.schema');\r\nvar requiredNameType = {\r\n    required: ['field', 'type']\r\n};\r\nvar x = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.typicalField), requiredNameType, {\r\n    properties: {\r\n        scale: {\r\n            properties: {\r\n                padding: { default: 1 },\r\n                bandWidth: { default: 21 }\r\n            }\r\n        },\r\n        axis: axis_schema_1.axis,\r\n        sort: sort_schema_1.sort\r\n    }\r\n});\r\nvar y = util_1.duplicate(x);\r\nvar facet = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.onlyOrdinalField), requiredNameType, {\r\n    properties: {\r\n        axis: axis_schema_1.axis,\r\n        sort: sort_schema_1.sort\r\n    }\r\n});\r\nvar row = schemautil_1.merge(util_1.duplicate(facet));\r\nvar column = schemautil_1.merge(util_1.duplicate(facet));\r\nvar size = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.typicalField), {\r\n    properties: {\r\n        legend: legend_schema_1.legend,\r\n        sort: sort_schema_1.sort,\r\n        value: {\r\n            type: 'integer',\r\n            default: 30,\r\n            minimum: 0,\r\n            description: 'Size of marks.'\r\n        }\r\n    }\r\n});\r\nvar color = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.typicalField), {\r\n    properties: {\r\n        legend: legend_schema_1.legend,\r\n        sort: sort_schema_1.sort,\r\n        value: {\r\n            type: 'string',\r\n            role: 'color',\r\n            default: '#4682b4',\r\n            description: 'Color to be used for marks.'\r\n        },\r\n        scale: {\r\n            type: 'object',\r\n            properties: {\r\n                quantitativeRange: {\r\n                    type: 'array',\r\n                    default: ['#AFC6A3', '#09622A'],\r\n                    description: 'Color range to encode quantitative variables.',\r\n                    minItems: 2,\r\n                    maxItems: 2,\r\n                    items: {\r\n                        type: 'string',\r\n                        role: 'color'\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n});\r\nvar shape = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.onlyOrdinalField), {\r\n    properties: {\r\n        legend: legend_schema_1.legend,\r\n        sort: sort_schema_1.sort,\r\n        value: {\r\n            type: 'string',\r\n            enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\r\n            default: 'circle',\r\n            description: 'Mark to be used.'\r\n        }\r\n    }\r\n});\r\nvar detail = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.onlyOrdinalField), {\r\n    properties: {\r\n        sort: sort_schema_1.sort\r\n    }\r\n});\r\nvar text = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.typicalField), {\r\n    properties: {\r\n        sort: sort_schema_1.sort,\r\n        value: {\r\n            type: 'string',\r\n            default: 'Abc'\r\n        }\r\n    }\r\n});\r\nexports.encoding = {\r\n    type: 'object',\r\n    properties: {\r\n        x: x,\r\n        y: y,\r\n        row: row,\r\n        column: column,\r\n        size: size,\r\n        color: color,\r\n        shape: shape,\r\n        text: text,\r\n        detail: detail\r\n    }\r\n};\r\n\n},{\"../util\":56,\"./axis.schema\":37,\"./fielddef.schema\":45,\"./legend.schema\":46,\"./schemautil\":50,\"./sort.schema\":51}],45:[function(require,module,exports){\nvar bin_schema_1 = require('./bin.schema');\r\nvar scale_schema_1 = require('./scale.schema');\r\nvar aggregate_1 = require('../aggregate');\r\nvar util_1 = require('../util');\r\nvar schemautil_1 = require('./schemautil');\r\nvar timeunit_1 = require('../timeunit');\r\nvar type_1 = require('../type');\r\nexports.fieldDef = {\r\n    type: 'object',\r\n    properties: {\r\n        field: {\r\n            type: 'string'\r\n        },\r\n        type: {\r\n            type: 'string',\r\n            enum: [type_1.NOMINAL, type_1.ORDINAL, type_1.QUANTITATIVE, type_1.TEMPORAL]\r\n        },\r\n        timeUnit: {\r\n            type: 'string',\r\n            enum: timeunit_1.TIMEUNITS,\r\n            supportedTypes: util_1.toMap([type_1.TEMPORAL])\r\n        },\r\n        bin: bin_schema_1.bin,\r\n    }\r\n};\r\nexports.aggregate = {\r\n    type: 'string',\r\n    enum: aggregate_1.AGGREGATE_OPS,\r\n    supportedEnums: {\r\n        quantitative: aggregate_1.AGGREGATE_OPS,\r\n        ordinal: ['median', 'min', 'max'],\r\n        nominal: [],\r\n        temporal: ['mean', 'median', 'min', 'max'],\r\n        '': ['count']\r\n    },\r\n    supportedTypes: util_1.toMap([type_1.QUANTITATIVE, type_1.NOMINAL, type_1.ORDINAL, type_1.TEMPORAL, ''])\r\n};\r\nexports.typicalField = schemautil_1.merge(util_1.duplicate(exports.fieldDef), {\r\n    properties: {\r\n        aggregate: exports.aggregate,\r\n        scale: scale_schema_1.typicalScale\r\n    }\r\n});\r\nexports.onlyOrdinalField = schemautil_1.merge(util_1.duplicate(exports.fieldDef), {\r\n    properties: {\r\n        scale: scale_schema_1.ordinalOnlyScale\r\n    }\r\n});\r\n\n},{\"../aggregate\":27,\"../timeunit\":54,\"../type\":55,\"../util\":56,\"./bin.schema\":38,\"./scale.schema\":48,\"./schemautil\":50}],46:[function(require,module,exports){\nexports.legend = {\r\n    default: true,\r\n    description: 'Properties of a legend or boolean flag for determining whether to show it.',\r\n    oneOf: [{\r\n            type: 'object',\r\n            properties: {\r\n                orient: {\r\n                    type: 'string',\r\n                    default: undefined,\r\n                    description: 'The orientation of the legend. One of \"left\" or \"right\". This determines how the legend is positioned within the scene. The default is \"right\".'\r\n                },\r\n                title: {\r\n                    type: 'string',\r\n                    default: undefined,\r\n                    description: 'A title for the legend. (Shows field name and its function by default.)'\r\n                },\r\n                format: {\r\n                    type: 'string',\r\n                    default: undefined,\r\n                    description: 'An optional formatting pattern for legend labels. Vega uses D3\\'s format pattern.'\r\n                },\r\n                values: {\r\n                    type: 'array',\r\n                    default: undefined,\r\n                    description: 'Explicitly set the visible legend values.'\r\n                },\r\n                properties: {\r\n                    type: 'object',\r\n                    default: undefined,\r\n                    description: 'Optional mark property definitions for custom legend styling. '\r\n                }\r\n            }\r\n        }, {\r\n            type: 'boolean'\r\n        }]\r\n};\r\n\n},{}],47:[function(require,module,exports){\nexports.mark = {\r\n    type: 'string',\r\n    enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\r\n};\r\n\n},{}],48:[function(require,module,exports){\nvar util_1 = require('../util');\r\nvar schemautil_1 = require('./schemautil');\r\nvar type_1 = require('../type');\r\nvar scale = {\r\n    type: 'object',\r\n    properties: {\r\n        type: {\r\n            type: 'string',\r\n            enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\r\n            default: 'linear',\r\n            supportedTypes: util_1.toMap([type_1.QUANTITATIVE])\r\n        },\r\n        domain: {\r\n            default: undefined,\r\n            type: ['array', 'object'],\r\n            description: 'The domain of the scale, representing the set of data values. For quantitative data, this can take the form of a two-element array with minimum and maximum values. For ordinal/categorical data, this may be an array of valid input values. The domain may also be specified by a reference to a data source.'\r\n        },\r\n        range: {\r\n            default: undefined,\r\n            type: ['array', 'object', 'string'],\r\n            description: 'The range of the scale, representing the set of visual values. For numeric values, the range can take the form of a two-element array with minimum and maximum values. For ordinal or quantized data, the range may by an array of desired output values, which are mapped to elements in the specified domain. For ordinal scales only, the range can be defined using a DataRef: the range values are then drawn dynamically from a backing data set.'\r\n        },\r\n        round: {\r\n            default: undefined,\r\n            type: 'boolean',\r\n            description: 'If true, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid.'\r\n        }\r\n    }\r\n};\r\nvar ordinalScaleMixin = {\r\n    properties: {\r\n        bandWidth: {\r\n            type: 'integer',\r\n            minimum: 0,\r\n            default: undefined\r\n        },\r\n        outerPadding: {\r\n            type: 'number',\r\n            default: undefined\r\n        },\r\n        padding: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'Applies spacing among ordinal elements in the scale range. The actual effect depends on how the scale is configured. If the __points__ parameter is `true`, the padding value is interpreted as a multiple of the spacing between points. A reasonable value is 1.0, such that the first and last point will be offset from the minimum and maximum value by half the distance between points. Otherwise, padding is typically in the range [0, 1] and corresponds to the fraction of space in the range interval to allocate to padding. A value of 0.5 means that the range band width will be equal to the padding width. For more, see the [D3 ordinal scale documentation](https://github.com/mbostock/d3/wiki/Ordinal-Scales).'\r\n        },\r\n        points: {\r\n            type: 'boolean',\r\n            default: undefined,\r\n            description: 'If true, distributes the ordinal values over a quantitative range at uniformly spaced points. The spacing of the points can be adjusted using the padding property. If false, the ordinal scale will construct evenly-spaced bands, rather than points.'\r\n        }\r\n    }\r\n};\r\nvar typicalScaleMixin = {\r\n    properties: {\r\n        clamp: {\r\n            type: 'boolean',\r\n            default: true,\r\n            description: 'If true, values that exceed the data domain are clamped to either the minimum or maximum range value'\r\n        },\r\n        nice: {\r\n            default: undefined,\r\n            oneOf: [\r\n                {\r\n                    type: 'boolean',\r\n                    description: 'If true, modifies the scale domain to use a more human-friendly number range (e.g., 7 instead of 6.96).'\r\n                }, {\r\n                    type: 'string',\r\n                    enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\r\n                    description: 'If specified, modifies the scale domain to use a more human-friendly value range. For time and utc scale types only, the nice value should be a string indicating the desired time interval; legal values are \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", or \"year\".'\r\n                }\r\n            ],\r\n            supportedTypes: util_1.toMap([type_1.QUANTITATIVE, type_1.TEMPORAL]),\r\n            description: ''\r\n        },\r\n        exponent: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'Sets the exponent of the scale transformation. For pow scale types only, otherwise ignored.'\r\n        },\r\n        zero: {\r\n            type: 'boolean',\r\n            description: 'If true, ensures that a zero baseline value is included in the scale domain. This option is ignored for non-quantitative scales.',\r\n            default: undefined,\r\n            supportedTypes: util_1.toMap([type_1.QUANTITATIVE, type_1.TEMPORAL])\r\n        },\r\n        useRawDomain: {\r\n            type: 'boolean',\r\n            default: false,\r\n            description: 'Uses the source data range as scale domain instead of ' +\r\n                'aggregated data for aggregate axis. ' +\r\n                'This option does not work with sum or count aggregate' +\r\n                'as they might have a substantially larger scale range.'\r\n        }\r\n    }\r\n};\r\nexports.ordinalOnlyScale = schemautil_1.merge(util_1.duplicate(scale), ordinalScaleMixin);\r\nexports.typicalScale = schemautil_1.merge(util_1.duplicate(scale), ordinalScaleMixin, typicalScaleMixin);\r\n\n},{\"../type\":55,\"../util\":56,\"./schemautil\":50}],49:[function(require,module,exports){\nvar schemaUtil = require('./schemautil');\r\nvar mark_schema_1 = require('./mark.schema');\r\nvar config_schema_1 = require('./config.schema');\r\nvar data_schema_1 = require('./data.schema');\r\nvar encoding_schema_1 = require('./encoding.schema');\r\nvar fielddef_schema_1 = require('./fielddef.schema');\r\nexports.aggregate = fielddef_schema_1.aggregate;\r\nexports.util = schemaUtil;\r\nexports.schema = {\r\n    $schema: 'http://json-schema.org/draft-04/schema#',\r\n    description: 'Schema for Vega-lite specification',\r\n    type: 'object',\r\n    required: ['mark', 'encoding'],\r\n    properties: {\r\n        name: {\r\n            type: 'string'\r\n        },\r\n        description: {\r\n            type: 'string'\r\n        },\r\n        data: data_schema_1.data,\r\n        mark: mark_schema_1.mark,\r\n        encoding: encoding_schema_1.encoding,\r\n        config: config_schema_1.config\r\n    }\r\n};\r\nfunction instantiate() {\r\n    return schemaUtil.instantiate(exports.schema);\r\n}\r\nexports.instantiate = instantiate;\r\n;\r\n\n},{\"./config.schema\":41,\"./data.schema\":43,\"./encoding.schema\":44,\"./fielddef.schema\":45,\"./mark.schema\":47,\"./schemautil\":50}],50:[function(require,module,exports){\nvar util = require('../util');\r\nfunction isEmpty(obj) {\r\n    return Object.keys(obj).length === 0;\r\n}\r\n;\r\nfunction extend(instance, schema) {\r\n    return merge(instantiate(schema), instance);\r\n}\r\nexports.extend = extend;\r\n;\r\nfunction instantiate(schema) {\r\n    var val;\r\n    if (schema === undefined) {\r\n        return undefined;\r\n    }\r\n    else if ('default' in schema) {\r\n        val = schema.default;\r\n        return util.isObject(val) ? util.duplicate(val) : val;\r\n    }\r\n    else if (schema.type === 'object') {\r\n        var instance = {};\r\n        for (var name in schema.properties) {\r\n            val = instantiate(schema.properties[name]);\r\n            if (val !== undefined) {\r\n                instance[name] = val;\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n    else if (schema.type === 'array') {\r\n        return undefined;\r\n    }\r\n    return undefined;\r\n}\r\nexports.instantiate = instantiate;\r\n;\r\nfunction subtract(instance, defaults) {\r\n    var changes = {};\r\n    for (var prop in instance) {\r\n        var def = defaults[prop];\r\n        var ins = instance[prop];\r\n        if (!defaults || def !== ins) {\r\n            if (typeof ins === 'object' && !util.isArray(ins) && def) {\r\n                var c = subtract(ins, def);\r\n                if (!isEmpty(c)) {\r\n                    changes[prop] = c;\r\n                }\r\n            }\r\n            else if (util.isArray(ins)) {\r\n                if (util.isArray(def)) {\r\n                    if (ins.length === def.length) {\r\n                        var equal = true;\r\n                        for (var i = 0; i < ins.length; i++) {\r\n                            if (ins[i] !== def[i]) {\r\n                                equal = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (equal) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                changes[prop] = ins;\r\n            }\r\n            else {\r\n                changes[prop] = ins;\r\n            }\r\n        }\r\n    }\r\n    return changes;\r\n}\r\nexports.subtract = subtract;\r\n;\r\nfunction merge(dest) {\r\n    var src = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        src[_i - 1] = arguments[_i];\r\n    }\r\n    for (var i = 0; i < src.length; i++) {\r\n        dest = merge_(dest, src[i]);\r\n    }\r\n    return dest;\r\n}\r\nexports.merge = merge;\r\n;\r\nfunction merge_(dest, src) {\r\n    if (typeof src !== 'object' || src === null) {\r\n        return dest;\r\n    }\r\n    for (var p in src) {\r\n        if (!src.hasOwnProperty(p)) {\r\n            continue;\r\n        }\r\n        if (src[p] === undefined) {\r\n            continue;\r\n        }\r\n        if (typeof src[p] !== 'object' || src[p] === null) {\r\n            dest[p] = src[p];\r\n        }\r\n        else if (typeof dest[p] !== 'object' || dest[p] === null) {\r\n            dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\r\n        }\r\n        else {\r\n            merge(dest[p], src[p]);\r\n        }\r\n    }\r\n    return dest;\r\n}\r\n\n},{\"../util\":56}],51:[function(require,module,exports){\nvar aggregate_1 = require('../aggregate');\r\nvar type_1 = require('../type');\r\nvar util_1 = require('../util');\r\nexports.sort = {\r\n    default: 'ascending',\r\n    supportedTypes: util_1.toMap([type_1.QUANTITATIVE, type_1.ORDINAL]),\r\n    oneOf: [\r\n        {\r\n            type: 'string',\r\n            enum: ['ascending', 'descending', 'unsorted']\r\n        },\r\n        {\r\n            type: 'object',\r\n            required: ['field', 'op'],\r\n            properties: {\r\n                field: {\r\n                    type: 'string',\r\n                    description: 'The field name to aggregate over.'\r\n                },\r\n                op: {\r\n                    type: 'string',\r\n                    enum: aggregate_1.AGGREGATE_OPS,\r\n                    description: 'The field name to aggregate over.'\r\n                },\r\n                order: {\r\n                    type: 'string',\r\n                    enum: ['ascending', 'descending']\r\n                }\r\n            }\r\n        }\r\n    ]\r\n};\r\n\n},{\"../aggregate\":27,\"../type\":55,\"../util\":56}],52:[function(require,module,exports){\nvar aggregate_1 = require('./aggregate');\r\nvar timeunit_1 = require('./timeunit');\r\nvar type_1 = require('./type');\r\nvar vlEncoding = require('./encoding');\r\nvar mark_1 = require('./mark');\r\nexports.DELIM = '|';\r\nexports.ASSIGN = '=';\r\nexports.TYPE = ',';\r\nexports.FUNC = '_';\r\nfunction shorten(spec) {\r\n    return 'mark' + exports.ASSIGN + spec.mark +\r\n        exports.DELIM + shortenEncoding(spec.encoding);\r\n}\r\nexports.shorten = shorten;\r\nfunction parse(shorthand, data, config) {\r\n    var split = shorthand.split(exports.DELIM), mark = split.shift().split(exports.ASSIGN)[1].trim(), encoding = parseEncoding(split.join(exports.DELIM));\r\n    var spec = {\r\n        mark: mark_1.Mark[mark],\r\n        encoding: encoding\r\n    };\r\n    if (data !== undefined) {\r\n        spec.data = data;\r\n    }\r\n    if (config !== undefined) {\r\n        spec.config = config;\r\n    }\r\n    return spec;\r\n}\r\nexports.parse = parse;\r\nfunction shortenEncoding(encoding) {\r\n    return vlEncoding.map(encoding, function (fieldDef, channel) {\r\n        return channel + exports.ASSIGN + shortenFieldDef(fieldDef);\r\n    }).join(exports.DELIM);\r\n}\r\nexports.shortenEncoding = shortenEncoding;\r\nfunction parseEncoding(encodingShorthand) {\r\n    return encodingShorthand.split(exports.DELIM).reduce(function (m, e) {\r\n        var split = e.split(exports.ASSIGN), enctype = split[0].trim(), fieldDefShorthand = split[1];\r\n        m[enctype] = parseFieldDef(fieldDefShorthand);\r\n        return m;\r\n    }, {});\r\n}\r\nexports.parseEncoding = parseEncoding;\r\nfunction shortenFieldDef(fieldDef) {\r\n    return (fieldDef.aggregate ? fieldDef.aggregate + exports.FUNC : '') +\r\n        (fieldDef.timeUnit ? fieldDef.timeUnit + exports.FUNC : '') +\r\n        (fieldDef.bin ? 'bin' + exports.FUNC : '') +\r\n        (fieldDef.field || '') + exports.TYPE + type_1.SHORT_TYPE[fieldDef.type];\r\n}\r\nexports.shortenFieldDef = shortenFieldDef;\r\nfunction shortenFieldDefs(fieldDefs, delim) {\r\n    if (delim === void 0) { delim = exports.DELIM; }\r\n    return fieldDefs.map(shortenFieldDef).join(delim);\r\n}\r\nexports.shortenFieldDefs = shortenFieldDefs;\r\nfunction parseFieldDef(fieldDefShorthand) {\r\n    var split = fieldDefShorthand.split(exports.TYPE), i;\r\n    var fieldDef = {\r\n        field: split[0].trim(),\r\n        type: type_1.TYPE_FROM_SHORT_TYPE[split[1].trim()]\r\n    };\r\n    for (i in aggregate_1.AGGREGATE_OPS) {\r\n        var a = aggregate_1.AGGREGATE_OPS[i];\r\n        if (fieldDef.field.indexOf(a + '_') === 0) {\r\n            fieldDef.field = fieldDef.field.substr(a.length + 1);\r\n            if (a === 'count' && fieldDef.field.length === 0)\r\n                fieldDef.field = '*';\r\n            fieldDef.aggregate = a;\r\n            break;\r\n        }\r\n    }\r\n    for (i in timeunit_1.TIMEUNITS) {\r\n        var tu = timeunit_1.TIMEUNITS[i];\r\n        if (fieldDef.field && fieldDef.field.indexOf(tu + '_') === 0) {\r\n            fieldDef.field = fieldDef.field.substr(fieldDef.field.length + 1);\r\n            fieldDef.timeUnit = tu;\r\n            break;\r\n        }\r\n    }\r\n    if (fieldDef.field && fieldDef.field.indexOf('bin_') === 0) {\r\n        fieldDef.field = fieldDef.field.substr(4);\r\n        fieldDef.bin = true;\r\n    }\r\n    return fieldDef;\r\n}\r\nexports.parseFieldDef = parseFieldDef;\r\n\n},{\"./aggregate\":27,\"./encoding\":34,\"./mark\":36,\"./timeunit\":54,\"./type\":55}],53:[function(require,module,exports){\nvar Model_1 = require('./compiler/Model');\r\nvar channel_1 = require('./channel');\r\nvar vlEncoding = require('./encoding');\r\nvar mark_1 = require('./mark');\r\nvar util_1 = require('./util');\r\nfunction alwaysNoOcclusion(spec) {\r\n    return vlEncoding.isAggregate(spec.encoding);\r\n}\r\nexports.alwaysNoOcclusion = alwaysNoOcclusion;\r\nfunction fieldDefs(spec) {\r\n    return vlEncoding.fieldDefs(spec.encoding);\r\n}\r\nexports.fieldDefs = fieldDefs;\r\n;\r\nfunction getCleanSpec(spec) {\r\n    return new Model_1.Model(spec).toSpec(true);\r\n}\r\nexports.getCleanSpec = getCleanSpec;\r\nfunction isStack(spec) {\r\n    return (vlEncoding.has(spec.encoding, channel_1.COLOR) || vlEncoding.has(spec.encoding, channel_1.SHAPE)) &&\r\n        (spec.mark === mark_1.BAR || spec.mark === mark_1.AREA) &&\r\n        (!spec.config || !spec.config.stack !== false) &&\r\n        vlEncoding.isAggregate(spec.encoding);\r\n}\r\nexports.isStack = isStack;\r\nfunction transpose(spec) {\r\n    var oldenc = spec.encoding, encoding = util_1.duplicate(spec.encoding);\r\n    encoding.x = oldenc.y;\r\n    encoding.y = oldenc.x;\r\n    encoding.row = oldenc.column;\r\n    encoding.column = oldenc.row;\r\n    spec.encoding = encoding;\r\n    return spec;\r\n}\r\nexports.transpose = transpose;\r\n\n},{\"./channel\":29,\"./compiler/Model\":30,\"./encoding\":34,\"./mark\":36,\"./util\":56}],54:[function(require,module,exports){\nexports.TIMEUNITS = [\r\n    'year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'\r\n];\r\n\n},{}],55:[function(require,module,exports){\n(function (Type) {\r\n    Type[Type[\"QUANTITATIVE\"] = 'quantitative'] = \"QUANTITATIVE\";\r\n    Type[Type[\"ORDINAL\"] = 'ordinal'] = \"ORDINAL\";\r\n    Type[Type[\"TEMPORAL\"] = 'temporal'] = \"TEMPORAL\";\r\n    Type[Type[\"NOMINAL\"] = 'nominal'] = \"NOMINAL\";\r\n})(exports.Type || (exports.Type = {}));\r\nvar Type = exports.Type;\r\nexports.QUANTITATIVE = Type.QUANTITATIVE;\r\nexports.ORDINAL = Type.ORDINAL;\r\nexports.TEMPORAL = Type.TEMPORAL;\r\nexports.NOMINAL = Type.NOMINAL;\r\nexports.SHORT_TYPE = {\r\n    quantitative: 'Q',\r\n    temporal: 'T',\r\n    nominal: 'N',\r\n    ordinal: 'O'\r\n};\r\nexports.TYPE_FROM_SHORT_TYPE = {\r\n    Q: exports.QUANTITATIVE,\r\n    T: exports.TEMPORAL,\r\n    O: exports.ORDINAL,\r\n    N: exports.NOMINAL\r\n};\r\nfunction getFullName(type) {\r\n    var typeString = type;\r\n    return exports.TYPE_FROM_SHORT_TYPE[typeString.toUpperCase()] ||\r\n        typeString.toLowerCase();\r\n}\r\nexports.getFullName = getFullName;\r\n\n},{}],56:[function(require,module,exports){\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n__export(require('datalib/src/util'));\r\n__export(require('datalib/src/generate'));\r\n__export(require('datalib/src/stats'));\r\nfunction contains(array, item) {\r\n    return array.indexOf(item) > -1;\r\n}\r\nexports.contains = contains;\r\nfunction forEach(obj, f, thisArg) {\r\n    if (obj.forEach) {\r\n        obj.forEach.call(thisArg, f);\r\n    }\r\n    else {\r\n        for (var k in obj) {\r\n            f.call(thisArg, obj[k], k, obj);\r\n        }\r\n    }\r\n}\r\nexports.forEach = forEach;\r\nfunction reduce(obj, f, init, thisArg) {\r\n    if (obj.reduce) {\r\n        return obj.reduce.call(thisArg, f, init);\r\n    }\r\n    else {\r\n        for (var k in obj) {\r\n            init = f.call(thisArg, init, obj[k], k, obj);\r\n        }\r\n        return init;\r\n    }\r\n}\r\nexports.reduce = reduce;\r\nfunction map(obj, f, thisArg) {\r\n    if (obj.map) {\r\n        return obj.map.call(thisArg, f);\r\n    }\r\n    else {\r\n        var output = [];\r\n        for (var k in obj) {\r\n            output.push(f.call(thisArg, obj[k], k, obj));\r\n        }\r\n        return output;\r\n    }\r\n}\r\nexports.map = map;\r\nfunction any(arr, f) {\r\n    var i = 0, k;\r\n    for (k in arr) {\r\n        if (f(arr[k], k, i++))\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nexports.any = any;\r\nfunction all(arr, f) {\r\n    var i = 0, k;\r\n    for (k in arr) {\r\n        if (!f(arr[k], k, i++))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nexports.all = all;\r\nvar dlBin = require('datalib/src/bins/bins');\r\nfunction getbins(stats, maxbins) {\r\n    return dlBin({\r\n        min: stats.min,\r\n        max: stats.max,\r\n        maxbins: maxbins\r\n    });\r\n}\r\nexports.getbins = getbins;\r\nfunction error(message) {\r\n    console.error('[VL Error]', message);\r\n}\r\nexports.error = error;\r\n\n},{\"datalib/src/bins/bins\":21,\"datalib/src/generate\":22,\"datalib/src/stats\":24,\"datalib/src/util\":26}],57:[function(require,module,exports){\nvar util_1 = require('./util');\r\nvar mark_1 = require('./mark');\r\nexports.DEFAULT_REQUIRED_CHANNEL_MAP = {\r\n    text: ['text'],\r\n    line: ['x', 'y'],\r\n    area: ['x', 'y']\r\n};\r\nexports.DEFAULT_SUPPORTED_CHANNEL_TYPE = {\r\n    bar: util_1.toMap(['row', 'column', 'x', 'y', 'size', 'color', 'detail']),\r\n    line: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\r\n    area: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\r\n    tick: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\r\n    circle: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\r\n    square: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\r\n    point: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail', 'shape']),\r\n    text: util_1.toMap(['row', 'column', 'size', 'color', 'text'])\r\n};\r\nfunction getEncodingMappingError(spec, requiredChannelMap, supportedChannelMap) {\r\n    if (requiredChannelMap === void 0) { requiredChannelMap = exports.DEFAULT_REQUIRED_CHANNEL_MAP; }\r\n    if (supportedChannelMap === void 0) { supportedChannelMap = exports.DEFAULT_SUPPORTED_CHANNEL_TYPE; }\r\n    var mark = spec.mark;\r\n    var encoding = spec.encoding;\r\n    var requiredChannels = requiredChannelMap[mark];\r\n    var supportedChannels = supportedChannelMap[mark];\r\n    for (var i in requiredChannels) {\r\n        if (!(requiredChannels[i] in encoding)) {\r\n            return 'Missing encoding channel \\\"' + requiredChannels[i] +\r\n                '\\\" for mark \\\"' + mark + '\\\"';\r\n        }\r\n    }\r\n    for (var channel in encoding) {\r\n        if (!supportedChannels[channel]) {\r\n            return 'Encoding channel \\\"' + channel +\r\n                '\\\" is not supported by mark type \\\"' + mark + '\\\"';\r\n        }\r\n    }\r\n    if (mark === mark_1.BAR && !encoding.x && !encoding.y) {\r\n        return 'Missing both x and y for bar';\r\n    }\r\n    return null;\r\n}\r\nexports.getEncodingMappingError = getEncodingMappingError;\r\n\n},{\"./mark\":36,\"./util\":56}]},{},[10])(10)\n});\n\n","module.exports = {\n   hcluster: require(\"./hcluster\"),\n   Kmeans: require(\"./kmeans\"),\n   kmeans: require(\"./kmeans\").kmeans\n};","module.exports = {\n  euclidean: function(v1, v2) {\n      var total = 0;\n      for (var i = 0; i < v1.length; i++) {\n         total += Math.pow(v2[i] - v1[i], 2);      \n      }\n      return Math.sqrt(total);\n   },\n   manhattan: function(v1, v2) {\n     var total = 0;\n     for (var i = 0; i < v1.length ; i++) {\n        total += Math.abs(v2[i] - v1[i]);      \n     }\n     return total;\n   },\n   max: function(v1, v2) {\n     var max = 0;\n     for (var i = 0; i < v1.length; i++) {\n        max = Math.max(max , Math.abs(v2[i] - v1[i]));      \n     }\n     return max;\n   }\n};","var distances = require(\"./distance\");\n\nvar HierarchicalClustering = function(distance, linkage, threshold) {\n   this.distance = distance;\n   this.linkage = linkage;\n   this.threshold = threshold == undefined ? Infinity : threshold;\n}\n\nHierarchicalClustering.prototype = {\n   cluster : function(items, snapshotPeriod, snapshotCb) {\n      this.clusters = [];\n      this.dists = [];  // distances between each pair of clusters\n      this.mins = []; // closest cluster for each cluster\n      this.index = []; // keep a hash of all clusters by key\n      \n      for (var i = 0; i < items.length; i++) {\n         var cluster = {\n            value: items[i],\n            key: i,\n            index: i,\n            size: 1\n         };\n         this.clusters[i] = cluster;\n         this.index[i] = cluster;\n         this.dists[i] = [];\n         this.mins[i] = 0;\n      }\n\n      for (var i = 0; i < this.clusters.length; i++) {\n         for (var j = 0; j <= i; j++) {\n            var dist = (i == j) ? Infinity : \n               this.distance(this.clusters[i].value, this.clusters[j].value);\n            this.dists[i][j] = dist;\n            this.dists[j][i] = dist;\n\n            if (dist < this.dists[i][this.mins[i]]) {\n               this.mins[i] = j;               \n            }\n         }\n      }\n\n      var merged = this.mergeClosest();\n      var i = 0;\n      while (merged) {\n        if (snapshotCb && (i++ % snapshotPeriod) == 0) {\n           snapshotCb(this.clusters);           \n        }\n        merged = this.mergeClosest();\n      }\n    \n      this.clusters.forEach(function(cluster) {\n        // clean up metadata used for clustering\n        delete cluster.key;\n        delete cluster.index;\n      });\n\n      return this.clusters;\n   },\n  \n   mergeClosest: function() {\n      // find two closest clusters from cached mins\n      var minKey = 0, min = Infinity;\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key = this.clusters[i].key,\n             dist = this.dists[key][this.mins[key]];\n         if (dist < min) {\n            minKey = key;\n            min = dist;\n         }\n      }\n      if (min >= this.threshold) {\n         return false;         \n      }\n\n      var c1 = this.index[minKey],\n          c2 = this.index[this.mins[minKey]];\n\n      // merge two closest clusters\n      var merged = {\n         left: c1,\n         right: c2,\n         key: c1.key,\n         size: c1.size + c2.size\n      };\n\n      this.clusters[c1.index] = merged;\n      this.clusters.splice(c2.index, 1);\n      this.index[c1.key] = merged;\n\n      // update distances with new merged cluster\n      for (var i = 0; i < this.clusters.length; i++) {\n         var ci = this.clusters[i];\n         var dist;\n         if (c1.key == ci.key) {\n            dist = Infinity;            \n         }\n         else if (this.linkage == \"single\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] > this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];\n            }\n         }\n         else if (this.linkage == \"complete\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] < this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];              \n            }\n         }\n         else if (this.linkage == \"average\") {\n            dist = (this.dists[c1.key][ci.key] * c1.size\n                   + this.dists[c2.key][ci.key] * c2.size) / (c1.size + c2.size);\n         }\n         else {\n            dist = this.distance(ci.value, c1.value);            \n         }\n\n         this.dists[c1.key][ci.key] = this.dists[ci.key][c1.key] = dist;\n      }\n\n    \n      // update cached mins\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key1 = this.clusters[i].key;        \n         if (this.mins[key1] == c1.key || this.mins[key1] == c2.key) {\n            var min = key1;\n            for (var j = 0; j < this.clusters.length; j++) {\n               var key2 = this.clusters[j].key;\n               if (this.dists[key1][key2] < this.dists[key1][min]) {\n                  min = key2;                  \n               }\n            }\n            this.mins[key1] = min;\n         }\n         this.clusters[i].index = i;\n      }\n    \n      // clean up metadata used for clustering\n      delete c1.key; delete c2.key;\n      delete c1.index; delete c2.index;\n\n      return true;\n   }\n}\n\nvar hcluster = function(items, distance, linkage, threshold, snapshot, snapshotCallback) {\n   distance = distance || \"euclidean\";\n   linkage = linkage || \"average\";\n\n   if (typeof distance == \"string\") {\n     distance = distances[distance];\n   }\n   var clusters = (new HierarchicalClustering(distance, linkage, threshold))\n                  .cluster(items, snapshot, snapshotCallback);\n      \n   if (threshold === undefined) {\n      return clusters[0]; // all clustered into one\n   }\n   return clusters;\n}\n\nmodule.exports = hcluster;\n","var distances = require(\"./distance\");\n\nfunction KMeans(centroids) {\n   this.centroids = centroids || [];\n}\n\nKMeans.prototype.randomCentroids = function(points, k) {\n   var centroids = points.slice(0); // copy\n   centroids.sort(function() {\n      return (Math.round(Math.random()) - 0.5);\n   });\n   return centroids.slice(0, k);\n}\n\nKMeans.prototype.classify = function(point, distance) {\n   var min = Infinity,\n       index = 0;\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   for (var i = 0; i < this.centroids.length; i++) {\n      var dist = distance(point, this.centroids[i]);\n      if (dist < min) {\n         min = dist;\n         index = i;\n      }\n   }\n\n   return index;\n}\n\nKMeans.prototype.cluster = function(points, k, distance, snapshotPeriod, snapshotCb) {\n   k = k || Math.max(2, Math.ceil(Math.sqrt(points.length / 2)));\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   this.centroids = this.randomCentroids(points, k);\n\n   var assignment = new Array(points.length);\n   var clusters = new Array(k);\n\n   var iterations = 0;\n   var movement = true;\n   while (movement) {\n      // update point-to-centroid assignments\n      for (var i = 0; i < points.length; i++) {\n         assignment[i] = this.classify(points[i], distance);\n      }\n\n      // update location of each centroid\n      movement = false;\n      for (var j = 0; j < k; j++) {\n         var assigned = [];\n         for (var i = 0; i < assignment.length; i++) {\n            if (assignment[i] == j) {\n               assigned.push(points[i]);\n            }\n         }\n\n         if (!assigned.length) {\n            continue;\n         }\n\n         var centroid = this.centroids[j];\n         var newCentroid = new Array(centroid.length);\n\n         for (var g = 0; g < centroid.length; g++) {\n            var sum = 0;\n            for (var i = 0; i < assigned.length; i++) {\n               sum += assigned[i][g];\n            }\n            newCentroid[g] = sum / assigned.length;\n\n            if (newCentroid[g] != centroid[g]) {\n               movement = true;\n            }\n         }\n\n         this.centroids[j] = newCentroid;\n         clusters[j] = assigned;\n      }\n\n      if (snapshotCb && (iterations++ % snapshotPeriod == 0)) {\n         snapshotCb(clusters);\n      }\n   }\n\n   return clusters;\n}\n\nKMeans.prototype.toJSON = function() {\n   return JSON.stringify(this.centroids);\n}\n\nKMeans.prototype.fromJSON = function(json) {\n   this.centroids = JSON.parse(json);\n   return this;\n}\n\nmodule.exports = KMeans;\n\nmodule.exports.kmeans = function(vectors, k) {\n   return (new KMeans()).cluster(vectors, k);\n}","\"use strict\";\n\nmodule.exports = cluster;\n\nvar vlShorthand = require('vega-lite/src/shorthand'),\n  clusterfck = require('clusterfck'),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\ncluster.distance = require('./distance');\n\nfunction cluster(specs, opt) {\n  // jshint unused:false\n  var dist = cluster.distance.table(specs);\n\n  var clusterTrees = clusterfck.hcluster(specs, function(e1, e2) {\n    var s1 = vlShorthand.shorten(e1),\n      s2 = vlShorthand.shorten(e2);\n    return dist[s1][s2];\n  }, 'average', consts.CLUSTER_THRESHOLD);\n\n  var clusters = clusterTrees.map(function(tree) {\n      return util.traverse(tree, []);\n    })\n   .map(function(cluster) {\n    return cluster.sort(function(spec1, spec2) {\n      // sort each cluster -- have the highest score as 1st item\n      return spec2._info.score - spec1._info.score;\n    });\n  }).filter(function(cluster) {  // filter empty cluster\n    return cluster.length >0;\n  }).sort(function(cluster1, cluster2) {\n    //sort by highest scoring item in each cluster\n    return cluster2[0]._info.score - cluster1[0]._info.score;\n  });\n\n  clusters.dist = dist; //append dist in the array for debugging\n\n  return clusters;\n}","'use strict';\n\nvar c = module.exports = {};\n\nc.SWAPPABLE = 0.05;\nc.DIST_MISSING = 1;\nc.CLUSTER_THRESHOLD = 1;\n\nfunction reduceTupleToTable(r, x) {\n  var a = x[0], b = x[1], d = x[2];\n  r[a] = r[a] || {};\n  r[b] = r[b] || {};\n  r[a][b] = r[b][a] = d;\n  return r;\n}\n\nc.DIST_BY_CHANNEL = [\n  // positional\n  ['x', 'y', c.SWAPPABLE],\n  ['row', 'column', c.SWAPPABLE],\n\n  // ordinal mark properties\n  ['color', 'shape', c.SWAPPABLE],\n  ['color', 'detail', c.SWAPPABLE],\n  ['detail', 'shape', c.SWAPPABLE],\n\n  // quantitative mark properties\n  ['size', 'color', c.SWAPPABLE]\n].reduce(reduceTupleToTable, {});\n","'use strict';\n\nvar vlSpec = require('vega-lite/src/spec'),\n  vlShorthand = require('vega-lite/src/shorthand'),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\nvar distance = {};\nmodule.exports = distance;\n\ndistance.table = function (specs) {\n  var len = specs.length,\n    extendedSpecs = specs.map(function(e) { return distance.extendSpecWithChannelByColumnName(e); }),\n    shorthands = specs.map(vlShorthand.shorten),\n    diff = {}, i, j;\n\n  for (i = 0; i < len; i++) diff[shorthands[i]] = {};\n\n  for (i = 0; i < len; i++) {\n    for (j = i + 1; j < len; j++) {\n      var sj = shorthands[j], si = shorthands[i];\n\n      diff[sj][si] = diff[si][sj] = distance.get(extendedSpecs[i], extendedSpecs[j]);\n    }\n  }\n  return diff;\n};\n\ndistance.get = function (extendedSpec1, extendedSpec2) {\n  var cols = util.union(util.keys(extendedSpec1.channelByField), util.keys(extendedSpec2.channelByField)),\n    dist = 0;\n\n  cols.forEach(function(column) {\n    var e1 = extendedSpec1.channelByField[column], e2 = extendedSpec2.channelByField[column];\n\n    if (e1 && e2) {\n      if (e1.channel != e2.channel) {\n        dist += (consts.DIST_BY_CHANNEL[e1.channel] || {})[e2.channel] || 1;\n      }\n    } else {\n      dist += consts.DIST_MISSING;\n    }\n  });\n\n  // do not group stacked chart with similar non-stacked chart!\n  var isStack1 = vlSpec.isStack(extendedSpec1),\n    isStack2 = vlSpec.isStack(extendedSpec2);\n\n  if (isStack1 || isStack2) {\n    if (isStack1 && isStack2) {\n      if ((extendedSpec1.encoding.color && extendedSpec2.encoding.color &&\n          extendedSpec1.encoding.color.field !== extendedSpec2.encoding.color.field) ||\n          (extendedSpec1.encoding.detail && extendedSpec2.encoding.detail &&\n          extendedSpec1.encoding.detail.field !== extendedSpec2.encoding.detail.field)\n         ) {\n        dist+=1;\n      }\n    } else {\n      dist+=1; // surely different\n    }\n  }\n  return dist;\n};\n\n// get encoding type by fieldname\ndistance.extendSpecWithChannelByColumnName = function(spec) {\n  var _channelByField = {},\n    encoding = spec.encoding;\n\n  util.keys(encoding).forEach(function(channel) {\n    var e = util.duplicate(encoding[channel]);\n    e.channel = channel;\n    _channelByField[e.field || ''] = e;\n    delete e.field;\n  });\n\n  return {\n    mark: spec.mark,\n    channelByField: _channelByField,\n    encoding: spec.encoding\n  };\n};","'use strict';\n\nvar consts = module.exports = {\n  gen: {},\n  cluster: {},\n  rank: {}\n};\n\nconsts.X = 'x';\nconsts.Y = 'y';\nconsts.ROW = 'row';\nconsts.COL = 'column';\nconsts.SIZE = 'size';\nconsts.SHAPE = 'shape';\nconsts.COLOR = 'color';\nconsts.TEXT = 'text';\nconsts.DETAIL = 'detail';\n\n\n// rename these\nconsts.Type = {};\nconsts.Type.Nominal = 'nominal';\nconsts.Type.Ordinal = 'ordinal';\nconsts.Type.Quantitative = 'quantitative';\nconsts.Type.Temporal = 'temporal';\n\n\nconsts.gen.projections = {\n  type: 'object',\n  properties: {\n    omitDotPlot: { //FIXME remove this!\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    maxCardinalityForAutoAddOrdinal: {\n      type: 'integer',\n      default: 50,\n      description: 'max cardinality for an ordinal variable to be considered for auto adding'\n    },\n    alwaysAddHistogram: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nconsts.gen.aggregates = {\n  type: 'object',\n  properties: {\n    config: {\n      type: 'object'\n    },\n    data: {\n      type: 'object'\n    },\n    tableTypes: {\n      type: 'boolean',\n      default: 'both',\n      enum: ['both', 'aggregated', 'disaggregated']\n    },\n    genDimQ: {\n      type: 'string',\n      default: 'auto',\n      enum: ['auto', 'bin', 'cast', 'none'],\n      description: 'Use Q as Dimension either by binning or casting'\n    },\n    minCardinalityForBin: {\n      type: 'integer',\n      default: 20,\n      description: 'minimum cardinality of an ordinal variable if we were to bin'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitMeasureOnly: {\n      type: 'boolean',\n      default: false,\n      description: 'Omit aggregation with measure(s) only'\n    },\n    omitDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Omit aggregation with dimension(s) only'\n    },\n    addCountForDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Add count when there are dimension(s) only'\n    },\n    aggrList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: [undefined, 'mean']\n    },\n    timeUnitList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: ['year']\n    },\n    consistentAutoQ: {\n      type: 'boolean',\n      default: true,\n      description: \"generate similar auto transform for quant\"\n    }\n  }\n};\n\nconsts.gen.encodings = {\n  type: 'object',\n  properties: {\n    markList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['point', 'bar', 'line', 'area', 'text', 'tick'], //filled_map\n      description: 'allowed marks'\n    },\n    encodingTypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['x', 'y', 'row', 'column', 'size', 'color', 'text', 'detail'],\n      description: 'allowed encoding types'\n    },\n    requiredEncodings: {\n      type: 'object',\n      default: undefined,\n      description: 'required encodings for each mark type'\n    },\n    supportedEncodings: {\n      type: 'object',\n      default: undefined,\n      description: 'supported encoding for each mark type'\n    },\n    // TODO: is this used in generation?\n    maxGoodCardinalityForFacets: {\n      type: 'integer',\n      default: 5,\n      description: 'maximum cardinality of an ordinal variable to be put on facet (row/column) effectively'\n    },\n    maxCardinalityForFacets: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of an ordinal variable to be put on facet (row/column)'\n    },\n    maxGoodCardinalityForColor: {\n      type: 'integer',\n      default: 7,\n      description: 'maximum cardinality of an ordinal variable to be put on color effectively'\n    },\n    maxCardinalityForColor: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of an ordinal variable to be put on color'\n    },\n    maxCardinalityForShape: {\n      type: 'integer',\n      default: 6,\n      description: 'maximum cardinality of an ordinal variable to be put on shape'\n    },\n    omitTranpose:  {\n      type: 'boolean',\n      default: true,\n      description: 'Eliminate all transpose by (1) keeping horizontal dot plot only (2) for OxQ charts, always put O on Y (3) show only one DxD, MxM (currently sorted by name)'\n    },\n    // TODO: create chart type name\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitDotPlotWithExtraEncoding: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all dot plots with >1 encoding'\n    },\n    omitMultipleRetinalEncodings: {\n      type: 'boolean',\n      default: true,\n      description: 'omit using multiple retinal variables (size, color, shape)'\n    },\n    // TODO: revise\n    omitNonTextAggrWithAllDimsOnFacets: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all aggregated charts (except text tables) with all dims on facets (row, column)'\n    },\n    // TODO: revise\n    omitOneDimensionCount: {\n      type: 'boolean',\n      default: false,\n      description: 'omit one dimension count'\n    },\n    // TODO remove this and merge with supportedEncodings\n    omitSizeOnBar: {\n      type: 'boolean',\n      default: false,\n      description: 'do not use bar\\'s size'\n    },\n    // TODO: change to omit non-summative stack\n    omitStackedAverage: {\n      type: 'boolean',\n      default: true,\n      description: 'do not stack bar chart with average'\n    },\n    alwaysGenerateTableAsHeatmap: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n","module.exports = {\n  consts: require('./consts'),\n  cluster: require('./cluster/cluster'),\n  gen: require('./gen/gen'),\n  rank: require('./rank/rank'),\n  util: require('./util'),\n  auto: \"-, sum\"\n};\n\n\n","'use strict';\n\nvar vlFieldDef = require('vega-lite/src/fielddef');\nvar vlSchemaUtil = require('vega-lite/src/schema/schemautil');\nvar vlShorthand = require('vega-lite/src/shorthand');\n\nvar consts = require('../consts');\nvar Type = consts.Type;\nvar util = require('../util');\n\nvar AUTO = '*';\n\nmodule.exports = genAggregates;\n\n\nfunction genAggregates(output, fieldDefs, stats, opt) {\n  opt = vlSchemaUtil.extend(opt||{}, consts.gen.aggregates);\n  var tf = new Array(fieldDefs.length);\n  var hasNorO = util.any(fieldDefs, function(f) {\n    return f.type === Type.Nominal || f.type == Type.Ordinal;\n  });\n\n  function emit(fieldSet) {\n    fieldSet = util.duplicate(fieldSet);\n    fieldSet.key = fieldSet.map(function(fieldDef) {\n      return vlShorthand.shortenFieldDef(fieldDef);\n    }).join(vlShorthand.DELIM);\n    output.push(fieldSet);\n  }\n\n  function checkAndPush() {\n    if (opt.omitMeasureOnly || opt.omitDimensionOnly) {\n      var hasMeasure = false, hasDimension = false, hasRaw = false;\n      tf.forEach(function(f) {\n        if (vlFieldDef.isDimension(f)) {\n          hasDimension = true;\n        } else {\n          hasMeasure = true;\n          if (!f.aggregate) hasRaw = true;\n        }\n      });\n      if (!hasDimension && !hasRaw && opt.omitMeasureOnly) return;\n      if (!hasMeasure) {\n        if (opt.addCountForDimensionOnly) {\n          tf.push(vlFieldDef.count());\n          emit(tf);\n          tf.pop();\n        }\n        if (opt.omitDimensionOnly) return;\n      }\n    }\n    if (opt.omitDotPlot && tf.length === 1) return;\n    emit(tf);\n  }\n\n  function assignAggrQ(i, hasAggr, autoMode, a) {\n    var canHaveAggr = hasAggr === true || hasAggr === null,\n      cantHaveAggr = hasAggr === false || hasAggr === null;\n    if (a) {\n      if (canHaveAggr) {\n        tf[i].aggregate = a;\n        assignField(i + 1, true, autoMode);\n        delete tf[i].aggregate;\n      }\n    } else { // if(a === undefined)\n      if (cantHaveAggr) {\n        assignField(i + 1, false, autoMode);\n      }\n    }\n  }\n\n  function assignBinQ(i, hasAggr, autoMode) {\n    tf[i].bin = true;\n    assignField(i + 1, hasAggr, autoMode);\n    delete tf[i].bin;\n  }\n\n  function assignQ(i, hasAggr, autoMode) {\n    var f = fieldDefs[i],\n      canHaveAggr = hasAggr === true || hasAggr === null;\n\n    tf[i] = {field: f.field, type: f.type};\n\n    if (f.aggregate === 'count') { // if count is included in the selected fields\n      if (canHaveAggr) {\n        tf[i].aggregate = f.aggregate;\n        assignField(i + 1, true, autoMode);\n      }\n    } else if (f._aggregate) {\n      // TODO support array of f._aggrs too\n      assignAggrQ(i, hasAggr, autoMode, f._aggregate);\n    } else if (f._raw) {\n      assignAggrQ(i, hasAggr, autoMode, undefined);\n    } else if (f._bin) {\n      assignBinQ(i, hasAggr, autoMode);\n    } else {\n      opt.aggrList.forEach(function(a) {\n        if (!opt.consistentAutoQ || autoMode === AUTO || autoMode === a) {\n          assignAggrQ(i, hasAggr, a /*assign autoMode*/, a);\n        }\n      });\n\n      if ((!opt.consistentAutoQ || util.isin(autoMode, [AUTO, 'bin', 'cast', 'autocast'])) && !hasNorO) {\n        var highCardinality = vlFieldDef.cardinality(f, stats) > opt.minCardinalityForBin;\n\n        var isAuto = opt.genDimQ === 'auto',\n          genBin = opt.genDimQ  === 'bin' || (isAuto && highCardinality),\n          genCast = opt.genDimQ === 'cast' || (isAuto && !highCardinality);\n\n        if (genBin && util.isin(autoMode, [AUTO, 'bin', 'autocast'])) {\n          assignBinQ(i, hasAggr, isAuto ? 'autocast' : 'bin');\n        }\n        if (genCast && util.isin(autoMode, [AUTO, 'cast', 'autocast'])) {\n          tf[i].type = Type.Ordinal;\n          assignField(i + 1, hasAggr, isAuto ? 'autocast' : 'cast');\n          tf[i].type = Type.Quantitative;\n        }\n      }\n    }\n  }\n\n  function assignTimeUnitT(i, hasAggr, autoMode, timeUnit) {\n    tf[i].timeUnit = timeUnit;\n    assignField(i+1, hasAggr, autoMode);\n    delete tf[i].timeUnit;\n  }\n\n  function assignT(i, hasAggr, autoMode) {\n    var f = fieldDefs[i];\n    tf[i] = {field: f.field, type: f.type};\n\n    // TODO support array of f._timeUnits\n    if (f._timeUnit) {\n      assignTimeUnitT(i, hasAggr, autoMode, f._timeUnit);\n    } else {\n      opt.timeUnitList.forEach(function(timeUnit) {\n        if (timeUnit === undefined) {\n          if (!hasAggr) { // can't aggregate over raw time\n            assignField(i+1, false, autoMode);\n          }\n        } else {\n          assignTimeUnitT(i, hasAggr, autoMode, timeUnit);\n        }\n      });\n    }\n\n    // FIXME what if you aggregate time?\n  }\n\n  function assignField(i, hasAggr, autoMode) {\n    if (i === fieldDefs.length) { // If all fields are assigned\n      checkAndPush();\n      return;\n    }\n\n    var f = fieldDefs[i];\n    // Otherwise, assign i-th field\n    switch (f.type) {\n      //TODO \"D\", \"G\"\n      case Type.Quantitative:\n        assignQ(i, hasAggr, autoMode);\n        break;\n\n      case Type.Temporal:\n        assignT(i, hasAggr, autoMode);\n        break;\n      case Type.Ordinal:\n        /* falls through */\n      case Type.Nominal:\n        /* falls through */\n      default:\n        tf[i] = f;\n        assignField(i + 1, hasAggr, autoMode);\n        break;\n    }\n  }\n\n  var hasAggr = opt.tableTypes === 'aggregated' ? true : opt.tableTypes === 'disaggregated' ? false : null;\n  assignField(0, hasAggr, AUTO);\n\n  return output;\n}\n","\"use strict\";\n\nvar vlFieldDef = require('vega-lite/src/fielddef');\nvar vlEncoding = require('vega-lite/src/encoding');\nvar util = require('../util');\n\nvar genMarks = require('./marks'),\n  isDimension = vlFieldDef.isDimension,\n  isMeasure = vlFieldDef.isMeasure;\n\nvar consts = require('../consts');\nvar Type = consts.Type;\n\nmodule.exports = genEncodings;\n\n// FIXME remove dimension, measure and use information in vega-lite instead!\nvar rules = {\n  x: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  y: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  row: {\n    dimension: true,\n    multiple: true\n  },\n  column: {\n    dimension: true,\n    multiple: true\n  },\n  shape: {\n    dimension: true,\n    rules: shapeRules\n  },\n  size: {\n    measure: true,\n    rules: retinalEncRules\n  },\n  color: {\n    dimension: true,\n    measure: true,\n    rules: colorRules\n  },\n  text: {\n    measure: true\n  },\n  detail: {\n    dimension: true\n  }\n  //geo: {\n  //  geo: true\n  //},\n  //arc: { // pie\n  //\n  //}\n};\n\nfunction retinalEncRules(encoding, fieldDef, stats, opt) {\n  if (opt.omitMultipleRetinalEncodings) {\n    if (encoding.color || encoding.size || encoding.shape) return false;\n  }\n  return true;\n}\n\nfunction colorRules(encoding, fieldDef, stats, opt) {\n  if(!retinalEncRules(encoding, fieldDef, stats, opt)) return false;\n\n  return vlFieldDef.isMeasure(fieldDef) ||\n    vlFieldDef.cardinality(fieldDef, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction shapeRules(encoding, fieldDef, stats, opt) {\n  if(!retinalEncRules(encoding, fieldDef, stats, opt)) return false;\n\n  if (fieldDef.bin && fieldDef.type === Type.Quantitative) return false;\n  if (fieldDef.timeUnit && fieldDef.type === Type.Temporal) return false;\n  return vlFieldDef.cardinality(fieldDef, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction dimMeaTransposeRule(encoding) {\n  // create horizontal histogram for ordinal\n  if ((encoding.y.type === Type.Nominal || encoding.y.type === Type.Ordinal) && isMeasure(encoding.x)) {\n    return true;\n  }\n\n  // vertical histogram for Q and T\n  if (isMeasure(encoding.y) &&\n      !(encoding.x.type === Type.Nominal || encoding.x.type === Type.Ordinal) &&\n      isDimension(encoding.x)\n      ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction generalRules(encoding, stats, opt) {\n  // encoding.text is only used for TEXT TABLE\n  if (encoding.text) {\n    return genMarks.satisfyRules(encoding, 'text', stats, opt);\n  }\n\n  // CARTESIAN PLOT OR MAP\n  if (encoding.x || encoding.y || encoding.geo || encoding.arc) {\n\n    if (encoding.row || encoding.column) { //have facet(s)\n\n      // don't use facets before filling up x,y\n      if (!encoding.x || !encoding.y) return false;\n\n      if (opt.omitNonTextAggrWithAllDimsOnFacets) {\n        // remove all aggregated charts with all dims on facets (row, column)\n        if (genEncodings.isAggrWithAllDimOnFacets(encoding)) return false;\n      }\n    }\n\n    if (encoding.x && encoding.y) {\n      var isDimX = !!isDimension(encoding.x),\n        isDimY = !!isDimension(encoding.y);\n\n      if (isDimX && isDimY && !vlEncoding.isAggregate(encoding)) {\n        // FIXME actually check if there would be occlusion #90\n        return false;\n      }\n\n      if (opt.omitTranpose) {\n        if (isDimX ^ isDimY) { // dim x mea\n          if (!dimMeaTransposeRule(encoding)) {\n            return false;\n          }\n        } else if (encoding.y.type=== Type.Temporal|| encoding.x.type === Type.Temporal) {\n          if (encoding.y.type=== Type.Temporal && encoding.x.type !== Type.Temporal) {\n            return false;\n          }\n        } else { // show only one OxO, QxQ\n          if (encoding.x.field > encoding.y.field) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    // DOT PLOTS\n    // // plot with one axis = dot plot\n    if (opt.omitDotPlot) {\n      return false;\n    }\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && encoding.y) {\n      return false;\n    }\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && util.keys(encoding).length > 1) {\n      return false;\n    }\n\n    if (opt.omitOneDimensionCount) {\n      // one dimension \"count\"\n      if (encoding.x && encoding.x.aggregate == 'count' && !encoding.y) {\n        return false;\n      }\n      if (encoding.y && encoding.y.aggregate == 'count' && !encoding.x) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  return false;\n}\n\ngenEncodings.isAggrWithAllDimOnFacets = function (encoding) {\n  var hasAggr = false, hasOtherO = false;\n  for (var channel in encoding) {\n    var fieldDef = encoding[channel];\n    if (fieldDef.aggregate) {\n      hasAggr = true;\n    }\n    if (vlFieldDef.isDimension(fieldDef) && (channel !== consts.ROW && channel !== consts.COL)) {\n      hasOtherO = true;\n    }\n    if (hasAggr && hasOtherO) break;\n  }\n\n  return hasAggr && !hasOtherO;\n};\n\n\nfunction genEncodings(encodings, fieldDefs, stats, opt) {\n  // generate a collection vega-lite's encoding\n  var tmpEncoding = {};\n\n  function assignField(i) {\n    // If all fields are assigned, save\n    if (i === fieldDefs.length) {\n      // at the minimal all chart should have x, y, geo, text or arc\n      if (generalRules(tmpEncoding, stats, opt)) {\n        encodings.push(util.duplicate(tmpEncoding));\n      }\n      return;\n    }\n\n    // Otherwise, assign i-th field\n    var fieldDef = fieldDefs[i];\n    for (var j in opt.encodingTypeList) {\n      var channel = opt.encodingTypeList[j],\n        isDim = isDimension(fieldDef);\n\n      //TODO: support \"multiple\" assignment\n      if (!(channel in tmpEncoding) && // encoding not used\n        ((isDim && rules[channel].dimension) || (!isDim && rules[channel].measure)) &&\n        (!rules[channel].rules || rules[channel].rules(tmpEncoding, fieldDef, stats, opt))\n      ) {\n        tmpEncoding[channel] = fieldDef;\n        assignField(i + 1);\n        delete tmpEncoding[channel];\n      }\n    }\n  }\n\n  assignField(0);\n\n  return encodings;\n}\n","'use strict';\n\nvar util = require('../util');\n\n/**\n * Module for generating visualizations\n */\n\nvar gen = module.exports = {\n  // data variations\n  aggregates: require('./aggregates'),\n  projections: require('./projections'),\n  // encodings / visual variations\n  specs: require('./specs'),\n  encodings: require('./encodings'),\n  marks: require('./marks')\n};\n\n\n// TODO(kanitw): revise if this is still working\ngen.charts = function(fieldDefs, opt, config, flat) {\n  opt = util.gen.getOpt(opt);\n  flat = flat === undefined ? {encodings: 1} : flat;\n\n  // TODO generate\n\n  // generate permutation of encoding mappings\n  var fieldSets = opt.genAggr ? gen.aggregates([], fieldDefs, opt) : [fieldDefs],\n    encodings, charts, level = 0;\n\n  if (flat === true || (flat && flat.aggregate)) {\n    encodings = fieldSets.reduce(function(output, fieldDefs) {\n      return gen.encs(output, fieldDefs, opt);\n    }, []);\n  } else {\n    encodings = fieldSets.map(function(fieldDefs) {\n      return gen.encs([], fieldDefs, opt);\n    }, true);\n    level += 1;\n  }\n\n  if (flat === true || (flat && flat.encodings)) {\n    charts = util.nestedReduce(encodings, function(output, encoding) {\n      return gen.marks(output, encoding, opt, config);\n    }, level, true);\n  } else {\n    charts = util.nestedMap(encodings, function(encoding) {\n      return gen.marks([], encoding, opt, config);\n    }, level, true);\n    level += 1;\n  }\n  return charts;\n};","\"use strict\";\n\nvar vlEncoding = require('vega-lite/src/encoding');\nvar vlFieldDef = require('vega-lite/src/fielddef');\nvar vlValidate = require('vega-lite/src/validate');\n\nvar isDimension = vlFieldDef.isDimension;\nvar util = require('../util');\n\nvar consts = require('../consts');\nvar Type = consts.Type;\n\nvar genMarks = module.exports = getMarks;\n\nvar marksRule = genMarks.rule = {\n  point:  pointRule,\n  bar:    barRule,\n  line:   lineRule,\n  area:   areaRule, // area is similar to line\n  text:   textRule,\n  tick:   tickRule\n};\n\nfunction getMarks(encoding, stats, opt) {\n  return opt.markList.filter(function(mark){\n    return genMarks.satisfyRules(encoding, mark, stats, opt);\n  });\n}\n\ngenMarks.satisfyRules = function (encoding, mark, stats, opt) {\n  return vlValidate.getEncodingMappingError({\n      mark: mark,\n      encoding: encoding\n    }) === null &&\n    (!marksRule[mark] || marksRule[mark](encoding, stats, opt));\n};\n\nfunction facetRule(fieldDef, stats, opt) {\n  return vlFieldDef.cardinality(fieldDef, stats) <= opt.maxCardinalityForFacets;\n}\n\nfunction facetsRule(encoding, stats, opt) {\n  if(encoding.row && !facetRule(encoding.row, stats, opt)) return false;\n  if(encoding.column && !facetRule(encoding.column, stats, opt)) return false;\n  return true;\n}\n\nfunction pointRule(encoding, stats, opt) {\n  if(!facetsRule(encoding, stats, opt)) return false;\n  if (encoding.x && encoding.y) {\n    // have both x & y ==> scatter plot / bubble plot\n\n    var xIsDim = isDimension(encoding.x),\n      yIsDim = isDimension(encoding.y);\n\n    // For OxO\n    if (xIsDim && yIsDim) {\n      // shape doesn't work with both x, y as ordinal\n      if (encoding.shape) {\n        return false;\n      }\n\n      // TODO(kanitw): check that there is quant at least ...\n      if (encoding.color && isDimension(encoding.color)) {\n        return false;\n      }\n    }\n\n  } else { // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && encoding.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && util.keys(encoding).length > 1) return false;\n\n    // dot plot with shape is non-sense\n    if (encoding.shape) return false;\n  }\n  return true;\n}\n\nfunction tickRule(encoding, stats, opt) {\n  // jshint unused:false\n  if (encoding.x || encoding.y) {\n    if(vlEncoding.isAggregate(encoding)) return false;\n\n    var xIsDim = isDimension(encoding.x),\n      yIsDim = isDimension(encoding.y);\n\n    return (!xIsDim && (!encoding.y || yIsDim)) ||\n      (!yIsDim && (!encoding.x || xIsDim));\n  }\n  return false;\n}\n\nfunction barRule(encoding, stats, opt) {\n  if(!facetsRule(encoding, stats, opt)) return false;\n\n  // bar requires at least x or y\n  if (!encoding.x && !encoding.y) return false;\n\n  if (opt.omitSizeOnBar && encoding.size !== undefined) return false;\n\n  // FIXME actually check if there would be occlusion #90\n  // need to aggregate on either x or y\n  var aggEitherXorY =\n    (!encoding.x || encoding.x.aggregate === undefined) ^\n    (!encoding.y || encoding.y.aggregate === undefined);\n\n\n  if (aggEitherXorY) {\n    var eitherXorYisDimOrNull =\n      (!encoding.x || isDimension(encoding.x)) ^\n      (!encoding.y || isDimension(encoding.y));\n\n    if (eitherXorYisDimOrNull) {\n      var aggregate = encoding.x.aggregate || encoding.y.aggregate;\n      return !(opt.omitStackedAverage && aggregate ==='mean' && encoding.color);\n    }\n  }\n\n  return false;\n}\n\nfunction lineRule(encoding, stats, opt) {\n  if(!facetsRule(encoding, stats, opt)) return false;\n\n  // TODO(kanitw): add omitVerticalLine as config\n\n  // FIXME truly ordinal data is fine here too.\n  // Line chart should be only horizontal\n  // and use only temporal data\n  return encoding.x.type == Type.Temporal && encoding.x.timeUnit && encoding.y.type == Type.Quantitative && encoding.y.aggregate;\n}\n\nfunction areaRule(encoding, stats, opt) {\n  if(!facetsRule(encoding, stats, opt)) return false;\n\n  if(!lineRule(encoding, stats, opt)) return false;\n\n  return !(opt.omitStackedAverage && encoding.y.aggregate ==='mean' && encoding.color);\n}\n\nfunction textRule(encoding, stats, opt) {\n  // at least must have row or column and aggregated text values\n  return (encoding.row || encoding.column) && encoding.text && encoding.text.aggregate && !encoding.x && !encoding.y && !encoding.size &&\n    (!opt.alwaysGenerateTableAsHeatmap || !encoding.color);\n}\n","'use strict';\n\nvar vlFieldDef = require('vega-lite/src/fielddef');\nvar vlSchemaUtil = require('vega-lite/src/schema/schemautil');\n\nvar util = require('../util'),\n  consts = require('../consts'),\n  isDimension = vlFieldDef.isDimension;\n\nmodule.exports = projections;\n\n// TODO support other mode of projections generation\n// powerset, chooseK, chooseKorLess are already included in the util\n\n/**\n * fields\n * @param  {[type]} fieldDefs array of fields and query information\n * @return {[type]}        [description]\n */\nfunction projections(fieldDefs, stats, opt) {\n  opt = vlSchemaUtil.extend(opt||{}, consts.gen.projections);\n\n  // First categorize field, selected, fieldsToAdd, and save indices\n  var selected = [], fieldsToAdd = [], fieldSets = [],\n    hasSelectedDimension = false,\n    hasSelectedMeasure = false,\n    indices = {};\n\n  fieldDefs.forEach(function(fieldDef, index){\n    //save indices for stable sort later\n    indices[fieldDef.field] = index;\n\n    if (fieldDef.selected) {\n      selected.push(fieldDef);\n      if (isDimension(fieldDef) || fieldDef.type ==='temporal') { // FIXME / HACK\n        hasSelectedDimension = true;\n      } else {\n        hasSelectedMeasure = true;\n      }\n    } else if (fieldDef.selected !== false && !vlFieldDef.isCount(fieldDef)) {\n      if (vlFieldDef.isDimension(fieldDef) &&\n          !opt.maxCardinalityForAutoAddOrdinal &&\n          vlFieldDef.cardinality(fieldDef, stats, 15) > opt.maxCardinalityForAutoAddOrdinal\n        ) {\n        return;\n      }\n      fieldsToAdd.push(fieldDef);\n    }\n  });\n\n  fieldsToAdd.sort(compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices));\n\n  var setsToAdd = util.chooseKorLess(fieldsToAdd, 1);\n\n  setsToAdd.forEach(function(setToAdd) {\n    var fieldSet = selected.concat(setToAdd);\n    if (fieldSet.length > 0) {\n      if (opt.omitDotPlot && fieldSet.length === 1) return;\n      fieldSets.push(fieldSet);\n    }\n  });\n\n  fieldSets.forEach(function(fieldSet) {\n      // always append projection's key to each projection returned, d3 style.\n    fieldSet.key = projections.key(fieldSet);\n  });\n\n  return fieldSets;\n}\n\nvar typeIsMeasureScore = {\n  nominal: 0,\n  ordinal: 0,\n  temporal: 2,\n  quantitative: 3\n};\n\nfunction compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices) {\n  return function(a, b){\n    // sort by type of the data\n    if (a.type !== b.type) {\n      if (!hasSelectedDimension) {\n        return typeIsMeasureScore[a.type] - typeIsMeasureScore[b.type];\n      } else { //if (!hasSelectedMeasure) {\n        return typeIsMeasureScore[b.type] - typeIsMeasureScore[a.type];\n      }\n    }\n    //make the sort stable\n    return indices[a.field] - indices[b.field];\n  };\n}\n\nprojections.key = function(projection) {\n  return projection.map(function(fieldDef) {\n    return vlFieldDef.isCount(fieldDef) ? 'count' : fieldDef.field;\n  }).join(',');\n};\n\n","'use strict';\n\nvar vlFieldDef = require('vega-lite/src/fielddef');\nvar vlSchemaUtil = require('vega-lite/src/schema/schemautil');\nvar util = require('../util');\n\nvar genEncodings = require('./encodings'),\n  getMarks = require('./marks'),\n  rank = require('../rank/rank'),\n  consts = require('../consts');\n\nmodule.exports = genSpecsFromFieldDefs;\n\n/** Design Encodings for a set of field definition */\n\nfunction genSpecsFromFieldDefs(output, fieldDefs, stats, opt, nested) {\n  // opt must be augmented before being passed to genEncodings or getMarks\n  opt = vlSchemaUtil.extend(opt||{}, consts.gen.encodings);\n  var encodings = genEncodings([], fieldDefs, stats, opt);\n\n  if (nested) {\n    return encodings.reduce(function(dict, encoding) {\n      dict[encoding] = genSpecsFromEncodings([], encoding, stats, opt);\n      return dict;\n    }, {});\n  } else {\n    return encodings.reduce(function(list, encoding) {\n      return genSpecsFromEncodings(list, encoding, stats, opt);\n    }, []);\n  }\n}\n\nfunction genSpecsFromEncodings(output, encoding, stats, opt) {\n  getMarks(encoding, stats, opt)\n    .forEach(function(mark) {\n      var spec = util.duplicate({\n          // Clone config & encoding to unique objects\n          encoding: encoding,\n          config: opt.config\n        });\n\n      spec.mark = mark;\n      // Data object is the same across charts: pass by reference\n      spec.data = opt.data;\n\n      spec = finalTouch(spec, stats, opt);\n      var score = rank.encoding(spec, stats, opt);\n\n      spec._info = score;\n      output.push(spec);\n    });\n  return output;\n}\n\n//FIXME this should be refactors\nfunction finalTouch(spec, stats, opt) {\n  if (spec.mark === 'text' && opt.alwaysGenerateTableAsHeatmap) {\n    spec.encoding.color = spec.encoding.text;\n  }\n\n  // don't include zero if stdev/mean < 0.01\n  // https://github.com/uwdata/visrec/issues/69\n  var encoding = spec.encoding;\n  ['x', 'y'].forEach(function(channel) {\n    var fieldDef = encoding[channel];\n\n    // TODO add a parameter for this case\n    if (fieldDef && vlFieldDef.isMeasure(fieldDef) && !vlFieldDef.isCount(fieldDef)) {\n      var stat = stats[fieldDef.field];\n      if (stat && stat.stdev / stat.mean < 0.01) {\n        fieldDef.scale = {zero: false};\n      }\n    }\n  });\n  return spec;\n}\n","module.exports = {\n  encoding: require('./rankEncodings')\n};\n\n\n","// FIXME: rename to rankSpecs\n\n'use strict';\n\nvar vlEncoding = require('vega-lite/src/encoding'),\n  vlFieldDef = require('vega-lite/src/fielddef'),\n  vlChannel = require('vega-lite/src/channel'),\n  isDimension = vlFieldDef.isDimension,\n  util = require('../util');\n\nvar vlShorthand = require('vega-lite/src/shorthand');\n\nvar consts = require('../consts');\nvar Type = consts.Type;\n\nmodule.exports = rankEncodings;\n\n// bad score not specified in the table above\nvar UNUSED_POSITION = 0.5;\n\nvar MARK_SCORE = {\n  line: 0.99,\n  area: 0.98,\n  bar: 0.97,\n  tick: 0.96,\n  point: 0.95,\n  circle: 0.94,\n  square: 0.94,\n  text: 0.8\n};\n\nfunction rankEncodings(spec, stats, opt, selected) {\n  var features = [],\n    channels = util.keys(spec.encoding),\n    mark = spec.mark,\n    encoding = spec.encoding;\n\n  var encodingMappingByField = vlEncoding.reduce(spec.encoding, function(o, fieldDef, channel) {\n    var key = vlShorthand.shortenFieldDef(fieldDef);\n    var mappings = o[key] = o[key] || [];\n    mappings.push({channel: channel, fieldDef: fieldDef});\n    return o;\n  }, {});\n\n  // data - encoding mapping score\n  util.forEach(encodingMappingByField, function(mappings) {\n    var reasons = mappings.map(function(m) {\n        return m.channel + vlShorthand.Assign + vlShorthand.shortenFieldDef(m.fieldDef) +\n          ' ' + (selected && selected[m.fieldDef.field] ? '[x]' : '[ ]');\n      }),\n      scores = mappings.map(function(m) {\n        var role = vlFieldDef.isDimension(m.fieldDef) ? 'dimension' : 'measure';\n\n        var score = rankEncodings.score[role](m.fieldDef, m.channel, spec.mark, stats, opt);\n\n        return !selected || selected[m.fieldDef.field] ? score : Math.pow(score, 0.125);\n      });\n\n    features.push({\n      reason: reasons.join(\" | \"),\n      score: Math.max.apply(null, scores)\n    });\n  });\n\n  // plot type\n  if (mark === 'text') {\n    // TODO\n  } else {\n    if (encoding.x && encoding.y) {\n      if (isDimension(encoding.x) ^ isDimension(encoding.y)) {\n        features.push({\n          reason: 'OxQ plot',\n          score: 0.8\n        });\n      }\n    }\n  }\n\n  // penalize not using positional only penalize for non-text\n  if (channels.length > 1 && mark !== 'text') {\n    if ((!encoding.x || !encoding.y) && !encoding.geo && !encoding.text) {\n      features.push({\n        reason: 'unused position',\n        score: UNUSED_POSITION\n      });\n    }\n  }\n\n  // mark type score\n  features.push({\n    reason: 'mark='+mark,\n    score: MARK_SCORE[mark]\n  });\n\n  return {\n    score: features.reduce(function(p, f) {\n      return p * f.score;\n    }, 1),\n    features: features\n  };\n}\n\n\nvar D = {}, M = {}, BAD = 0.1, TERRIBLE = 0.01;\n\nD.minor = 0.01;\nD.pos = 1;\nD.Y_T = 0.8;\nD.facet_text = 1;\nD.facet_good = 0.675; // < color_ok, > color_bad\nD.facet_ok = 0.55;\nD.facet_bad = 0.4;\nD.color_good = 0.7;\nD.color_ok = 0.65; // > M.Size\nD.color_bad = 0.3;\nD.color_stack = 0.6;\nD.shape = 0.6;\nD.detail = 0.5;\nD.bad = BAD;\nD.terrible = TERRIBLE;\n\nM.pos = 1;\nM.size = 0.6;\nM.color = 0.5;\nM.text = 0.4;\nM.bad = BAD;\nM.terrible = TERRIBLE;\n\nrankEncodings.dimensionScore = function (fieldDef, channel, mark, stats, opt){\n  var cardinality = vlFieldDef.cardinality(fieldDef, stats);\n  switch (channel) {\n    case vlChannel.X:\n      if (fieldDef.type === Type.Nominal || fieldDef.type === Type.Ordinal)  {\n        return D.pos - D.minor;\n      }\n      return D.pos;\n\n    case vlChannel.Y:\n      if (fieldDef.type === Type.Nominal || fieldDef.type === Type.Ordinal) {\n        return D.pos - D.minor; //prefer ordinal on y\n      }\n      if (fieldDef.type === Type.Temporal) {\n        return D.Y_T; // time should not be on Y\n      }\n      return D.pos - D.minor;\n\n    case vlChannel.COL:\n      if (mark === 'text') return D.facet_text;\n      //prefer column over row due to scrolling issues\n      return cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad;\n\n    case vlChannel.ROW:\n      if (mark === 'text') return D.facet_text;\n      return (cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad) - D.minor;\n\n    case vlChannel.COLOR:\n      var hasOrder = (fieldDef.bin && fieldDef.type=== Type.Quantitative) || (fieldDef.timeUnit && fieldDef.type=== Type.Temporal);\n\n      //FIXME add stacking option once we have control ..\n      var isStacked = mark === 'bar' || mark === 'area';\n\n      // true ordinal on color is currently BAD (until we have good ordinal color scale support)\n      if (hasOrder) return D.color_bad;\n\n      //stacking gets lower score\n      if (isStacked) return D.color_stack;\n\n      return cardinality <= opt.maxGoodCardinalityForColor ? D.color_good: cardinality <= opt.maxCardinalityForColor ? D.color_ok : D.color_bad;\n    case vlChannel.SHAPE:\n      return cardinality <= opt.maxCardinalityForShape ? D.shape : TERRIBLE;\n    case vlChannel.DETAIL:\n      return D.detail;\n  }\n  return TERRIBLE;\n};\n\nrankEncodings.dimensionScore.consts = D;\n\nrankEncodings.measureScore = function (fieldDef, channel, mark, stats, opt) {\n  // jshint unused:false\n  switch (channel){\n    case vlChannel.X: return M.pos;\n    case vlChannel.Y: return M.pos;\n    case vlChannel.SIZE:\n      if (mark === 'bar') return BAD; //size of bar is very bad\n      if (mark === 'text') return BAD;\n      if (mark === 'line') return BAD;\n      return M.size;\n    case vlChannel.COLOR: return M.color;\n    case vlChannel.TEXT: return M.text;\n  }\n  return BAD;\n};\n\nrankEncodings.measureScore.consts = M;\n\n\nrankEncodings.score = {\n  dimension: rankEncodings.dimensionScore,\n  measure: rankEncodings.measureScore,\n};\n","\"use strict\";\n\nvar consts = require('./consts');\n\nvar util = module.exports = {\n  gen: {}\n};\n\n// FIXME: remove redundant methods\n\nutil.isArray = Array.isArray || function (obj) {\n  return {}.toString.call(obj) == '[object Array]';\n};\n\nutil.isin = function (item, array) {\n    return array.indexOf(item) !== -1;\n};\n\nutil.json = function(s, sp) {\n  return JSON.stringify(s, null, sp);\n};\n\nutil.keys = function(obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n};\n\nutil.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  }\n  else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k, obj);\n    }\n  }\n};\n\nutil.any = function (arr, f) {\n    var i = 0, k;\n    for (k in arr) {\n        if (f(arr[k], k, i++))\n            return true;\n    }\n    return false;\n};\n\nutil.nestedMap = function (collection, f, level, filter) {\n  return level === 0 ?\n    collection.map(f) :\n    collection.map(function(v) {\n      var r = util.nestedMap(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nestedReduce = function (collection, f, level, filter) {\n  return level === 0 ?\n    collection.reduce(f, []) :\n    collection.map(function(v) {\n      var r = util.nestedReduce(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nonEmpty = function(grp) {\n  return !util.isArray(grp) || grp.length > 0;\n};\n\n\nutil.traverse = function (node, arr) {\n  if (node.value !== undefined) {\n    arr.push(node.value);\n  } else {\n    if (node.left) util.traverse(node.left, arr);\n    if (node.right) util.traverse(node.right, arr);\n  }\n  return arr;\n};\n\nutil.union = function (a, b) {\n  var o = {};\n  a.forEach(function(x) { o[x] = true;});\n  b.forEach(function(x) { o[x] = true;});\n  return util.keys(o);\n};\n\n\nutil.gen.getOpt = function (opt) {\n  //merge with default\n  return (opt ? util.keys(opt) : []).reduce(function(c, k) {\n    c[k] = opt[k];\n    return c;\n  }, Object.create(consts.gen.DEFAULT_OPT));\n};\n\n/**\n * powerset code from http://rosettacode.org/wiki/Power_Set#JavaScript\n *\n *   var res = powerset([1,2,3,4]);\n *\n * returns\n *\n * [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],\n * [2,4],[1,2,4],[3,4],[1,3,4],[2,3,4],[1,2,3,4]]\n[edit]\n*/\n\nutil.powerset = function(list) {\n  var ps = [\n    []\n  ];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = ps.length; j < len; j++) {\n      ps.push(ps[j].concat(list[i]));\n    }\n  }\n  return ps;\n};\n\nutil.chooseKorLess = function(list, k) {\n  var subset = [[]];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length <= k){\n        subset.push(sub);\n      }\n    }\n  }\n  return subset;\n};\n\nutil.chooseK = function(list, k) {\n  var subset = [[]];\n  var kArray =[];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length < k){\n        subset.push(sub);\n      }else if (sub.length === k){\n        kArray.push(sub);\n      }\n    }\n  }\n  return kArray;\n};\n\nutil.cross = function(a,b){\n  var x = [];\n  for(var i=0; i< a.length; i++){\n    for(var j=0;j< b.length; j++){\n      x.push(a[i].concat(b[j]));\n    }\n  }\n  return x;\n};\n\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('d3-time', ['exports'], factory) :\n  factory((global.d3_time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t0 = new Date;\n  var t1 = new Date;\n  function newInterval(floori, offseti, count, field) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) {\n      interval.count = function(start, end) {\n        t0.setTime(+start), t1.setTime(+end);\n        floori(t0), floori(t1);\n        return Math.floor(count(t0, t1));\n      };\n\n      interval.every = function(step) {\n        step = Math.floor(step);\n        return !isFinite(step) || !(step > 0) ? null\n            : !(step > 1) ? interval\n            : interval.filter(field\n                ? function(d) { return field(d) % step === 0; }\n                : function(d) { return interval.count(0, d) % step === 0; });\n      };\n    }\n\n    return interval;\n  };\n\n  var millisecond = newInterval(function() {\n    // noop\n  }, function(date, step) {\n    date.setTime(+date + step);\n  }, function(start, end) {\n    return end - start;\n  });\n\n  // An optimized implementation for this simple case.\n  millisecond.every = function(k) {\n    k = Math.floor(k);\n    if (!isFinite(k) || !(k > 0)) return null;\n    if (!(k > 1)) return millisecond;\n    return newInterval(function(date) {\n      date.setTime(Math.floor(date / k) * k);\n    }, function(date, step) {\n      date.setTime(+date + step * k);\n    }, function(start, end) {\n      return (end - start) / k;\n    });\n  };\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getSeconds();\n  });\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getMinutes();\n  });\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getHours();\n  });\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  }, function(date) {\n    return date.getDate() - 1;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n  var tuesday = weekday(2);\n  var wednesday = weekday(3);\n  var thursday = weekday(4);\n  var friday = weekday(5);\n  var saturday = weekday(6);\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  }, function(date) {\n    return date.getMonth();\n  });\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  }, function(date) {\n    return date.getFullYear();\n  });\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getUTCSeconds();\n  });\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getUTCMinutes();\n  });\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getUTCHours();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  }, function(date) {\n    return date.getUTCDate() - 1;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n  var utcTuesday = utcWeekday(2);\n  var utcWednesday = utcWeekday(3);\n  var utcThursday = utcWeekday(4);\n  var utcFriday = utcWeekday(5);\n  var utcSaturday = utcWeekday(6);\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  }, function(date) {\n    return date.getUTCMonth();\n  });\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  }, function(date) {\n    return date.getUTCFullYear();\n  });\n\n  var milliseconds = millisecond.range;\n  var seconds = second.range;\n  var minutes = minute.range;\n  var hours = hour.range;\n  var days = day.range;\n  var sundays = sunday.range;\n  var mondays = monday.range;\n  var tuesdays = tuesday.range;\n  var wednesdays = wednesday.range;\n  var thursdays = thursday.range;\n  var fridays = friday.range;\n  var saturdays = saturday.range;\n  var weeks = sunday.range;\n  var months = month.range;\n  var years = year.range;\n\n  var utcMillisecond = millisecond;\n  var utcMilliseconds = milliseconds;\n  var utcSeconds = utcSecond.range;\n  var utcMinutes = utcMinute.range;\n  var utcHours = utcHour.range;\n  var utcDays = utcDay.range;\n  var utcSundays = utcSunday.range;\n  var utcMondays = utcMonday.range;\n  var utcTuesdays = utcTuesday.range;\n  var utcWednesdays = utcWednesday.range;\n  var utcThursdays = utcThursday.range;\n  var utcFridays = utcFriday.range;\n  var utcSaturdays = utcSaturday.range;\n  var utcWeeks = utcSunday.range;\n  var utcMonths = utcMonth.range;\n  var utcYears = utcYear.range;\n\n  var version = \"0.1.0\";\n\n  exports.version = version;\n  exports.milliseconds = milliseconds;\n  exports.seconds = seconds;\n  exports.minutes = minutes;\n  exports.hours = hours;\n  exports.days = days;\n  exports.sundays = sundays;\n  exports.mondays = mondays;\n  exports.tuesdays = tuesdays;\n  exports.wednesdays = wednesdays;\n  exports.thursdays = thursdays;\n  exports.fridays = fridays;\n  exports.saturdays = saturdays;\n  exports.weeks = weeks;\n  exports.months = months;\n  exports.years = years;\n  exports.utcMillisecond = utcMillisecond;\n  exports.utcMilliseconds = utcMilliseconds;\n  exports.utcSeconds = utcSeconds;\n  exports.utcMinutes = utcMinutes;\n  exports.utcHours = utcHours;\n  exports.utcDays = utcDays;\n  exports.utcSundays = utcSundays;\n  exports.utcMondays = utcMondays;\n  exports.utcTuesdays = utcTuesdays;\n  exports.utcWednesdays = utcWednesdays;\n  exports.utcThursdays = utcThursdays;\n  exports.utcFridays = utcFridays;\n  exports.utcSaturdays = utcSaturdays;\n  exports.utcWeeks = utcWeeks;\n  exports.utcMonths = utcMonths;\n  exports.utcYears = utcYears;\n  exports.millisecond = millisecond;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.sunday = sunday;\n  exports.monday = monday;\n  exports.tuesday = tuesday;\n  exports.wednesday = wednesday;\n  exports.thursday = thursday;\n  exports.friday = friday;\n  exports.saturday = saturday;\n  exports.week = sunday;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcSunday = utcSunday;\n  exports.utcMonday = utcMonday;\n  exports.utcTuesday = utcTuesday;\n  exports.utcWednesday = utcWednesday;\n  exports.utcThursday = utcThursday;\n  exports.utcFriday = utcFriday;\n  exports.utcSaturday = utcSaturday;\n  exports.utcWeek = utcSunday;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n  exports.interval = newInterval;\n\n}));","var util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n\n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n","var gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x >= min && x <= max) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    return x < min ? 0 : x > max ? 1 : (x - min) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? min + p*d : NaN;\n  };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x === Math.floor(x) && x >= a && x < b) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    var v = Math.floor(x);\n    return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? a - 1 + Math.floor(p*d) : NaN;\n  };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    var exp = Math.exp(Math.pow(x-mean, 2) / (-2 * Math.pow(stdev, 2)));\n    return (1 / (stdev * Math.sqrt(2*Math.PI))) * exp;\n  };\n  f.cdf = function(x) {\n    // Approximation from West (2009)\n    // Better Approximations to Cumulative Normal Functions\n    var cd,\n        z = (x - mean) / stdev,\n        Z = Math.abs(z);\n    if (Z > 37) {\n      cd = 0;\n    } else {\n      var sum, exp = Math.exp(-Z*Z/2);\n      if (Z < 7.07106781186547) {\n        sum = 3.52624965998911e-02 * Z + 0.700383064443688;\n        sum = sum * Z + 6.37396220353165;\n        sum = sum * Z + 33.912866078383;\n        sum = sum * Z + 112.079291497871;\n        sum = sum * Z + 221.213596169931;\n        sum = sum * Z + 220.206867912376;\n        cd = exp * sum;\n        sum = 8.83883476483184e-02 * Z + 1.75566716318264;\n        sum = sum * Z + 16.064177579207;\n        sum = sum * Z + 86.7807322029461;\n        sum = sum * Z + 296.564248779674;\n        sum = sum * Z + 637.333633378831;\n        sum = sum * Z + 793.826512519948;\n        sum = sum * Z + 440.413735824752;\n        cd = cd / sum;\n      } else {\n        sum = Z + 0.65;\n        sum = Z + 4 / sum;\n        sum = Z + 3 / sum;\n        sum = Z + 2 / sum;\n        sum = Z + 1 / sum;\n        cd = exp / sum / 2.506628274631;\n      }\n    }\n    return z > 0 ? 1 - cd : cd;\n  };\n  f.icdf = function(p) {\n    // Approximation of Probit function using inverse error function.\n    if (p <= 0 || p >= 1) return NaN;\n    var x = 2*p - 1,\n        v = (8 * (Math.PI - 3)) / (3 * Math.PI * (4-Math.PI)),\n        a = (2 / (Math.PI*v)) + (Math.log(1 - Math.pow(x,2)) / 2),\n        b = Math.log(1 - (x*x)) / v,\n        s = (x > 0 ? 1 : -1) * Math.sqrt(Math.sqrt((a*a) - b) - a);\n    return mean + stdev * Math.SQRT2 * s;\n  };\n  return f;\n};","var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n","var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\n\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Compute the Cohen's d effect size between two arrays of numbers.\nstats.cohensd = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      x1 = stats.mean(X),\n      x2 = stats.mean(Y),\n      n1 = stats.count.valid(X),\n      n2 = stats.count.valid(Y);\n\n  if ((n1+n2-2) <= 0) {\n    // if both arrays are size 1, or one is empty, there's no effect size\n    return 0;\n  }\n  // pool standard deviation\n  var s1 = stats.variance(X),\n      s2 = stats.variance(Y),\n      s = Math.sqrt((((n1-1)*s1) + ((n2-1)*s2)) / (n1+n2-2));\n  // if there is no variance, there's no effect size\n  return s===0 ? 0 : (x1 - x2) / s;\n};\n\n// Computes the covariance between two arrays of numbers\nstats.covariance = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n = X.length,\n      xm = stats.mean(X),\n      ym = stats.mean(Y),\n      sum = 0, c = 0, i, x, y, vx, vy;\n\n  if (n !== Y.length) {\n    throw Error('Input lengths must match.');\n  }\n\n  for (i=0; i<n; ++i) {\n    x = X[i]; vx = util.isValid(x);\n    y = Y[i]; vy = util.isValid(y);\n    if (vx && vy) {\n      sum += (x-xm) * (y-ym);\n      ++c;\n    } else if (vx || vy) {\n      throw Error('Valid values must align.');\n    }\n  }\n  return sum / (c-1);\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Simple linear regression.\n// Returns a \"fit\" object with slope (m), intercept (b),\n// r value (R), and sum-squared residual error (rss).\nstats.linearRegression = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n = X.length,\n      xy = stats.covariance(X, Y), // will throw err if valid vals don't align\n      sx = stats.stdev(X),\n      sy = stats.stdev(Y),\n      slope = xy / (sx*sx),\n      icept = stats.mean(Y) - slope * stats.mean(X),\n      fit = {slope: slope, intercept: icept, R: xy / (sx*sy), rss: 0},\n      res, i;\n\n  for (i=0; i<n; ++i) {\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\n      res = (slope*X[i] + icept) - Y[i];\n      fit.rss += res * res;\n    }\n  }\n\n  return fit;\n};\n\n// Namespace for z-tests\nstats.z = {};\n\n// Construct a z-confidence interval at a given significance level\n// Arguments are an array and an optional alpha (defaults to 0.05).\nstats.z.ci = function(a, alpha) {\n  var z = alpha ? gen.random.normal(0, 1).icdf(1-(alpha/2)) : 1.96,\n      mu = stats.mean(a),\n      SE = stats.stdev(a) / Math.sqrt(stats.count.valid(a));\n  return [mu - (z*SE), mu + (z*SE)];\n};\n\n// Perform a z-test of means. Returns the p-value.\n// Assuming we have a list of values, and a null hypothesis. If no null\n// hypothesis, assume our null hypothesis is mu=0.\n// http://en.wikipedia.org/wiki/Z-test\nstats.z.test = function(a, b) {\n  var nullH = b ? b : 0,\n      gaussian = gen.random.normal(0, 1),\n      mu = stats.mean(a),\n      SE = stats.stdev(a) / Math.sqrt(stats.count.valid(a));\n\n  if (SE===0) {\n    // Test not well defined when standard error is 0.\n    return (mu - nullH) === 0 ? 1 : 0;\n  }\n  // Two-sided, so twice the one-sided cdf.\n  var z = (mu - nullH) / SE;\n  return 2 * gaussian.cdf(-Math.abs(z));\n};\n\n// Perform a two sample paired z-test of means. Returns the p-value.\n// http://en.wikipedia.org/wiki/Paired_difference_test\nstats.z.pairedTest = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n1 = stats.count(X),\n      n2 = stats.count(Y),\n      diffs = Array(), i;\n\n  if (n1 !== n2) {\n    throw Error('Array lengths must match.');\n  }\n  for (i=0; i<n1; ++i) {\n    // Only valid differences should contribute to the test statistic\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\n      diffs.push(X[i] - Y[i]);\n    }\n  }\n  return stats.z.test(diffs);\n};\n\n// Perform a two sample z-test of means. Returns the p-value.\n// http://en.wikipedia.org/wiki/Z-test\nstats.z.twoSampleTest = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n1 = stats.count.valid(X),\n      n2 = stats.count.valid(Y),\n      gaussian = gen.random.normal(0, 1),\n      meanDiff = stats.mean(X) - stats.mean(Y),\n      SE = Math.sqrt(stats.variance(X)/n1 + stats.variance(Y)/n2);\n\n  if (SE===0) {\n    // Not well defined when pooled standard error is 0.\n    return meanDiff===0 ? 1 : 0;\n  }\n  // Two-tailed, so twice the one-sided cdf.\n  var z = meanDiff / SE;\n  return 2 * gaussian.cdf(-Math.abs(z));\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance]\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;\n","var d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);\n","var buffer = require('buffer'),\n    time = require('./time'),\n    utc = time.utc;\n\nvar u = module.exports = {};\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (buffer.Buffer && buffer.Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\n// parse a date with optional d3.time-format format\nu.date = function(s, format) {\n  var d = format ? format : Date;\n  return s == null || s === '' ? null : d.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\nu.$year   = u.$func('year', time.year.unit);\nu.$month  = u.$func('month', time.months.unit);\nu.$date   = u.$func('date', time.dates.unit);\nu.$day    = u.$func('day', time.weekdays.unit);\nu.$hour   = u.$func('hour', time.hours.unit);\nu.$minute = u.$func('minute', time.minutes.unit);\nu.$second = u.$func('second', time.seconds.unit);\n\nu.$utcYear   = u.$func('utcYear', utc.year.unit);\nu.$utcMonth  = u.$func('utcMonth', utc.months.unit);\nu.$utcDate   = u.$func('utcDate', utc.dates.unit);\nu.$utcDay    = u.$func('utcDay', utc.weekdays.unit);\nu.$utcHour   = u.$func('utcHour', utc.hours.unit);\nu.$utcMinute = u.$func('utcMinute', utc.minutes.unit);\nu.$utcSecond = u.$func('utcSecond', utc.seconds.unit);\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n","exports.AGGREGATE_OPS = [\r\n    'values', 'count', 'valid', 'missing', 'distinct',\r\n    'sum', 'mean', 'average', 'variance', 'variancep', 'stdev',\r\n    'stdevp', 'median', 'q1', 'q3', 'modeskew', 'min', 'max',\r\n    'argmin', 'argmax'\r\n];\r\nexports.SHARED_DOMAIN_OPS = [\r\n    'mean', 'average', 'stdev', 'stdevp', 'median', 'q1', 'q3', 'min', 'max'\r\n];\r\n//# sourceMappingURL=aggregate.js.map","exports.MAXBINS_DEFAULT = 15;\r\n//# sourceMappingURL=bin.js.map","(function (Channel) {\r\n    Channel[Channel[\"X\"] = 'x'] = \"X\";\r\n    Channel[Channel[\"Y\"] = 'y'] = \"Y\";\r\n    Channel[Channel[\"ROW\"] = 'row'] = \"ROW\";\r\n    Channel[Channel[\"COLUMN\"] = 'column'] = \"COLUMN\";\r\n    Channel[Channel[\"SHAPE\"] = 'shape'] = \"SHAPE\";\r\n    Channel[Channel[\"SIZE\"] = 'size'] = \"SIZE\";\r\n    Channel[Channel[\"COLOR\"] = 'color'] = \"COLOR\";\r\n    Channel[Channel[\"TEXT\"] = 'text'] = \"TEXT\";\r\n    Channel[Channel[\"DETAIL\"] = 'detail'] = \"DETAIL\";\r\n})(exports.Channel || (exports.Channel = {}));\r\nvar Channel = exports.Channel;\r\nexports.X = Channel.X;\r\nexports.Y = Channel.Y;\r\nexports.ROW = Channel.ROW;\r\nexports.COLUMN = Channel.COLUMN;\r\nexports.SHAPE = Channel.SHAPE;\r\nexports.SIZE = Channel.SIZE;\r\nexports.COLOR = Channel.COLOR;\r\nexports.TEXT = Channel.TEXT;\r\nexports.DETAIL = Channel.DETAIL;\r\nexports.CHANNELS = [exports.X, exports.Y, exports.ROW, exports.COLUMN, exports.SIZE, exports.SHAPE, exports.COLOR, exports.TEXT, exports.DETAIL];\r\n;\r\nfunction supportMark(channel, mark) {\r\n    return !!getSupportedMark(channel)[mark];\r\n}\r\nexports.supportMark = supportMark;\r\nfunction getSupportedMark(channel) {\r\n    switch (channel) {\r\n        case exports.X:\r\n        case exports.Y:\r\n            return {\r\n                point: true, tick: true, circle: true, square: true,\r\n                bar: true, line: true, area: true\r\n            };\r\n        case exports.ROW:\r\n        case exports.COLUMN:\r\n            return {\r\n                point: true, tick: true, circle: true, square: true,\r\n                bar: true, line: true, area: true, text: true\r\n            };\r\n        case exports.SIZE:\r\n            return {\r\n                point: true, tick: true, circle: true, square: true,\r\n                bar: true, text: true\r\n            };\r\n        case exports.COLOR:\r\n        case exports.DETAIL:\r\n            return {\r\n                point: true, tick: true, circle: true, square: true,\r\n                bar: true, line: true, area: true, text: true\r\n            };\r\n        case exports.SHAPE:\r\n            return { point: true };\r\n        case exports.TEXT:\r\n            return { text: true };\r\n    }\r\n    return {};\r\n}\r\nexports.getSupportedMark = getSupportedMark;\r\n;\r\nfunction getSupportedRole(channel) {\r\n    switch (channel) {\r\n        case exports.X:\r\n        case exports.Y:\r\n        case exports.COLOR:\r\n            return {\r\n                measure: true,\r\n                dimension: true\r\n            };\r\n        case exports.ROW:\r\n        case exports.COLUMN:\r\n        case exports.SHAPE:\r\n        case exports.DETAIL:\r\n            return {\r\n                measure: false,\r\n                dimension: true\r\n            };\r\n        case exports.SIZE:\r\n        case exports.TEXT:\r\n            return {\r\n                measure: true,\r\n                dimension: false\r\n            };\r\n    }\r\n    throw new Error('Invalid encoding channel' + channel);\r\n}\r\nexports.getSupportedRole = getSupportedRole;\r\n//# sourceMappingURL=channel.js.map","var bin_1 = require('../bin');\r\nvar channel_1 = require('../channel');\r\nvar data_1 = require('../data');\r\nvar vlFieldDef = require('../fielddef');\r\nvar vlEncoding = require('../encoding');\r\nvar layout_1 = require('./layout');\r\nvar mark_1 = require('../mark');\r\nvar schema = require('../schema/schema');\r\nvar schemaUtil = require('../schema/schemautil');\r\nvar type_1 = require('../type');\r\nvar util_1 = require('../util');\r\nvar time = require('./time');\r\nvar Model = (function () {\r\n    function Model(spec, theme) {\r\n        var defaults = schema.instantiate();\r\n        this._spec = schemaUtil.merge(defaults, theme || {}, spec);\r\n        vlEncoding.forEach(this._spec.encoding, function (fieldDef, channel) {\r\n            if (fieldDef.type) {\r\n                fieldDef.type = type_1.getFullName(fieldDef.type);\r\n            }\r\n        });\r\n        this._stack = this.getStackProperties();\r\n        this._layout = layout_1.compileLayout(this);\r\n    }\r\n    Model.prototype.getStackProperties = function () {\r\n        var stackChannel = (this.has(channel_1.COLOR)) ? channel_1.COLOR : (this.has(channel_1.DETAIL)) ? channel_1.DETAIL : null;\r\n        if (stackChannel &&\r\n            (this.is(mark_1.BAR) || this.is(mark_1.AREA)) &&\r\n            this.config('stack') !== false &&\r\n            this.isAggregate()) {\r\n            var isXMeasure = this.isMeasure(channel_1.X);\r\n            var isYMeasure = this.isMeasure(channel_1.Y);\r\n            if (isXMeasure && !isYMeasure) {\r\n                return {\r\n                    groupbyChannel: channel_1.Y,\r\n                    fieldChannel: channel_1.X,\r\n                    stackChannel: stackChannel,\r\n                    config: this.config('stack')\r\n                };\r\n            }\r\n            else if (isYMeasure && !isXMeasure) {\r\n                return {\r\n                    groupbyChannel: channel_1.X,\r\n                    fieldChannel: channel_1.Y,\r\n                    stackChannel: stackChannel,\r\n                    config: this.config('stack')\r\n                };\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    Model.prototype.layout = function () {\r\n        return this._layout;\r\n    };\r\n    Model.prototype.stack = function () {\r\n        return this._stack;\r\n    };\r\n    Model.prototype.toSpec = function (excludeConfig, excludeData) {\r\n        var encoding = util_1.duplicate(this._spec.encoding), spec;\r\n        spec = {\r\n            mark: this._spec.mark,\r\n            encoding: encoding\r\n        };\r\n        if (!excludeConfig) {\r\n            spec.config = util_1.duplicate(this._spec.config);\r\n        }\r\n        if (!excludeData) {\r\n            spec.data = util_1.duplicate(this._spec.data);\r\n        }\r\n        var defaults = schema.instantiate();\r\n        return schemaUtil.subtract(spec, defaults);\r\n    };\r\n    Model.prototype.mark = function () {\r\n        return this._spec.mark;\r\n    };\r\n    Model.prototype.spec = function () {\r\n        return this._spec;\r\n    };\r\n    Model.prototype.is = function (mark) {\r\n        return this._spec.mark === mark;\r\n    };\r\n    Model.prototype.has = function (channel) {\r\n        return this._spec.encoding[channel].field !== undefined;\r\n    };\r\n    Model.prototype.fieldDef = function (channel) {\r\n        return this._spec.encoding[channel];\r\n    };\r\n    Model.prototype.field = function (channel, opt) {\r\n        opt = opt || {};\r\n        var fieldDef = this.fieldDef(channel);\r\n        var f = (opt.datum ? 'datum.' : '') + (opt.prefn || ''), field = fieldDef.field;\r\n        if (vlFieldDef.isCount(fieldDef)) {\r\n            return f + 'count';\r\n        }\r\n        else if (opt.fn) {\r\n            return f + opt.fn + '_' + field;\r\n        }\r\n        else if (!opt.nofn && fieldDef.bin) {\r\n            var binSuffix = opt.binSuffix || '_start';\r\n            return f + 'bin_' + field + binSuffix;\r\n        }\r\n        else if (!opt.nofn && !opt.noAggregate && fieldDef.aggregate) {\r\n            return f + fieldDef.aggregate + '_' + field;\r\n        }\r\n        else if (!opt.nofn && fieldDef.timeUnit) {\r\n            return f + fieldDef.timeUnit + '_' + field;\r\n        }\r\n        else {\r\n            return f + field;\r\n        }\r\n    };\r\n    Model.prototype.fieldTitle = function (channel) {\r\n        if (vlFieldDef.isCount(this._spec.encoding[channel])) {\r\n            return vlFieldDef.COUNT_DISPLAYNAME;\r\n        }\r\n        var fn = this._spec.encoding[channel].aggregate || this._spec.encoding[channel].timeUnit || (this._spec.encoding[channel].bin && 'bin');\r\n        if (fn) {\r\n            return fn.toUpperCase() + '(' + this._spec.encoding[channel].field + ')';\r\n        }\r\n        else {\r\n            return this._spec.encoding[channel].field;\r\n        }\r\n    };\r\n    Model.prototype.bin = function (channel) {\r\n        var bin = this._spec.encoding[channel].bin;\r\n        if (bin === {})\r\n            return false;\r\n        if (bin === true)\r\n            return {\r\n                maxbins: bin_1.MAXBINS_DEFAULT\r\n            };\r\n        return bin;\r\n    };\r\n    Model.prototype.numberFormat = function (channel) {\r\n        return this.config('numberFormat');\r\n    };\r\n    ;\r\n    Model.prototype.map = function (f) {\r\n        return vlEncoding.map(this._spec.encoding, f);\r\n    };\r\n    Model.prototype.reduce = function (f, init) {\r\n        return vlEncoding.reduce(this._spec.encoding, f, init);\r\n    };\r\n    Model.prototype.forEach = function (f) {\r\n        return vlEncoding.forEach(this._spec.encoding, f);\r\n    };\r\n    Model.prototype.isOrdinalScale = function (channel) {\r\n        var fieldDef = this.fieldDef(channel);\r\n        return fieldDef && (util_1.contains([type_1.NOMINAL, type_1.ORDINAL], fieldDef.type) ||\r\n            (fieldDef.type === type_1.TEMPORAL && fieldDef.timeUnit &&\r\n                time.scale.type(fieldDef.timeUnit, channel) === 'ordinal'));\r\n    };\r\n    Model.prototype.isDimension = function (channel) {\r\n        return this.has(channel) &&\r\n            vlFieldDef.isDimension(this.fieldDef(channel));\r\n    };\r\n    Model.prototype.isMeasure = function (channel) {\r\n        return this.has(channel) &&\r\n            vlFieldDef.isMeasure(this.fieldDef(channel));\r\n    };\r\n    Model.prototype.isAggregate = function () {\r\n        return vlEncoding.isAggregate(this._spec.encoding);\r\n    };\r\n    Model.prototype.isFacet = function () {\r\n        return this.has(channel_1.ROW) || this.has(channel_1.COLUMN);\r\n    };\r\n    Model.prototype.dataTable = function () {\r\n        return this.isAggregate() ? data_1.SUMMARY : data_1.SOURCE;\r\n    };\r\n    Model.prototype.data = function () {\r\n        return this._spec.data;\r\n    };\r\n    Model.prototype.hasValues = function () {\r\n        var vals = this.data().values;\r\n        return vals && vals.length;\r\n    };\r\n    Model.prototype.config = function (name) {\r\n        return this._spec.config[name];\r\n    };\r\n    Model.prototype.markOpacity = function () {\r\n        var opacity = this.config('marks').opacity;\r\n        if (opacity) {\r\n            return opacity;\r\n        }\r\n        else {\r\n            if (util_1.contains([mark_1.POINT, mark_1.TICK, mark_1.CIRCLE, mark_1.SQUARE], this.mark())) {\r\n                if (!this.isAggregate() ||\r\n                    (this.has(channel_1.DETAIL) || this.has(channel_1.COLOR) || this.has(channel_1.SHAPE))) {\r\n                    return 0.7;\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    return Model;\r\n})();\r\nexports.Model = Model;\r\n//# sourceMappingURL=Model.js.map","var channel_1 = require('../channel');\r\nvar mark_1 = require('../mark');\r\nvar data_1 = require('../data');\r\nfunction compileLayout(model) {\r\n    var cellWidth = getCellWidth(model);\r\n    var cellHeight = getCellHeight(model);\r\n    return {\r\n        cellWidth: cellWidth,\r\n        cellHeight: cellHeight,\r\n        width: getWidth(model, cellWidth),\r\n        height: getHeight(model, cellHeight)\r\n    };\r\n}\r\nexports.compileLayout = compileLayout;\r\nfunction getCellWidth(model) {\r\n    if (model.has(channel_1.X)) {\r\n        if (model.isOrdinalScale(channel_1.X)) {\r\n            return { data: data_1.LAYOUT, field: 'cellWidth' };\r\n        }\r\n        return model.config('cell').width;\r\n    }\r\n    if (model.mark() === mark_1.TEXT) {\r\n        return model.config('textCellWidth');\r\n    }\r\n    return model.fieldDef(channel_1.X).scale.bandWidth;\r\n}\r\nfunction getWidth(model, cellWidth) {\r\n    if (model.has(channel_1.COLUMN)) {\r\n        return { data: data_1.LAYOUT, field: 'width' };\r\n    }\r\n    return cellWidth;\r\n}\r\nfunction getCellHeight(model) {\r\n    if (model.has(channel_1.Y)) {\r\n        if (model.isOrdinalScale(channel_1.Y)) {\r\n            return { data: data_1.LAYOUT, field: 'cellHeight' };\r\n        }\r\n        else {\r\n            return model.config('cell').height;\r\n        }\r\n    }\r\n    return model.fieldDef(channel_1.Y).scale.bandWidth;\r\n}\r\nfunction getHeight(model, cellHeight) {\r\n    if (model.has(channel_1.ROW)) {\r\n        return { data: data_1.LAYOUT, field: 'height' };\r\n    }\r\n    return cellHeight;\r\n}\r\n//# sourceMappingURL=layout.js.map","var util = require('../util');\r\nvar channel_1 = require('../channel');\r\nfunction cardinality(fieldDef, stats, filterNull, type) {\r\n    var timeUnit = fieldDef.timeUnit;\r\n    switch (timeUnit) {\r\n        case 'seconds': return 60;\r\n        case 'minutes': return 60;\r\n        case 'hours': return 24;\r\n        case 'day': return 7;\r\n        case 'date': return 31;\r\n        case 'month': return 12;\r\n        case 'year':\r\n            var stat = stats[fieldDef.field], yearstat = stats['year_' + fieldDef.field];\r\n            if (!yearstat) {\r\n                return null;\r\n            }\r\n            return yearstat.distinct -\r\n                (stat.missing > 0 && filterNull[type] ? 1 : 0);\r\n    }\r\n    return null;\r\n}\r\nexports.cardinality = cardinality;\r\nfunction formula(timeUnit, field) {\r\n    var fn = 'utc' + timeUnit;\r\n    return fn + '(' + field + ')';\r\n}\r\nexports.formula = formula;\r\nvar scale;\r\n(function (scale) {\r\n    function type(timeUnit, channel) {\r\n        if (channel === channel_1.COLOR) {\r\n            return 'linear';\r\n        }\r\n        if (channel === channel_1.COLUMN || channel === channel_1.ROW) {\r\n            return 'ordinal';\r\n        }\r\n        switch (timeUnit) {\r\n            case 'hours':\r\n            case 'day':\r\n            case 'date':\r\n            case 'month':\r\n                return 'ordinal';\r\n            case 'year':\r\n            case 'second':\r\n            case 'minute':\r\n                return 'linear';\r\n        }\r\n        return 'time';\r\n    }\r\n    scale.type = type;\r\n    function domain(timeUnit, channel) {\r\n        var isColor = channel === channel_1.COLOR;\r\n        switch (timeUnit) {\r\n            case 'seconds':\r\n            case 'minutes': return isColor ? [0, 59] : util.range(0, 60);\r\n            case 'hours': return isColor ? [0, 23] : util.range(0, 24);\r\n            case 'day': return isColor ? [0, 6] : util.range(0, 7);\r\n            case 'date': return isColor ? [1, 31] : util.range(1, 32);\r\n            case 'month': return isColor ? [0, 11] : util.range(0, 12);\r\n        }\r\n        return null;\r\n    }\r\n    scale.domain = domain;\r\n})(scale = exports.scale || (exports.scale = {}));\r\nfunction labelTemplate(timeUnit, abbreviated) {\r\n    if (abbreviated === void 0) { abbreviated = false; }\r\n    var postfix = abbreviated ? '-abbrev' : '';\r\n    switch (timeUnit) {\r\n        case 'day':\r\n            return 'day' + postfix;\r\n        case 'month':\r\n            return 'month' + postfix;\r\n    }\r\n    return null;\r\n}\r\nexports.labelTemplate = labelTemplate;\r\n//# sourceMappingURL=time.js.map","var type_1 = require('./type');\r\nexports.SUMMARY = 'summary';\r\nexports.SOURCE = 'source';\r\nexports.STACKED = 'stacked';\r\nexports.LAYOUT = 'layout';\r\nexports.types = {\r\n    'boolean': type_1.NOMINAL,\r\n    'number': type_1.QUANTITATIVE,\r\n    'integer': type_1.QUANTITATIVE,\r\n    'date': type_1.TEMPORAL,\r\n    'string': type_1.NOMINAL\r\n};\r\n//# sourceMappingURL=data.js.map","var channel_1 = require('./channel');\r\nfunction countRetinal(encoding) {\r\n    var count = 0;\r\n    if (encoding.color)\r\n        count++;\r\n    if (encoding.size)\r\n        count++;\r\n    if (encoding.shape)\r\n        count++;\r\n    return count;\r\n}\r\nexports.countRetinal = countRetinal;\r\nfunction has(encoding, channel) {\r\n    var fieldDef = encoding && encoding[channel];\r\n    return fieldDef && fieldDef.field;\r\n}\r\nexports.has = has;\r\nfunction isAggregate(encoding) {\r\n    for (var k in encoding) {\r\n        if (has(encoding, k) && encoding[k].aggregate) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.isAggregate = isAggregate;\r\nfunction fieldDefs(encoding) {\r\n    var arr = [];\r\n    channel_1.CHANNELS.forEach(function (k) {\r\n        if (has(encoding, k)) {\r\n            arr.push(encoding[k]);\r\n        }\r\n    });\r\n    return arr;\r\n}\r\nexports.fieldDefs = fieldDefs;\r\n;\r\nfunction forEach(encoding, f) {\r\n    var i = 0;\r\n    channel_1.CHANNELS.forEach(function (channel) {\r\n        if (has(encoding, channel)) {\r\n            f(encoding[channel], channel, i++);\r\n        }\r\n    });\r\n}\r\nexports.forEach = forEach;\r\nfunction map(encoding, f) {\r\n    var arr = [];\r\n    channel_1.CHANNELS.forEach(function (k) {\r\n        if (has(encoding, k)) {\r\n            arr.push(f(encoding[k], k, encoding));\r\n        }\r\n    });\r\n    return arr;\r\n}\r\nexports.map = map;\r\nfunction reduce(encoding, f, init) {\r\n    var r = init;\r\n    channel_1.CHANNELS.forEach(function (k) {\r\n        if (has(encoding, k)) {\r\n            r = f(r, encoding[k], k, encoding);\r\n        }\r\n    });\r\n    return r;\r\n}\r\nexports.reduce = reduce;\r\n//# sourceMappingURL=encoding.js.map","var bin_1 = require('./bin');\r\nvar util_1 = require('./util');\r\nvar time = require('./compiler/time');\r\nvar type_1 = require('./type');\r\nfunction _isFieldDimension(fieldDef) {\r\n    return util_1.contains([type_1.NOMINAL, type_1.ORDINAL], fieldDef.type) || !!fieldDef.bin ||\r\n        (fieldDef.type === type_1.TEMPORAL && !!fieldDef.timeUnit);\r\n}\r\nfunction isDimension(fieldDef) {\r\n    return fieldDef && _isFieldDimension(fieldDef);\r\n}\r\nexports.isDimension = isDimension;\r\nfunction isMeasure(fieldDef) {\r\n    return fieldDef && !_isFieldDimension(fieldDef);\r\n}\r\nexports.isMeasure = isMeasure;\r\nfunction count() {\r\n    return { field: '*', aggregate: 'count', type: type_1.QUANTITATIVE, displayName: exports.COUNT_DISPLAYNAME };\r\n}\r\nexports.count = count;\r\nexports.COUNT_DISPLAYNAME = 'Number of Records';\r\nfunction isCount(fieldDef) {\r\n    return fieldDef.aggregate === 'count';\r\n}\r\nexports.isCount = isCount;\r\nfunction cardinality(fieldDef, stats, filterNull) {\r\n    if (filterNull === void 0) { filterNull = {}; }\r\n    var stat = stats[fieldDef.field];\r\n    var type = fieldDef.type;\r\n    if (fieldDef.bin) {\r\n        var bin = fieldDef.bin;\r\n        var maxbins = (typeof bin === 'boolean') ? bin_1.MAXBINS_DEFAULT : bin.maxbins;\r\n        var bins = util_1.getbins(stat, maxbins);\r\n        return (bins.stop - bins.start) / bins.step;\r\n    }\r\n    if (fieldDef.type === type_1.TEMPORAL) {\r\n        var cardinality = time.cardinality(fieldDef, stats, filterNull, type);\r\n        if (cardinality !== null)\r\n            return cardinality;\r\n    }\r\n    if (fieldDef.aggregate) {\r\n        return 1;\r\n    }\r\n    return stat.distinct -\r\n        (stat.missing > 0 && filterNull[type] ? 1 : 0);\r\n}\r\nexports.cardinality = cardinality;\r\n//# sourceMappingURL=fielddef.js.map","(function (Mark) {\r\n    Mark[Mark[\"AREA\"] = 'area'] = \"AREA\";\r\n    Mark[Mark[\"BAR\"] = 'bar'] = \"BAR\";\r\n    Mark[Mark[\"LINE\"] = 'line'] = \"LINE\";\r\n    Mark[Mark[\"POINT\"] = 'point'] = \"POINT\";\r\n    Mark[Mark[\"TEXT\"] = 'text'] = \"TEXT\";\r\n    Mark[Mark[\"TICK\"] = 'tick'] = \"TICK\";\r\n    Mark[Mark[\"CIRCLE\"] = 'circle'] = \"CIRCLE\";\r\n    Mark[Mark[\"SQUARE\"] = 'square'] = \"SQUARE\";\r\n})(exports.Mark || (exports.Mark = {}));\r\nvar Mark = exports.Mark;\r\nexports.AREA = Mark.AREA;\r\nexports.BAR = Mark.BAR;\r\nexports.LINE = Mark.LINE;\r\nexports.POINT = Mark.POINT;\r\nexports.TEXT = Mark.TEXT;\r\nexports.TICK = Mark.TICK;\r\nexports.CIRCLE = Mark.CIRCLE;\r\nexports.SQUARE = Mark.SQUARE;\r\n//# sourceMappingURL=mark.js.map","exports.axis = {\r\n    type: 'object',\r\n    properties: {\r\n        format: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'The formatting pattern for axis labels. ' +\r\n                'If not undefined, this will be determined by ' +\r\n                'the max value ' +\r\n                'of the field.'\r\n        },\r\n        grid: {\r\n            type: 'boolean',\r\n            default: undefined,\r\n            description: 'A flag indicate if gridlines should be created in addition to ticks. If `grid` is unspecified, the default value is `true` for ROW and COL. For X and Y, the default value is `true` for quantitative and time fields and `false` otherwise.'\r\n        },\r\n        layer: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'A string indicating if the axis (and any gridlines) should be placed above or below the data marks.'\r\n        },\r\n        orient: {\r\n            type: 'string',\r\n            default: undefined,\r\n            enum: ['top', 'right', 'left', 'bottom'],\r\n            description: 'The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).'\r\n        },\r\n        ticks: {\r\n            type: 'integer',\r\n            default: undefined,\r\n            minimum: 0,\r\n            description: 'A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale\\'s range.'\r\n        },\r\n        title: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'A title for the axis. (Shows field name and its function by default.)'\r\n        },\r\n        labelMaxLength: {\r\n            type: 'integer',\r\n            default: 25,\r\n            minimum: 0,\r\n            description: 'Truncate labels that are too long.'\r\n        },\r\n        titleMaxLength: {\r\n            type: 'integer',\r\n            default: undefined,\r\n            minimum: 0,\r\n            description: 'Max length for axis title if the title is automatically generated from the field\\'s description'\r\n        },\r\n        titleOffset: {\r\n            type: 'integer',\r\n            default: undefined,\r\n            description: 'A title offset value for the axis.'\r\n        },\r\n        shortTimeNames: {\r\n            type: 'boolean',\r\n            default: false,\r\n            description: 'Whether month names and weekday names should be abbreviated.'\r\n        },\r\n        properties: {\r\n            type: 'object',\r\n            default: undefined,\r\n            description: 'Optional mark property definitions for custom axis styling.'\r\n        }\r\n    }\r\n};\r\n//# sourceMappingURL=axis.schema.js.map","var bin_1 = require('../bin');\r\nvar type_1 = require('../type');\r\nvar util_1 = require('../util');\r\nexports.bin = {\r\n    type: ['boolean', 'object'],\r\n    default: false,\r\n    properties: {\r\n        maxbins: {\r\n            type: 'integer',\r\n            default: bin_1.MAXBINS_DEFAULT,\r\n            minimum: 2,\r\n            description: 'Maximum number of bins.'\r\n        }\r\n    },\r\n    supportedTypes: util_1.toMap([type_1.QUANTITATIVE])\r\n};\r\n//# sourceMappingURL=bin.schema.js.map","exports.cellConfig = {\r\n    type: 'object',\r\n    properties: {\r\n        width: {\r\n            type: 'integer',\r\n            default: 200\r\n        },\r\n        height: {\r\n            type: 'integer',\r\n            default: 200\r\n        },\r\n        padding: {\r\n            type: 'integer',\r\n            default: 16,\r\n            description: 'default padding between facets.'\r\n        },\r\n        gridColor: {\r\n            type: 'string',\r\n            role: 'color',\r\n            default: '#000000'\r\n        },\r\n        gridOpacity: {\r\n            type: 'number',\r\n            minimum: 0,\r\n            maximum: 1,\r\n            default: 0.25\r\n        },\r\n        gridOffset: {\r\n            type: 'number',\r\n            default: 6\r\n        },\r\n        fill: {\r\n            type: 'string',\r\n            role: 'color',\r\n            default: 'rgba(0,0,0,0)'\r\n        },\r\n        fillOpacity: {\r\n            type: 'number',\r\n        },\r\n        stroke: {\r\n            type: 'string',\r\n            role: 'color',\r\n        },\r\n        strokeWidth: {\r\n            type: 'integer'\r\n        },\r\n        strokeOpacity: {\r\n            type: 'number'\r\n        },\r\n        strokeDash: {\r\n            type: 'array',\r\n            default: undefined\r\n        },\r\n        strokeDashOffset: {\r\n            type: 'integer',\r\n            description: 'The offset (in pixels) into which to begin drawing with the stroke dash array.'\r\n        }\r\n    }\r\n};\r\n//# sourceMappingURL=config.cell.schema.js.map","exports.marksConfig = {\r\n    type: 'object',\r\n    properties: {\r\n        filled: {\r\n            type: 'boolean',\r\n            default: false,\r\n            description: 'Whether the shape\\'s color should be used as fill color instead of stroke color.'\r\n        },\r\n        format: {\r\n            type: 'string',\r\n            default: '',\r\n            description: 'The formatting pattern for text value.' +\r\n                'If not defined, this will be determined automatically'\r\n        },\r\n        fill: {\r\n            type: 'string',\r\n            role: 'color',\r\n            default: '#000000'\r\n        },\r\n        opacity: {\r\n            type: 'number',\r\n            default: undefined,\r\n            minimum: 0,\r\n            maximum: 1\r\n        },\r\n        strokeWidth: {\r\n            type: 'integer',\r\n            default: 2,\r\n            minimum: 0\r\n        },\r\n        strokeDash: {\r\n            type: 'array',\r\n            default: undefined,\r\n            description: 'An array of alternating stroke, space lengths for creating dashed or dotted lines.'\r\n        },\r\n        strokeDashOffset: {\r\n            type: 'array',\r\n            default: undefined,\r\n            description: 'The offset (in pixels) into which to begin drawing with the stroke dash array.'\r\n        },\r\n        orient: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'The orientation of this area mark. One of horizontal (the default) or vertical.'\r\n        },\r\n        interpolate: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'The line interpolation method to use. One of linear, step-before, step-after, basis, basis-open, basis-closed, bundle, cardinal, cardinal-open, cardinal-closed, monotone.'\r\n        },\r\n        tension: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'Depending on the interpolation type, sets the tension parameter.'\r\n        },\r\n        align: {\r\n            type: 'string',\r\n            default: 'right',\r\n            enum: ['left', 'right', 'center'],\r\n            description: 'The horizontal alignment of the text. One of left, right, center.'\r\n        },\r\n        angle: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'The rotation angle of the text, in degrees.'\r\n        },\r\n        baseline: {\r\n            type: 'string',\r\n            default: 'middle',\r\n            enum: ['top', 'middle', 'bottom'],\r\n            description: 'The vertical alignment of the text. One of top, middle, bottom.'\r\n        },\r\n        dx: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the angle property.'\r\n        },\r\n        dy: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the angle property.'\r\n        },\r\n        font: {\r\n            type: 'string',\r\n            default: undefined,\r\n            role: 'font',\r\n            description: 'The typeface to set the text in (e.g., Helvetica Neue).'\r\n        },\r\n        fontStyle: {\r\n            type: 'string',\r\n            default: undefined,\r\n            enum: ['normal', 'italic'],\r\n            description: 'The font style (e.g., italic).'\r\n        },\r\n        fontWeight: {\r\n            type: 'string',\r\n            enum: ['normal', 'bold'],\r\n            default: undefined,\r\n            description: 'The font weight (e.g., bold).'\r\n        },\r\n        radius: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'Polar coordinate radial offset, in pixels, of the text label from the origin determined by the x and y properties.'\r\n        },\r\n        theta: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'Polar coordinate angle, in radians, of the text label from the origin determined by the x and y properties. Values for theta follow the same convention of arc mark startAngle and endAngle properties: angles are measured in radians, with 0 indicating \"north\".'\r\n        }\r\n    }\r\n};\r\n//# sourceMappingURL=config.marks.schema.js.map","var config_stack_schema_1 = require('./config.stack.schema');\r\nvar config_cell_schema_1 = require('./config.cell.schema');\r\nvar config_marks_schema_1 = require('./config.marks.schema');\r\nexports.config = {\r\n    type: 'object',\r\n    properties: {\r\n        viewport: {\r\n            type: 'array',\r\n            items: {\r\n                type: 'integer'\r\n            },\r\n            default: undefined,\r\n            description: 'The width and height of the on-screen viewport, in pixels. If necessary, clipping and scrolling will be applied.'\r\n        },\r\n        background: {\r\n            type: 'string',\r\n            role: 'color',\r\n            default: undefined,\r\n            description: 'CSS color property to use as background of visualization. Default is `\"transparent\"`.'\r\n        },\r\n        scene: {\r\n            type: 'object',\r\n            default: undefined,\r\n            description: 'An object to style the top-level scenegraph root. Available properties include `fill`, `fillOpacity`, `stroke`, `strokeOpacity`, `strokeWidth`, `strokeDash`, `strokeDashOffset`'\r\n        },\r\n        filterNull: {\r\n            type: 'object',\r\n            properties: {\r\n                nominal: { type: 'boolean', default: false },\r\n                ordinal: { type: 'boolean', default: false },\r\n                quantitative: { type: 'boolean', default: true },\r\n                temporal: { type: 'boolean', default: true }\r\n            }\r\n        },\r\n        textCellWidth: {\r\n            type: 'integer',\r\n            default: 90,\r\n            minimum: 0\r\n        },\r\n        sortLineBy: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'Data field to sort line by. ' +\r\n                '\\'-\\' prefix can be added to suggest descending order.'\r\n        },\r\n        stack: config_stack_schema_1.stackConfig,\r\n        cell: config_cell_schema_1.cellConfig,\r\n        marks: config_marks_schema_1.marksConfig,\r\n        singleBarOffset: {\r\n            type: 'integer',\r\n            default: 5,\r\n            minimum: 0\r\n        },\r\n        characterWidth: {\r\n            type: 'integer',\r\n            default: 6\r\n        },\r\n        numberFormat: {\r\n            type: 'string',\r\n            default: 's',\r\n            description: 'D3 Number format for axis labels and text tables.'\r\n        },\r\n        timeFormat: {\r\n            type: 'string',\r\n            default: '%Y-%m-%d',\r\n            description: 'Date format for axis labels.'\r\n        }\r\n    }\r\n};\r\n//# sourceMappingURL=config.schema.js.map","exports.stackConfig = {\r\n    type: ['boolean', 'object'],\r\n    default: {},\r\n    description: 'Enable stacking (for bar and area marks only).',\r\n    properties: {\r\n        sort: {\r\n            oneOf: [{\r\n                    type: 'string',\r\n                    enum: ['ascending', 'descending']\r\n                }, {\r\n                    type: 'array',\r\n                    items: { type: 'string' },\r\n                }],\r\n            description: 'Order of the stack. ' +\r\n                'This can be either a string (either \"descending\" or \"ascending\")' +\r\n                'or a list of fields to determine the order of stack layers.' +\r\n                'By default, stack uses descending order.'\r\n        },\r\n        offset: {\r\n            type: 'string',\r\n            enum: ['zero', 'center', 'normalize']\r\n        }\r\n    }\r\n};\r\n//# sourceMappingURL=config.stack.schema.js.map","exports.data = {\r\n    type: 'object',\r\n    properties: {\r\n        formatType: {\r\n            type: 'string',\r\n            enum: ['json', 'csv', 'tsv'],\r\n            default: 'json'\r\n        },\r\n        url: {\r\n            type: 'string',\r\n            default: undefined\r\n        },\r\n        values: {\r\n            type: 'array',\r\n            default: undefined,\r\n            description: 'Pass array of objects instead of a url to a file.',\r\n            items: {\r\n                type: 'object',\r\n                additionalProperties: true\r\n            }\r\n        },\r\n        filter: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'A string containing the filter Vega expression. Use `datum` to refer to the current data object.'\r\n        },\r\n        calculate: {\r\n            type: 'array',\r\n            default: undefined,\r\n            description: 'Calculate new field(s) using the provided expresssion(s). Calculation are applied before filter.',\r\n            items: {\r\n                type: 'object',\r\n                properties: {\r\n                    field: {\r\n                        type: 'string',\r\n                        description: 'The field in which to store the computed formula value.'\r\n                    },\r\n                    expr: {\r\n                        type: 'string',\r\n                        description: 'A string containing an expression for the formula. Use the variable `datum` to to refer to the current data object.'\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n//# sourceMappingURL=data.schema.js.map","var schemautil_1 = require('./schemautil');\r\nvar util_1 = require('../util');\r\nvar axis_schema_1 = require('./axis.schema');\r\nvar legend_schema_1 = require('./legend.schema');\r\nvar sort_schema_1 = require('./sort.schema');\r\nvar fielddef_schema_1 = require('./fielddef.schema');\r\nvar requiredNameType = {\r\n    required: ['field', 'type']\r\n};\r\nvar x = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.typicalField), requiredNameType, {\r\n    properties: {\r\n        scale: {\r\n            properties: {\r\n                padding: { default: 1 },\r\n                bandWidth: { default: 21 }\r\n            }\r\n        },\r\n        axis: axis_schema_1.axis,\r\n        sort: sort_schema_1.sort\r\n    }\r\n});\r\nvar y = util_1.duplicate(x);\r\nvar facet = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.onlyOrdinalField), requiredNameType, {\r\n    properties: {\r\n        axis: axis_schema_1.axis,\r\n        sort: sort_schema_1.sort\r\n    }\r\n});\r\nvar row = schemautil_1.merge(util_1.duplicate(facet));\r\nvar column = schemautil_1.merge(util_1.duplicate(facet));\r\nvar size = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.typicalField), {\r\n    properties: {\r\n        legend: legend_schema_1.legend,\r\n        sort: sort_schema_1.sort,\r\n        value: {\r\n            type: 'integer',\r\n            default: 30,\r\n            minimum: 0,\r\n            description: 'Size of marks.'\r\n        }\r\n    }\r\n});\r\nvar color = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.typicalField), {\r\n    properties: {\r\n        legend: legend_schema_1.legend,\r\n        sort: sort_schema_1.sort,\r\n        value: {\r\n            type: 'string',\r\n            role: 'color',\r\n            default: '#4682b4',\r\n            description: 'Color to be used for marks.'\r\n        },\r\n        scale: {\r\n            type: 'object',\r\n            properties: {\r\n                quantitativeRange: {\r\n                    type: 'array',\r\n                    default: ['#AFC6A3', '#09622A'],\r\n                    description: 'Color range to encode quantitative variables.',\r\n                    minItems: 2,\r\n                    maxItems: 2,\r\n                    items: {\r\n                        type: 'string',\r\n                        role: 'color'\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n});\r\nvar shape = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.onlyOrdinalField), {\r\n    properties: {\r\n        legend: legend_schema_1.legend,\r\n        sort: sort_schema_1.sort,\r\n        value: {\r\n            type: 'string',\r\n            enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\r\n            default: 'circle',\r\n            description: 'Mark to be used.'\r\n        }\r\n    }\r\n});\r\nvar detail = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.onlyOrdinalField), {\r\n    properties: {\r\n        sort: sort_schema_1.sort\r\n    }\r\n});\r\nvar text = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.typicalField), {\r\n    properties: {\r\n        sort: sort_schema_1.sort,\r\n        value: {\r\n            type: 'string',\r\n            default: 'Abc'\r\n        }\r\n    }\r\n});\r\nexports.encoding = {\r\n    type: 'object',\r\n    properties: {\r\n        x: x,\r\n        y: y,\r\n        row: row,\r\n        column: column,\r\n        size: size,\r\n        color: color,\r\n        shape: shape,\r\n        text: text,\r\n        detail: detail\r\n    }\r\n};\r\n//# sourceMappingURL=encoding.schema.js.map","var bin_schema_1 = require('./bin.schema');\r\nvar scale_schema_1 = require('./scale.schema');\r\nvar aggregate_1 = require('../aggregate');\r\nvar util_1 = require('../util');\r\nvar schemautil_1 = require('./schemautil');\r\nvar timeunit_1 = require('../timeunit');\r\nvar type_1 = require('../type');\r\nexports.fieldDef = {\r\n    type: 'object',\r\n    properties: {\r\n        field: {\r\n            type: 'string'\r\n        },\r\n        type: {\r\n            type: 'string',\r\n            enum: [type_1.NOMINAL, type_1.ORDINAL, type_1.QUANTITATIVE, type_1.TEMPORAL]\r\n        },\r\n        timeUnit: {\r\n            type: 'string',\r\n            enum: timeunit_1.TIMEUNITS,\r\n            supportedTypes: util_1.toMap([type_1.TEMPORAL])\r\n        },\r\n        bin: bin_schema_1.bin,\r\n    }\r\n};\r\nexports.aggregate = {\r\n    type: 'string',\r\n    enum: aggregate_1.AGGREGATE_OPS,\r\n    supportedEnums: {\r\n        quantitative: aggregate_1.AGGREGATE_OPS,\r\n        ordinal: ['median', 'min', 'max'],\r\n        nominal: [],\r\n        temporal: ['mean', 'median', 'min', 'max'],\r\n        '': ['count']\r\n    },\r\n    supportedTypes: util_1.toMap([type_1.QUANTITATIVE, type_1.NOMINAL, type_1.ORDINAL, type_1.TEMPORAL, ''])\r\n};\r\nexports.typicalField = schemautil_1.merge(util_1.duplicate(exports.fieldDef), {\r\n    properties: {\r\n        aggregate: exports.aggregate,\r\n        scale: scale_schema_1.typicalScale\r\n    }\r\n});\r\nexports.onlyOrdinalField = schemautil_1.merge(util_1.duplicate(exports.fieldDef), {\r\n    properties: {\r\n        scale: scale_schema_1.ordinalOnlyScale\r\n    }\r\n});\r\n//# sourceMappingURL=fielddef.schema.js.map","exports.legend = {\r\n    default: true,\r\n    description: 'Properties of a legend or boolean flag for determining whether to show it.',\r\n    oneOf: [{\r\n            type: 'object',\r\n            properties: {\r\n                orient: {\r\n                    type: 'string',\r\n                    default: undefined,\r\n                    description: 'The orientation of the legend. One of \"left\" or \"right\". This determines how the legend is positioned within the scene. The default is \"right\".'\r\n                },\r\n                title: {\r\n                    type: 'string',\r\n                    default: undefined,\r\n                    description: 'A title for the legend. (Shows field name and its function by default.)'\r\n                },\r\n                format: {\r\n                    type: 'string',\r\n                    default: undefined,\r\n                    description: 'An optional formatting pattern for legend labels. Vega uses D3\\'s format pattern.'\r\n                },\r\n                values: {\r\n                    type: 'array',\r\n                    default: undefined,\r\n                    description: 'Explicitly set the visible legend values.'\r\n                },\r\n                properties: {\r\n                    type: 'object',\r\n                    default: undefined,\r\n                    description: 'Optional mark property definitions for custom legend styling. '\r\n                }\r\n            }\r\n        }, {\r\n            type: 'boolean'\r\n        }]\r\n};\r\n//# sourceMappingURL=legend.schema.js.map","exports.mark = {\r\n    type: 'string',\r\n    enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\r\n};\r\n//# sourceMappingURL=mark.schema.js.map","var util_1 = require('../util');\r\nvar schemautil_1 = require('./schemautil');\r\nvar type_1 = require('../type');\r\nvar scale = {\r\n    type: 'object',\r\n    properties: {\r\n        type: {\r\n            type: 'string',\r\n            enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\r\n            default: 'linear',\r\n            supportedTypes: util_1.toMap([type_1.QUANTITATIVE])\r\n        },\r\n        domain: {\r\n            default: undefined,\r\n            type: ['array', 'object'],\r\n            description: 'The domain of the scale, representing the set of data values. For quantitative data, this can take the form of a two-element array with minimum and maximum values. For ordinal/categorical data, this may be an array of valid input values. The domain may also be specified by a reference to a data source.'\r\n        },\r\n        range: {\r\n            default: undefined,\r\n            type: ['array', 'object', 'string'],\r\n            description: 'The range of the scale, representing the set of visual values. For numeric values, the range can take the form of a two-element array with minimum and maximum values. For ordinal or quantized data, the range may by an array of desired output values, which are mapped to elements in the specified domain. For ordinal scales only, the range can be defined using a DataRef: the range values are then drawn dynamically from a backing data set.'\r\n        },\r\n        round: {\r\n            default: undefined,\r\n            type: 'boolean',\r\n            description: 'If true, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid.'\r\n        }\r\n    }\r\n};\r\nvar ordinalScaleMixin = {\r\n    properties: {\r\n        bandWidth: {\r\n            type: 'integer',\r\n            minimum: 0,\r\n            default: undefined\r\n        },\r\n        outerPadding: {\r\n            type: 'number',\r\n            default: undefined\r\n        },\r\n        padding: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'Applies spacing among ordinal elements in the scale range. The actual effect depends on how the scale is configured. If the __points__ parameter is `true`, the padding value is interpreted as a multiple of the spacing between points. A reasonable value is 1.0, such that the first and last point will be offset from the minimum and maximum value by half the distance between points. Otherwise, padding is typically in the range [0, 1] and corresponds to the fraction of space in the range interval to allocate to padding. A value of 0.5 means that the range band width will be equal to the padding width. For more, see the [D3 ordinal scale documentation](https://github.com/mbostock/d3/wiki/Ordinal-Scales).'\r\n        },\r\n        points: {\r\n            type: 'boolean',\r\n            default: undefined,\r\n            description: 'If true, distributes the ordinal values over a quantitative range at uniformly spaced points. The spacing of the points can be adjusted using the padding property. If false, the ordinal scale will construct evenly-spaced bands, rather than points.'\r\n        }\r\n    }\r\n};\r\nvar typicalScaleMixin = {\r\n    properties: {\r\n        clamp: {\r\n            type: 'boolean',\r\n            default: true,\r\n            description: 'If true, values that exceed the data domain are clamped to either the minimum or maximum range value'\r\n        },\r\n        nice: {\r\n            default: undefined,\r\n            oneOf: [\r\n                {\r\n                    type: 'boolean',\r\n                    description: 'If true, modifies the scale domain to use a more human-friendly number range (e.g., 7 instead of 6.96).'\r\n                }, {\r\n                    type: 'string',\r\n                    enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\r\n                    description: 'If specified, modifies the scale domain to use a more human-friendly value range. For time and utc scale types only, the nice value should be a string indicating the desired time interval; legal values are \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", or \"year\".'\r\n                }\r\n            ],\r\n            supportedTypes: util_1.toMap([type_1.QUANTITATIVE, type_1.TEMPORAL]),\r\n            description: ''\r\n        },\r\n        exponent: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'Sets the exponent of the scale transformation. For pow scale types only, otherwise ignored.'\r\n        },\r\n        zero: {\r\n            type: 'boolean',\r\n            description: 'If true, ensures that a zero baseline value is included in the scale domain. This option is ignored for non-quantitative scales.',\r\n            default: undefined,\r\n            supportedTypes: util_1.toMap([type_1.QUANTITATIVE, type_1.TEMPORAL])\r\n        },\r\n        useRawDomain: {\r\n            type: 'boolean',\r\n            default: false,\r\n            description: 'Uses the source data range as scale domain instead of ' +\r\n                'aggregated data for aggregate axis. ' +\r\n                'This option does not work with sum or count aggregate' +\r\n                'as they might have a substantially larger scale range.'\r\n        }\r\n    }\r\n};\r\nexports.ordinalOnlyScale = schemautil_1.merge(util_1.duplicate(scale), ordinalScaleMixin);\r\nexports.typicalScale = schemautil_1.merge(util_1.duplicate(scale), ordinalScaleMixin, typicalScaleMixin);\r\n//# sourceMappingURL=scale.schema.js.map","var schemaUtil = require('./schemautil');\r\nvar mark_schema_1 = require('./mark.schema');\r\nvar config_schema_1 = require('./config.schema');\r\nvar data_schema_1 = require('./data.schema');\r\nvar encoding_schema_1 = require('./encoding.schema');\r\nvar fielddef_schema_1 = require('./fielddef.schema');\r\nexports.aggregate = fielddef_schema_1.aggregate;\r\nexports.util = schemaUtil;\r\nexports.schema = {\r\n    $schema: 'http://json-schema.org/draft-04/schema#',\r\n    description: 'Schema for Vega-lite specification',\r\n    type: 'object',\r\n    required: ['mark', 'encoding'],\r\n    properties: {\r\n        name: {\r\n            type: 'string'\r\n        },\r\n        description: {\r\n            type: 'string'\r\n        },\r\n        data: data_schema_1.data,\r\n        mark: mark_schema_1.mark,\r\n        encoding: encoding_schema_1.encoding,\r\n        config: config_schema_1.config\r\n    }\r\n};\r\nfunction instantiate() {\r\n    return schemaUtil.instantiate(exports.schema);\r\n}\r\nexports.instantiate = instantiate;\r\n;\r\n//# sourceMappingURL=schema.js.map","var util = require('../util');\r\nfunction isEmpty(obj) {\r\n    return Object.keys(obj).length === 0;\r\n}\r\n;\r\nfunction extend(instance, schema) {\r\n    return merge(instantiate(schema), instance);\r\n}\r\nexports.extend = extend;\r\n;\r\nfunction instantiate(schema) {\r\n    var val;\r\n    if (schema === undefined) {\r\n        return undefined;\r\n    }\r\n    else if ('default' in schema) {\r\n        val = schema.default;\r\n        return util.isObject(val) ? util.duplicate(val) : val;\r\n    }\r\n    else if (schema.type === 'object') {\r\n        var instance = {};\r\n        for (var name in schema.properties) {\r\n            val = instantiate(schema.properties[name]);\r\n            if (val !== undefined) {\r\n                instance[name] = val;\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n    else if (schema.type === 'array') {\r\n        return undefined;\r\n    }\r\n    return undefined;\r\n}\r\nexports.instantiate = instantiate;\r\n;\r\nfunction subtract(instance, defaults) {\r\n    var changes = {};\r\n    for (var prop in instance) {\r\n        var def = defaults[prop];\r\n        var ins = instance[prop];\r\n        if (!defaults || def !== ins) {\r\n            if (typeof ins === 'object' && !util.isArray(ins) && def) {\r\n                var c = subtract(ins, def);\r\n                if (!isEmpty(c)) {\r\n                    changes[prop] = c;\r\n                }\r\n            }\r\n            else if (util.isArray(ins)) {\r\n                if (util.isArray(def)) {\r\n                    if (ins.length === def.length) {\r\n                        var equal = true;\r\n                        for (var i = 0; i < ins.length; i++) {\r\n                            if (ins[i] !== def[i]) {\r\n                                equal = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (equal) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                changes[prop] = ins;\r\n            }\r\n            else {\r\n                changes[prop] = ins;\r\n            }\r\n        }\r\n    }\r\n    return changes;\r\n}\r\nexports.subtract = subtract;\r\n;\r\nfunction merge(dest) {\r\n    var src = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        src[_i - 1] = arguments[_i];\r\n    }\r\n    for (var i = 0; i < src.length; i++) {\r\n        dest = merge_(dest, src[i]);\r\n    }\r\n    return dest;\r\n}\r\nexports.merge = merge;\r\n;\r\nfunction merge_(dest, src) {\r\n    if (typeof src !== 'object' || src === null) {\r\n        return dest;\r\n    }\r\n    for (var p in src) {\r\n        if (!src.hasOwnProperty(p)) {\r\n            continue;\r\n        }\r\n        if (src[p] === undefined) {\r\n            continue;\r\n        }\r\n        if (typeof src[p] !== 'object' || src[p] === null) {\r\n            dest[p] = src[p];\r\n        }\r\n        else if (typeof dest[p] !== 'object' || dest[p] === null) {\r\n            dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\r\n        }\r\n        else {\r\n            merge(dest[p], src[p]);\r\n        }\r\n    }\r\n    return dest;\r\n}\r\n//# sourceMappingURL=schemautil.js.map","var aggregate_1 = require('../aggregate');\r\nvar type_1 = require('../type');\r\nvar util_1 = require('../util');\r\nexports.sort = {\r\n    default: 'ascending',\r\n    supportedTypes: util_1.toMap([type_1.QUANTITATIVE, type_1.ORDINAL]),\r\n    oneOf: [\r\n        {\r\n            type: 'string',\r\n            enum: ['ascending', 'descending', 'unsorted']\r\n        },\r\n        {\r\n            type: 'object',\r\n            required: ['field', 'op'],\r\n            properties: {\r\n                field: {\r\n                    type: 'string',\r\n                    description: 'The field name to aggregate over.'\r\n                },\r\n                op: {\r\n                    type: 'string',\r\n                    enum: aggregate_1.AGGREGATE_OPS,\r\n                    description: 'The field name to aggregate over.'\r\n                },\r\n                order: {\r\n                    type: 'string',\r\n                    enum: ['ascending', 'descending']\r\n                }\r\n            }\r\n        }\r\n    ]\r\n};\r\n//# sourceMappingURL=sort.schema.js.map","var aggregate_1 = require('./aggregate');\r\nvar timeunit_1 = require('./timeunit');\r\nvar type_1 = require('./type');\r\nvar vlEncoding = require('./encoding');\r\nvar mark_1 = require('./mark');\r\nexports.DELIM = '|';\r\nexports.ASSIGN = '=';\r\nexports.TYPE = ',';\r\nexports.FUNC = '_';\r\nfunction shorten(spec) {\r\n    return 'mark' + exports.ASSIGN + spec.mark +\r\n        exports.DELIM + shortenEncoding(spec.encoding);\r\n}\r\nexports.shorten = shorten;\r\nfunction parse(shorthand, data, config) {\r\n    var split = shorthand.split(exports.DELIM), mark = split.shift().split(exports.ASSIGN)[1].trim(), encoding = parseEncoding(split.join(exports.DELIM));\r\n    var spec = {\r\n        mark: mark_1.Mark[mark],\r\n        encoding: encoding\r\n    };\r\n    if (data !== undefined) {\r\n        spec.data = data;\r\n    }\r\n    if (config !== undefined) {\r\n        spec.config = config;\r\n    }\r\n    return spec;\r\n}\r\nexports.parse = parse;\r\nfunction shortenEncoding(encoding) {\r\n    return vlEncoding.map(encoding, function (fieldDef, channel) {\r\n        return channel + exports.ASSIGN + shortenFieldDef(fieldDef);\r\n    }).join(exports.DELIM);\r\n}\r\nexports.shortenEncoding = shortenEncoding;\r\nfunction parseEncoding(encodingShorthand) {\r\n    return encodingShorthand.split(exports.DELIM).reduce(function (m, e) {\r\n        var split = e.split(exports.ASSIGN), enctype = split[0].trim(), fieldDefShorthand = split[1];\r\n        m[enctype] = parseFieldDef(fieldDefShorthand);\r\n        return m;\r\n    }, {});\r\n}\r\nexports.parseEncoding = parseEncoding;\r\nfunction shortenFieldDef(fieldDef) {\r\n    return (fieldDef.aggregate ? fieldDef.aggregate + exports.FUNC : '') +\r\n        (fieldDef.timeUnit ? fieldDef.timeUnit + exports.FUNC : '') +\r\n        (fieldDef.bin ? 'bin' + exports.FUNC : '') +\r\n        (fieldDef.field || '') + exports.TYPE + type_1.SHORT_TYPE[fieldDef.type];\r\n}\r\nexports.shortenFieldDef = shortenFieldDef;\r\nfunction shortenFieldDefs(fieldDefs, delim) {\r\n    if (delim === void 0) { delim = exports.DELIM; }\r\n    return fieldDefs.map(shortenFieldDef).join(delim);\r\n}\r\nexports.shortenFieldDefs = shortenFieldDefs;\r\nfunction parseFieldDef(fieldDefShorthand) {\r\n    var split = fieldDefShorthand.split(exports.TYPE), i;\r\n    var fieldDef = {\r\n        field: split[0].trim(),\r\n        type: type_1.TYPE_FROM_SHORT_TYPE[split[1].trim()]\r\n    };\r\n    for (i in aggregate_1.AGGREGATE_OPS) {\r\n        var a = aggregate_1.AGGREGATE_OPS[i];\r\n        if (fieldDef.field.indexOf(a + '_') === 0) {\r\n            fieldDef.field = fieldDef.field.substr(a.length + 1);\r\n            if (a === 'count' && fieldDef.field.length === 0)\r\n                fieldDef.field = '*';\r\n            fieldDef.aggregate = a;\r\n            break;\r\n        }\r\n    }\r\n    for (i in timeunit_1.TIMEUNITS) {\r\n        var tu = timeunit_1.TIMEUNITS[i];\r\n        if (fieldDef.field && fieldDef.field.indexOf(tu + '_') === 0) {\r\n            fieldDef.field = fieldDef.field.substr(fieldDef.field.length + 1);\r\n            fieldDef.timeUnit = tu;\r\n            break;\r\n        }\r\n    }\r\n    if (fieldDef.field && fieldDef.field.indexOf('bin_') === 0) {\r\n        fieldDef.field = fieldDef.field.substr(4);\r\n        fieldDef.bin = true;\r\n    }\r\n    return fieldDef;\r\n}\r\nexports.parseFieldDef = parseFieldDef;\r\n//# sourceMappingURL=shorthand.js.map","var Model_1 = require('./compiler/Model');\r\nvar channel_1 = require('./channel');\r\nvar vlEncoding = require('./encoding');\r\nvar mark_1 = require('./mark');\r\nvar util_1 = require('./util');\r\nfunction alwaysNoOcclusion(spec) {\r\n    return vlEncoding.isAggregate(spec.encoding);\r\n}\r\nexports.alwaysNoOcclusion = alwaysNoOcclusion;\r\nfunction fieldDefs(spec) {\r\n    return vlEncoding.fieldDefs(spec.encoding);\r\n}\r\nexports.fieldDefs = fieldDefs;\r\n;\r\nfunction getCleanSpec(spec) {\r\n    return new Model_1.Model(spec).toSpec(true);\r\n}\r\nexports.getCleanSpec = getCleanSpec;\r\nfunction isStack(spec) {\r\n    return (vlEncoding.has(spec.encoding, channel_1.COLOR) || vlEncoding.has(spec.encoding, channel_1.SHAPE)) &&\r\n        (spec.mark === mark_1.BAR || spec.mark === mark_1.AREA) &&\r\n        (!spec.config || !spec.config.stack !== false) &&\r\n        vlEncoding.isAggregate(spec.encoding);\r\n}\r\nexports.isStack = isStack;\r\nfunction transpose(spec) {\r\n    var oldenc = spec.encoding, encoding = util_1.duplicate(spec.encoding);\r\n    encoding.x = oldenc.y;\r\n    encoding.y = oldenc.x;\r\n    encoding.row = oldenc.column;\r\n    encoding.column = oldenc.row;\r\n    spec.encoding = encoding;\r\n    return spec;\r\n}\r\nexports.transpose = transpose;\r\n//# sourceMappingURL=spec.js.map","exports.TIMEUNITS = [\r\n    'year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'\r\n];\r\n//# sourceMappingURL=timeunit.js.map","(function (Type) {\r\n    Type[Type[\"QUANTITATIVE\"] = 'quantitative'] = \"QUANTITATIVE\";\r\n    Type[Type[\"ORDINAL\"] = 'ordinal'] = \"ORDINAL\";\r\n    Type[Type[\"TEMPORAL\"] = 'temporal'] = \"TEMPORAL\";\r\n    Type[Type[\"NOMINAL\"] = 'nominal'] = \"NOMINAL\";\r\n})(exports.Type || (exports.Type = {}));\r\nvar Type = exports.Type;\r\nexports.QUANTITATIVE = Type.QUANTITATIVE;\r\nexports.ORDINAL = Type.ORDINAL;\r\nexports.TEMPORAL = Type.TEMPORAL;\r\nexports.NOMINAL = Type.NOMINAL;\r\nexports.SHORT_TYPE = {\r\n    quantitative: 'Q',\r\n    temporal: 'T',\r\n    nominal: 'N',\r\n    ordinal: 'O'\r\n};\r\nexports.TYPE_FROM_SHORT_TYPE = {\r\n    Q: exports.QUANTITATIVE,\r\n    T: exports.TEMPORAL,\r\n    O: exports.ORDINAL,\r\n    N: exports.NOMINAL\r\n};\r\nfunction getFullName(type) {\r\n    var typeString = type;\r\n    return exports.TYPE_FROM_SHORT_TYPE[typeString.toUpperCase()] ||\r\n        typeString.toLowerCase();\r\n}\r\nexports.getFullName = getFullName;\r\n//# sourceMappingURL=type.js.map","function __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n__export(require('datalib/src/util'));\r\n__export(require('datalib/src/generate'));\r\n__export(require('datalib/src/stats'));\r\nfunction contains(array, item) {\r\n    return array.indexOf(item) > -1;\r\n}\r\nexports.contains = contains;\r\nfunction forEach(obj, f, thisArg) {\r\n    if (obj.forEach) {\r\n        obj.forEach.call(thisArg, f);\r\n    }\r\n    else {\r\n        for (var k in obj) {\r\n            f.call(thisArg, obj[k], k, obj);\r\n        }\r\n    }\r\n}\r\nexports.forEach = forEach;\r\nfunction reduce(obj, f, init, thisArg) {\r\n    if (obj.reduce) {\r\n        return obj.reduce.call(thisArg, f, init);\r\n    }\r\n    else {\r\n        for (var k in obj) {\r\n            init = f.call(thisArg, init, obj[k], k, obj);\r\n        }\r\n        return init;\r\n    }\r\n}\r\nexports.reduce = reduce;\r\nfunction map(obj, f, thisArg) {\r\n    if (obj.map) {\r\n        return obj.map.call(thisArg, f);\r\n    }\r\n    else {\r\n        var output = [];\r\n        for (var k in obj) {\r\n            output.push(f.call(thisArg, obj[k], k, obj));\r\n        }\r\n        return output;\r\n    }\r\n}\r\nexports.map = map;\r\nfunction any(arr, f) {\r\n    var i = 0, k;\r\n    for (k in arr) {\r\n        if (f(arr[k], k, i++))\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nexports.any = any;\r\nfunction all(arr, f) {\r\n    var i = 0, k;\r\n    for (k in arr) {\r\n        if (!f(arr[k], k, i++))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nexports.all = all;\r\nvar dlBin = require('datalib/src/bins/bins');\r\nfunction getbins(stats, maxbins) {\r\n    return dlBin({\r\n        min: stats.min,\r\n        max: stats.max,\r\n        maxbins: maxbins\r\n    });\r\n}\r\nexports.getbins = getbins;\r\nfunction error(message) {\r\n    console.error('[VL Error]', message);\r\n}\r\nexports.error = error;\r\n//# sourceMappingURL=util.js.map","var util_1 = require('./util');\r\nvar mark_1 = require('./mark');\r\nexports.DEFAULT_REQUIRED_CHANNEL_MAP = {\r\n    text: ['text'],\r\n    line: ['x', 'y'],\r\n    area: ['x', 'y']\r\n};\r\nexports.DEFAULT_SUPPORTED_CHANNEL_TYPE = {\r\n    bar: util_1.toMap(['row', 'column', 'x', 'y', 'size', 'color', 'detail']),\r\n    line: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\r\n    area: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\r\n    tick: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\r\n    circle: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\r\n    square: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\r\n    point: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail', 'shape']),\r\n    text: util_1.toMap(['row', 'column', 'size', 'color', 'text'])\r\n};\r\nfunction getEncodingMappingError(spec, requiredChannelMap, supportedChannelMap) {\r\n    if (requiredChannelMap === void 0) { requiredChannelMap = exports.DEFAULT_REQUIRED_CHANNEL_MAP; }\r\n    if (supportedChannelMap === void 0) { supportedChannelMap = exports.DEFAULT_SUPPORTED_CHANNEL_TYPE; }\r\n    var mark = spec.mark;\r\n    var encoding = spec.encoding;\r\n    var requiredChannels = requiredChannelMap[mark];\r\n    var supportedChannels = supportedChannelMap[mark];\r\n    for (var i in requiredChannels) {\r\n        if (!(requiredChannels[i] in encoding)) {\r\n            return 'Missing encoding channel \\\"' + requiredChannels[i] +\r\n                '\\\" for mark \\\"' + mark + '\\\"';\r\n        }\r\n    }\r\n    for (var channel in encoding) {\r\n        if (!supportedChannels[channel]) {\r\n            return 'Encoding channel \\\"' + channel +\r\n                '\\\" is not supported by mark type \\\"' + mark + '\\\"';\r\n        }\r\n    }\r\n    if (mark === mark_1.BAR && !encoding.x && !encoding.y) {\r\n        return 'Missing both x and y for bar';\r\n    }\r\n    return null;\r\n}\r\nexports.getEncodingMappingError = getEncodingMappingError;\r\n//# sourceMappingURL=validate.js.map"],"sourceRoot":"/source/"}